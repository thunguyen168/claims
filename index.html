<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claims Resilience Testing Tool</title>
<style>
/* ===== Reset & Base ===== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, sans-serif;
  background: #0f172a; color: #e2e8f0; min-height: 100vh;
}
a { color: #60a5fa; }

/* ===== Layout ===== */
.app { display: flex; min-height: 100vh; }
.sidebar {
  width: 280px; background: #1e293b; border-right: 1px solid #334155;
  padding: 20px; flex-shrink: 0; overflow-y: auto;
}
.main { flex: 1; padding: 24px; overflow-y: auto; }

/* ===== Navigation ===== */
.nav-title {
  font-size: 14px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 1px; color: #94a3b8; margin-bottom: 16px;
}
.nav-tabs { display: flex; gap: 4px; margin-bottom: 20px; }
.nav-tab {
  flex: 1; padding: 8px 4px; text-align: center; font-size: 12px; font-weight: 600;
  background: #334155; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer;
  transition: all 0.2s;
}
.nav-tab.active { background: #3b82f6; color: #fff; }
.nav-tab:hover:not(.active) { background: #475569; }

/* ===== Form Controls ===== */
.form-group { margin-bottom: 16px; }
.form-group label {
  display: block; font-size: 12px; font-weight: 600;
  color: #94a3b8; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;
}
select, input[type="number"], input[type="text"] {
  width: 100%; padding: 10px 12px; background: #0f172a; border: 1px solid #334155;
  border-radius: 8px; color: #e2e8f0; font-size: 14px; outline: none;
  transition: border-color 0.2s;
}
select:focus, input:focus { border-color: #3b82f6; }
.btn {
  padding: 10px 20px; border: none; border-radius: 8px; font-size: 14px;
  font-weight: 600; cursor: pointer; transition: all 0.2s; width: 100%;
}
.btn-primary { background: #3b82f6; color: #fff; }
.btn-primary:hover { background: #2563eb; }
.btn-success { background: #22c55e; color: #fff; }
.btn-success:hover { background: #16a34a; }
.btn-danger { background: #ef4444; color: #fff; margin-top: 8px; }
.btn-danger:hover { background: #dc2626; }
.btn-secondary { background: #475569; color: #e2e8f0; margin-top: 8px; }
.btn-secondary:hover { background: #64748b; }

/* ===== Cards ===== */
.card {
  background: #1e293b; border: 1px solid #334155; border-radius: 12px;
  padding: 20px; margin-bottom: 20px;
}
.card-title {
  font-size: 16px; font-weight: 700; margin-bottom: 16px;
  padding-bottom: 12px; border-bottom: 1px solid #334155;
}

/* ===== Metrics Grid ===== */
.metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
.metric-card {
  background: #1e293b; border: 1px solid #334155; border-radius: 12px;
  padding: 16px; text-align: center;
}
.metric-value { font-size: 28px; font-weight: 800; margin-bottom: 4px; }
.metric-label { font-size: 12px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px; }
.metric-green { color: #22c55e; }
.metric-yellow { color: #eab308; }
.metric-red { color: #ef4444; }
.metric-blue { color: #3b82f6; }

/* ===== Charts (Canvas-based) ===== */
.chart-container { position: relative; width: 100%; margin-bottom: 12px; }
canvas { width: 100%; display: block; }

/* ===== Capacity Table ===== */
.capacity-table { width: 100%; border-collapse: collapse; font-size: 13px; }
.capacity-table th, .capacity-table td {
  padding: 10px 12px; text-align: left; border-bottom: 1px solid #334155;
}
.capacity-table th { color: #94a3b8; font-weight: 600; text-transform: uppercase; font-size: 11px; letter-spacing: 0.5px; }
.status-ok { color: #22c55e; font-weight: 600; }
.status-warn { color: #eab308; font-weight: 600; }
.status-over { color: #ef4444; font-weight: 600; }

/* ===== Recommendations ===== */
.rec-list { list-style: none; }
.rec-list li { padding: 10px 12px; border-left: 3px solid #3b82f6; margin-bottom: 8px; background: #0f172a; border-radius: 0 8px 8px 0; font-size: 13px; }
.rec-list li.critical { border-left-color: #ef4444; }
.rec-list li.warning { border-left-color: #eab308; }
.rec-list li.info { border-left-color: #3b82f6; }

/* ===== Backend Admin ===== */
.admin-section { margin-bottom: 24px; }
.admin-section h3 { font-size: 14px; font-weight: 700; color: #94a3b8; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
.admin-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.admin-grid .form-group { margin-bottom: 8px; }
.site-card {
  background: #0f172a; border: 1px solid #334155; border-radius: 8px;
  padding: 16px; margin-bottom: 12px;
}
.site-card-header {
  display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;
}
.site-card-header h4 { font-size: 14px; font-weight: 600; }
.tag { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; }
.tag-active { background: #22c55e22; color: #22c55e; }

/* ===== Header ===== */
.header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 24px; flex-wrap: wrap; gap: 12px;
}
.header h1 { font-size: 22px; font-weight: 800; }
.header-sub { font-size: 13px; color: #94a3b8; }

/* ===== Responsive ===== */
@media (max-width: 900px) {
  .app { flex-direction: column; }
  .sidebar { width: 100%; border-right: none; border-bottom: 1px solid #334155; }
  .metrics { grid-template-columns: 1fr 1fr; }
}
@media (max-width: 500px) {
  .metrics { grid-template-columns: 1fr; }
  .admin-grid { grid-template-columns: 1fr; }
}

/* ===== Legend ===== */
.chart-legend { display: flex; gap: 16px; flex-wrap: wrap; margin-top: 8px; font-size: 12px; }
.legend-item { display: flex; align-items: center; gap: 6px; }
.legend-swatch { width: 12px; height: 12px; border-radius: 3px; }

/* ===== Toggle ===== */
.toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
.toggle-label { font-size: 13px; }
.toggle {
  width: 40px; height: 22px; background: #475569; border-radius: 11px;
  position: relative; cursor: pointer; transition: background 0.2s;
}
.toggle.on { background: #3b82f6; }
.toggle::after {
  content: ''; position: absolute; width: 18px; height: 18px; background: #fff;
  border-radius: 50%; top: 2px; left: 2px; transition: transform 0.2s;
}
.toggle.on::after { transform: translateX(18px); }

/* Progress bar */
.progress-bar { height: 8px; background: #334155; border-radius: 4px; overflow: hidden; margin-top: 4px; }
.progress-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }

/* Range slider */
.range-group { margin-bottom: 16px; }
.range-group label { display: block; font-size: 12px; font-weight: 600; color: #94a3b8; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
.range-value { font-size: 13px; color: #3b82f6; font-weight: 700; float: right; }
input[type="range"] {
  -webkit-appearance: none; width: 100%; height: 6px; background: #334155;
  border-radius: 3px; outline: none; margin-top: 4px;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 16px; height: 16px; background: #3b82f6;
  border-radius: 50%; cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
  width: 16px; height: 16px; background: #3b82f6; border-radius: 50%;
  cursor: pointer; border: none;
}

/* Surge resources */
.surge-entry {
  display: flex; gap: 6px; align-items: center; margin-bottom: 6px;
  background: #0f172a; padding: 6px 8px; border-radius: 6px; font-size: 12px;
}
.surge-entry select, .surge-entry input {
  width: auto; padding: 4px 6px; font-size: 12px;
}
.surge-entry .btn { width: auto; padding: 4px 8px; font-size: 11px; }
.surge-list { max-height: 160px; overflow-y: auto; margin-bottom: 8px; }

/* Report button */
.btn-report { background: #8b5cf6; color: #fff; margin-top: 8px; }
.btn-report:hover { background: #7c3aed; }
</style>
</head>
<body>

<div class="app">
  <!-- Sidebar -->
  <div class="sidebar">
    <div class="nav-title">Claims Resilience Tool</div>
    <div class="nav-tabs">
      <button class="nav-tab active" onclick="switchView('scenario')">Scenario</button>
      <button class="nav-tab" onclick="switchView('admin')">Admin</button>
    </div>

    <!-- Scenario Panel -->
    <div id="scenarioPanel">
      <div class="form-group">
        <label>Select Site</label>
        <select id="siteSelect" onchange="runScenario()"></select>
      </div>
      <div class="form-group">
        <label>Incident Type</label>
        <select id="incidentSelect" onchange="runScenario()">
          <option value="fire">Fire</option>
          <option value="explosion">Explosion</option>
          <option value="chemical">Chemical (Toxic Release)</option>
          <option value="nuclear">Nuclear (Radiological)</option>
        </select>
      </div>
      <div class="form-group">
        <label>Claim Type</label>
        <select id="claimTypeSelect" onchange="runScenario()">
          <option value="both">Both (Injury + Property)</option>
          <option value="injury">Injury Claims (Bodily Injury)</option>
          <option value="property">Property Claims (PD/BI/Economic)</option>
        </select>
      </div>
      <div class="form-group">
        <label>Time Horizon</label>
        <select id="timeHorizonSelect" onchange="runScenario()">
          <option value="short">Short Term (0-12 weeks)</option>
          <option value="medium">Medium Term (0-2 years)</option>
          <option value="long">Long Term (0-10+ years)</option>
        </select>
      </div>
      <div class="form-group">
        <label>Severity Level</label>
        <select id="severitySelect" onchange="runScenario()">
          <option value="minor">Minor - Small local impact</option>
          <option value="moderate">Moderate - Neighbourhood impact</option>
          <option value="major">Major - Town/city impact</option>
          <option value="catastrophic">Catastrophic - Regional impact</option>
        </select>
      </div>
      <!-- Peak week slider removed - using incident-specific claim patterns -->
      <div id="claimPatternNote" style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:10px;margin-bottom:16px;font-size:11px;color:#94a3b8">
        <strong style="color:#e2e8f0">Claim Pattern:</strong> <span id="patternDescription">Based on historical incident data</span>
      </div>

      <div class="form-group">
        <label>Surge Resources</label>
        <div class="surge-list" id="surgeList"></div>
        <button class="btn btn-secondary" style="font-size:12px;padding:6px 10px" onclick="addSurgeEntry()">+ Add Surge Staff</button>
      </div>

      <div class="form-group">
        <label>Target Processing Time (weeks)</label>
        <input type="number" id="targetWeeksInput" value="12" min="1" max="52" step="1" onchange="runScenario()">
        <div style="font-size:10px;color:#64748b;margin-top:2px">All claims should be processed within this many weeks</div>
      </div>

      <div style="margin-top:20px">
        <button class="btn btn-primary" onclick="runScenario()">Run Scenario</button>
        <button class="btn btn-report" onclick="generateReport()">Generate PDF Report</button>
      </div>
    </div>

    <!-- Admin Panel -->
    <div id="adminPanel" style="display:none">
      <div class="admin-section">
        <h3>Organisation Settings</h3>
        <div class="form-group">
          <label>Number of Claims Staff</label>
          <input type="number" id="adminStaff" value="8" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Working Days per Week</label>
          <input type="number" id="adminWorkDays" value="5" onchange="saveAdmin()">
        </div>
        <div style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;margin-top:8px">
          <div style="font-size:12px;font-weight:600;color:#94a3b8;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px">Calculated Weekly Capacity</div>
          <div id="calculatedCapacity" style="font-size:22px;font-weight:800;color:#3b82f6">10</div>
          <div id="capacityFormula" style="font-size:11px;color:#64748b;margin-top:2px">8 staff × 5 days ÷ 4.0 avg days/claim</div>
        </div>
      </div>

      <div class="admin-section">
        <h3>Claim Complexity Mix</h3>
        <p style="font-size:11px;color:#64748b;margin-bottom:10px">Adjust the proportion of claims at each processing speed. Remaining % uses standard processing time.</p>
        <div class="range-group">
          <label>Auto-Processed (0 days) <span class="range-value" id="autoProcessedValue">10%</span></label>
          <input type="range" id="autoProcessedSlider" min="0" max="100" value="10" oninput="updateComplexitySlider()">
        </div>
        <div class="range-group">
          <label>Fast Track - 2 Days <span class="range-value" id="twoDayValue">20%</span></label>
          <input type="range" id="twoDaySlider" min="0" max="100" value="20" oninput="updateComplexitySlider()">
        </div>
        <div class="range-group" style="margin-bottom:8px">
          <label>Medium Track <span class="range-value" id="customDayValue">30%</span></label>
          <input type="range" id="customDaySlider" min="0" max="100" value="30" oninput="updateComplexitySlider()">
        </div>
        <div class="form-group" style="margin-bottom:4px">
          <label>Medium Track Days</label>
          <input type="number" id="customDaysInput" value="3" min="1" max="20" step="0.5" onchange="updateComplexitySlider()">
        </div>
        <div class="form-group" style="margin-bottom:8px">
          <label>Standard Track Days</label>
          <input type="number" id="standardDaysInput" value="4" min="1" max="30" step="0.5" onchange="updateComplexitySlider()">
        </div>
        <div id="complexityBreakdown" style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:10px;font-size:12px">
        </div>
      </div>

      <div class="admin-section">
        <h3>Incident Multipliers</h3>
        <div class="form-group">
          <label>Fire Multiplier</label>
          <input type="number" id="multFire" value="1.0" step="0.1" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Explosion Multiplier</label>
          <input type="number" id="multExplosion" value="1.3" step="0.1" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Chemical Multiplier</label>
          <input type="number" id="multChemical" value="1.5" step="0.1" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Nuclear Multiplier</label>
          <input type="number" id="multNuclear" value="2.0" step="0.1" onchange="saveAdmin()">
        </div>
      </div>

      <div class="admin-section">
        <h3>Severity Claim Rates</h3>
        <p style="font-size:11px;color:#64748b;margin-bottom:8px">% of affected population filing claims</p>
        <div class="form-group">
          <label>Minor (%)</label>
          <input type="number" id="rateMinor" value="2" step="0.5" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Moderate (%)</label>
          <input type="number" id="rateModerate" value="8" step="0.5" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Major (%)</label>
          <input type="number" id="rateMajor" value="20" step="1" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Catastrophic (%)</label>
          <input type="number" id="rateCatastrophic" value="45" step="1" onchange="saveAdmin()">
        </div>
      </div>

      <div class="admin-section">
        <h3>Sites Management</h3>
        <div id="sitesAdminList"></div>
        <button class="btn btn-success" onclick="addSitePrompt()" style="margin-top:12px">+ Add Site</button>
      </div>

      <div class="admin-section" style="margin-top:20px">
        <button class="btn btn-secondary" onclick="exportConfig()">Export Config</button>
        <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">Import Config</button>
        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importConfig(event)">
      </div>
    </div>
  </div>

  <!-- Main Content -->
  <div class="main">
    <div class="header">
      <div>
        <h1 id="mainTitle">Claims Resilience Testing</h1>
        <div class="header-sub" id="mainSub">Select a scenario to begin analysis</div>
      </div>
    </div>

    <div id="resultsArea" style="display:none">
      <!-- Key Metrics -->
      <div class="metrics" id="metricsGrid"></div>

      <!-- Claims Forecast Chart -->
      <div class="card">
        <div class="card-title" id="forecastChartTitle">Claims Forecast Over 12 Weeks</div>
        <div class="chart-container">
          <canvas id="forecastChart" height="300"></canvas>
        </div>
        <div class="chart-legend" id="forecastLegend"></div>
      </div>

      <!-- Capacity Chart -->
      <div class="card">
        <div class="card-title">Capacity Utilisation</div>
        <div class="chart-container">
          <canvas id="capacityChart" height="250"></canvas>
        </div>
        <div class="chart-legend" id="capacityLegend"></div>
      </div>

      <!-- Weekly Breakdown Table -->
      <div class="card">
        <div class="card-title">Weekly Breakdown</div>
        <div style="overflow-x:auto">
          <table class="capacity-table" id="weeklyTable">
            <thead><tr>
              <th>Week</th><th>New Claims</th><th>Cumulative</th><th>Processed</th><th>Backlog</th><th>Status</th>
            </tr></thead>
            <tbody id="weeklyBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Resource Requirements -->
      <div class="card">
        <div class="card-title">Resource Requirements</div>
        <div id="resourceContent"></div>
      </div>

      <!-- Recommendations -->
      <div class="card">
        <div class="card-title">Recommendations</div>
        <ul class="rec-list" id="recList"></ul>
      </div>
    </div>

    <div id="welcomeArea">
      <div class="card" style="text-align:center;padding:60px 20px">
        <div style="font-size:48px;margin-bottom:16px">&#9881;</div>
        <h2 style="margin-bottom:12px">Claims Resilience Testing Tool</h2>
        <p style="color:#94a3b8;max-width:500px;margin:0 auto;line-height:1.6">
          Test your organisation's claim processing resilience across different incident scenarios.
          Select a site, incident type, and severity level from the sidebar to begin.
        </p>
        <p style="color:#64748b;margin-top:16px;font-size:13px">
          Use the Admin panel to configure sites, staff capacity, and processing parameters.
        </p>
      </div>
    </div>
  </div>
</div>

<script>
// ===== DEFAULT CONFIGURATION =====
const DEFAULT_CONFIG = {
  organisation: {
    staffCount: 8,
    workDaysPerWeek: 5
  },
  claimComplexity: {
    autoProcessedPct: 10,    // % of claims auto-processed (0 days)
    twoDayPct: 20,           // % of claims processed in 2 days
    customDayPct: 30,        // % of claims processed in customDays
    customDays: 3,           // number of days for the custom tier
    standardDays: 4,         // number of days for the standard tier
    // remainder = 100 - auto - twoDay - custom = processed in standardDays
  },
  incidentMultipliers: {
    fire: 1.0,
    explosion: 1.3,
    chemical: 1.5,
    nuclear: 2.0
  },
  // Claim type split ratios (injury vs property) by incident type
  claimTypeSplits: {
    fire: { injury: 0.25, property: 0.75 },        // Fire: mostly property claims
    explosion: { injury: 0.30, property: 0.70 },   // Explosion: more injury than fire
    chemical: { injury: 0.60, property: 0.40 },    // Chemical: injury-dominant (Bhopal pattern)
    nuclear: { injury: 0.35, property: 0.65 }      // Nuclear: property-heavy (evacuation/decontamination)
  },
  severityRates: {
    minor: 0.02,
    moderate: 0.08,
    major: 0.20,
    catastrophic: 0.45
  },
  sites: [
    { id: 'hinkley', name: 'Hinkley Point', location: 'Somerset, England', population: 35000, staffOnSite: 4000, active: true },
    { id: 'sizewell', name: 'Sizewell', location: 'Suffolk, England', population: 25000, staffOnSite: 2500, active: true },
    { id: 'heysham', name: 'Heysham', location: 'Lancashire, England', population: 30000, staffOnSite: 3000, active: true }
  ]
};

// ===== TIME HORIZON CONFIGURATIONS =====
const TIME_HORIZONS = {
  short: { weeks: 12, label: '12 Weeks', unitLabel: 'Week' },
  medium: { weeks: 104, label: '2 Years', unitLabel: 'Week' },  // 2 years = 104 weeks
  long: { weeks: 520, label: '10 Years', unitLabel: 'Month' }   // 10 years = 520 weeks, display as months
};

// ===== INCIDENT CLAIM PATTERNS =====
// Based on research: different claim patterns by incident type and claim type
// Returns an array of relative weights for each time period
const CLAIM_PATTERNS = {
  // Fire patterns
  fire: {
    // Fire injury: early spike (burns/inhalation), moderate tail for disability/long-term care
    injury: {
      short: { peakWeek: 2, shape: 'spike', tailWeight: 0.15 },
      medium: { peakWeek: 3, shape: 'fast_decay', tailWeight: 0.10 },
      long: { peakMonth: 2, shape: 'fast_decay', tailWeight: 0.05 }
    },
    // Fire property: immediate spike + re-scope waves, rebuild delays
    property: {
      short: { peakWeek: 3, shape: 'spike_rescope', tailWeight: 0.25 },
      medium: { peakWeek: 4, shape: 'extended_plateau', tailWeight: 0.20 },
      long: { peakMonth: 3, shape: 'gradual_decay', tailWeight: 0.10 }
    }
  },
  // Explosion patterns
  explosion: {
    // Explosion injury: lower count but high severity, early reporting
    injury: {
      short: { peakWeek: 1, shape: 'sharp_spike', tailWeight: 0.10 },
      medium: { peakWeek: 2, shape: 'fast_decay', tailWeight: 0.08 },
      long: { peakMonth: 1, shape: 'fast_decay', tailWeight: 0.05 }
    },
    // Explosion property: instant sharp spike (wide blast radius), BI develops over time
    property: {
      short: { peakWeek: 2, shape: 'sharp_spike', tailWeight: 0.30 },
      medium: { peakWeek: 3, shape: 'spike_bi_tail', tailWeight: 0.25 },
      long: { peakMonth: 2, shape: 'gradual_decay', tailWeight: 0.15 }
    }
  },
  // Chemical (toxic release) patterns - Bhopal-style
  chemical: {
    // Chemical injury: very fast spike (hours-weeks), then LONG tail (complications, disability, litigation)
    injury: {
      short: { peakWeek: 2, shape: 'sharp_spike', tailWeight: 0.35 },
      medium: { peakWeek: 3, shape: 'spike_long_tail', tailWeight: 0.40 },
      long: { peakMonth: 2, shape: 'very_long_tail', tailWeight: 0.50 }  // Decades of claims (Bhopal)
    },
    // Chemical property: mid-fast spike, depends on contamination persistence
    property: {
      short: { peakWeek: 4, shape: 'moderate_spike', tailWeight: 0.25 },
      medium: { peakWeek: 6, shape: 'extended_plateau', tailWeight: 0.30 },
      long: { peakMonth: 4, shape: 'contamination_tail', tailWeight: 0.35 }
    }
  },
  // Nuclear (radiological) patterns - Fukushima/Chernobyl-style
  nuclear: {
    // Nuclear injury: small immediate spike, VERY long tail (latency, thyroid cancers, monitoring)
    injury: {
      short: { peakWeek: 3, shape: 'low_early', tailWeight: 0.40 },
      medium: { peakWeek: 8, shape: 'delayed_rise', tailWeight: 0.55 },
      long: { peakMonth: 36, shape: 'latency_driven', tailWeight: 0.70 }  // Peak years later
    },
    // Nuclear property: very large early-to-mid spike (evacuation, decontamination), extended plateau
    property: {
      short: { peakWeek: 3, shape: 'rapid_rise', tailWeight: 0.50 },
      medium: { peakWeek: 6, shape: 'evacuation_plateau', tailWeight: 0.60 },
      long: { peakMonth: 12, shape: 'stigma_tail', tailWeight: 0.45 }
    }
  }
};

// Load config from localStorage or use defaults
let config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
try {
  const saved = localStorage.getItem('claimsToolConfig');
  if (saved) {
    config = JSON.parse(saved);
    // Migrate old configs missing claimComplexity
    if (!config.claimComplexity) config.claimComplexity = JSON.parse(JSON.stringify(DEFAULT_CONFIG.claimComplexity));
  }
} catch(e) {}

function saveConfig() {
  try { localStorage.setItem('claimsToolConfig', JSON.stringify(config)); } catch(e) {}
}

// ===== CAPACITY CALCULATION =====
// Calculate weighted average days per claim based on complexity mix
function getWeightedDaysPerClaim() {
  const cc = config.claimComplexity || DEFAULT_CONFIG.claimComplexity;
  const autoPct = cc.autoProcessedPct / 100;
  const twoDayPct = cc.twoDayPct / 100;
  const customPct = cc.customDayPct / 100;
  const standardPct = Math.max(0, 1 - autoPct - twoDayPct - customPct);
  const customDays = cc.customDays || 3;
  const standardDays = cc.standardDays || 4;
  // weighted average: auto=0 days, twoDay=2 days, custom=customDays, standard=standardDays
  return (autoPct * 0) + (twoDayPct * 2) + (customPct * customDays) + (standardPct * standardDays);
}

// Calculate weekly capacity from staff, working days, and weighted processing time
function getWeeklyCapacity() {
  const weightedDays = getWeightedDaysPerClaim();
  if (weightedDays <= 0) return config.organisation.staffCount * config.organisation.workDaysPerWeek;
  return Math.round(config.organisation.staffCount * config.organisation.workDaysPerWeek / weightedDays);
}

// ===== VIEW SWITCHING =====
function switchView(view) {
  document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
  if (view === 'scenario') {
    document.getElementById('scenarioPanel').style.display = '';
    document.getElementById('adminPanel').style.display = 'none';
    document.querySelectorAll('.nav-tab')[0].classList.add('active');
  } else {
    document.getElementById('scenarioPanel').style.display = 'none';
    document.getElementById('adminPanel').style.display = '';
    document.querySelectorAll('.nav-tab')[1].classList.add('active');
    loadAdmin();
  }
}

// ===== POPULATE SITE DROPDOWN =====
function populateSites() {
  const sel = document.getElementById('siteSelect');
  sel.innerHTML = '';
  config.sites.filter(s => s.active).forEach(s => {
    const opt = document.createElement('option');
    opt.value = s.id; opt.textContent = s.name + ' - ' + s.location;
    sel.appendChild(opt);
  });
}

// ===== ADMIN PANEL =====
function loadAdmin() {
  document.getElementById('adminStaff').value = config.organisation.staffCount;
  document.getElementById('adminWorkDays').value = config.organisation.workDaysPerWeek;
  // Complexity sliders
  const cc = config.claimComplexity || DEFAULT_CONFIG.claimComplexity;
  document.getElementById('autoProcessedSlider').value = cc.autoProcessedPct;
  document.getElementById('twoDaySlider').value = cc.twoDayPct;
  document.getElementById('customDaySlider').value = cc.customDayPct;
  document.getElementById('customDaysInput').value = cc.customDays;
  document.getElementById('standardDaysInput').value = cc.standardDays || 4;
  updateComplexityDisplay();
  document.getElementById('multFire').value = config.incidentMultipliers.fire;
  document.getElementById('multExplosion').value = config.incidentMultipliers.explosion;
  document.getElementById('multChemical').value = config.incidentMultipliers.chemical || 1.5;
  document.getElementById('multNuclear').value = config.incidentMultipliers.nuclear || 2.0;
  document.getElementById('rateMinor').value = (config.severityRates.minor * 100);
  document.getElementById('rateModerate').value = (config.severityRates.moderate * 100);
  document.getElementById('rateMajor').value = (config.severityRates.major * 100);
  document.getElementById('rateCatastrophic').value = (config.severityRates.catastrophic * 100);
  renderSitesAdmin();
}

function saveAdmin() {
  config.organisation.staffCount = parseInt(document.getElementById('adminStaff').value) || 8;
  config.organisation.workDaysPerWeek = parseInt(document.getElementById('adminWorkDays').value) || 5;
  config.incidentMultipliers.fire = parseFloat(document.getElementById('multFire').value) || 1.0;
  config.incidentMultipliers.explosion = parseFloat(document.getElementById('multExplosion').value) || 1.3;
  config.incidentMultipliers.chemical = parseFloat(document.getElementById('multChemical').value) || 1.5;
  config.incidentMultipliers.nuclear = parseFloat(document.getElementById('multNuclear').value) || 2.0;
  config.severityRates.minor = (parseFloat(document.getElementById('rateMinor').value) || 2) / 100;
  config.severityRates.moderate = (parseFloat(document.getElementById('rateModerate').value) || 8) / 100;
  config.severityRates.major = (parseFloat(document.getElementById('rateMajor').value) || 20) / 100;
  config.severityRates.catastrophic = (parseFloat(document.getElementById('rateCatastrophic').value) || 45) / 100;
  updateComplexityDisplay();
  saveConfig();
  populateSites();
}

function updateComplexitySlider() {
  let autoPct = parseInt(document.getElementById('autoProcessedSlider').value) || 0;
  let twoDayPct = parseInt(document.getElementById('twoDaySlider').value) || 0;
  let customPct = parseInt(document.getElementById('customDaySlider').value) || 0;
  const customDays = parseFloat(document.getElementById('customDaysInput').value) || 3;
  const standardDays = parseFloat(document.getElementById('standardDaysInput').value) || 4;

  // Clamp so total doesn't exceed 100
  if (autoPct + twoDayPct + customPct > 100) {
    customPct = Math.max(0, 100 - autoPct - twoDayPct);
    document.getElementById('customDaySlider').value = customPct;
  }

  if (!config.claimComplexity) config.claimComplexity = {};
  config.claimComplexity.autoProcessedPct = autoPct;
  config.claimComplexity.twoDayPct = twoDayPct;
  config.claimComplexity.customDayPct = customPct;
  config.claimComplexity.customDays = customDays;
  config.claimComplexity.standardDays = standardDays;

  updateComplexityDisplay();
  saveConfig();
}

function updateComplexityDisplay() {
  const cc = config.claimComplexity || DEFAULT_CONFIG.claimComplexity;
  const standardPct = Math.max(0, 100 - cc.autoProcessedPct - cc.twoDayPct - cc.customDayPct);
  const weightedDays = getWeightedDaysPerClaim();
  const weeklyCapacity = getWeeklyCapacity();

  document.getElementById('autoProcessedValue').textContent = cc.autoProcessedPct + '%';
  document.getElementById('twoDayValue').textContent = cc.twoDayPct + '%';
  document.getElementById('customDayValue').textContent = cc.customDayPct + '%';

  document.getElementById('calculatedCapacity').textContent = weeklyCapacity;
  document.getElementById('capacityFormula').textContent =
    config.organisation.staffCount + ' staff × ' + config.organisation.workDaysPerWeek + ' days ÷ ' + weightedDays.toFixed(1) + ' avg days/claim';

  document.getElementById('complexityBreakdown').innerHTML = `
    <div style="display:flex;gap:4px;height:16px;border-radius:4px;overflow:hidden;margin-bottom:8px">
      ${cc.autoProcessedPct > 0 ? `<div style="width:${cc.autoProcessedPct}%;background:#22c55e" title="Auto"></div>` : ''}
      ${cc.twoDayPct > 0 ? `<div style="width:${cc.twoDayPct}%;background:#3b82f6" title="2-day"></div>` : ''}
      ${cc.customDayPct > 0 ? `<div style="width:${cc.customDayPct}%;background:#eab308" title="${cc.customDays}-day"></div>` : ''}
      ${standardPct > 0 ? `<div style="width:${standardPct}%;background:#ef4444" title="Standard"></div>` : ''}
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;color:#94a3b8">
      <span><span style="color:#22c55e">●</span> Auto: ${cc.autoProcessedPct}%</span>
      <span><span style="color:#3b82f6">●</span> 2-day: ${cc.twoDayPct}%</span>
      <span><span style="color:#eab308">●</span> ${cc.customDays}-day: ${cc.customDayPct}%</span>
      <span><span style="color:#ef4444">●</span> Standard (${cc.standardDays || 4}d): ${standardPct}%</span>
    </div>
    <div style="margin-top:6px;color:#64748b;font-size:11px">Weighted avg: ${weightedDays.toFixed(1)} days/claim → <strong style="color:#3b82f6">${weeklyCapacity} claims/week</strong></div>
  `;
}

function renderSitesAdmin() {
  const container = document.getElementById('sitesAdminList');
  container.innerHTML = '';
  config.sites.forEach((site, idx) => {
    const div = document.createElement('div');
    div.className = 'site-card';
    div.innerHTML = `
      <div class="site-card-header">
        <h4>${site.name}</h4>
        <span class="tag ${site.active ? 'tag-active' : ''}">${site.active ? 'Active' : 'Inactive'}</span>
      </div>
      <div class="admin-grid">
        <div class="form-group">
          <label>Name</label>
          <input type="text" value="${site.name}" onchange="updateSite(${idx},'name',this.value)">
        </div>
        <div class="form-group">
          <label>Location</label>
          <input type="text" value="${site.location}" onchange="updateSite(${idx},'location',this.value)">
        </div>
        <div class="form-group">
          <label>Local Population</label>
          <input type="number" value="${site.population}" onchange="updateSite(${idx},'population',parseInt(this.value))">
        </div>
        <div class="form-group">
          <label>Staff on Site</label>
          <input type="number" value="${site.staffOnSite}" onchange="updateSite(${idx},'staffOnSite',parseInt(this.value))">
        </div>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button class="btn btn-secondary" style="width:auto;padding:6px 12px;font-size:12px" onclick="toggleSiteActive(${idx})">${site.active ? 'Deactivate' : 'Activate'}</button>
        <button class="btn btn-danger" style="width:auto;padding:6px 12px;font-size:12px" onclick="removeSite(${idx})">Remove</button>
      </div>
    `;
    container.appendChild(div);
  });
}

function updateSite(idx, field, value) {
  config.sites[idx][field] = value;
  if (field === 'name') {
    config.sites[idx].id = value.toLowerCase().replace(/[^a-z0-9]/g, '_');
  }
  saveConfig();
  populateSites();
  renderSitesAdmin();
}

function toggleSiteActive(idx) {
  config.sites[idx].active = !config.sites[idx].active;
  saveConfig();
  populateSites();
  renderSitesAdmin();
}

function removeSite(idx) {
  if (config.sites.length <= 1) { alert('You must have at least one site.'); return; }
  config.sites.splice(idx, 1);
  saveConfig();
  populateSites();
  renderSitesAdmin();
}

function addSitePrompt() {
  const name = prompt('Enter site name:');
  if (!name) return;
  const location = prompt('Enter location:') || '';
  const population = parseInt(prompt('Enter local population estimate:')) || 10000;
  const staff = parseInt(prompt('Enter staff on site:')) || 500;
  config.sites.push({
    id: name.toLowerCase().replace(/[^a-z0-9]/g, '_'),
    name: name,
    location: location,
    population: population,
    staffOnSite: staff,
    active: true
  });
  saveConfig();
  populateSites();
  renderSitesAdmin();
}

function exportConfig() {
  const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'claims-tool-config.json';
  a.click();
}

function importConfig(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      config = JSON.parse(e.target.result);
      saveConfig();
      populateSites();
      loadAdmin();
      alert('Configuration imported successfully.');
    } catch(err) {
      alert('Invalid config file.');
    }
  };
  reader.readAsText(file);
  event.target.value = '';
}

// ===== CLAIMS DISTRIBUTION MODEL =====
// Advanced distribution model based on incident type, claim type, and time horizon

// Generate distribution based on shape type
function generateShapedDistribution(numPeriods, peakPeriod, shape, tailWeight) {
  const raw = [];

  for (let i = 1; i <= numPeriods; i++) {
    let val = 0;

    switch (shape) {
      case 'sharp_spike':
        // Very sharp spike, fast decay
        val = Math.exp(-0.8 * Math.pow((i - peakPeriod) / 1.2, 2)) + 0.01;
        break;

      case 'spike':
        // Standard spike with moderate decay
        val = Math.exp(-0.5 * Math.pow((i - peakPeriod) / 1.8, 2)) + 0.015;
        break;

      case 'moderate_spike':
        // Moderate spike, wider spread
        val = Math.exp(-0.4 * Math.pow((i - peakPeriod) / 2.5, 2)) + 0.02;
        break;

      case 'spike_rescope':
        // Initial spike with secondary bump (re-scoping for fire property)
        val = Math.exp(-0.5 * Math.pow((i - peakPeriod) / 1.5, 2)) +
              0.3 * Math.exp(-0.5 * Math.pow((i - peakPeriod - 4) / 2, 2)) + 0.02;
        break;

      case 'spike_bi_tail':
        // Spike with business interruption tail
        val = Math.exp(-0.6 * Math.pow((i - peakPeriod) / 1.5, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.exp(-0.1 * (i - peakPeriod));
        }
        val += 0.015;
        break;

      case 'fast_decay':
        // Fast initial spike, quick decay
        val = Math.exp(-0.7 * Math.pow((i - peakPeriod) / 1.3, 2)) + 0.01;
        break;

      case 'spike_long_tail':
        // Chemical injury: sharp spike with very long tail
        val = Math.exp(-0.6 * Math.pow((i - peakPeriod) / 1.5, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.92, i - peakPeriod);  // Slow exponential decay
        }
        val += 0.02;
        break;

      case 'very_long_tail':
        // Chemical long-term: decades of claims
        val = Math.exp(-0.4 * Math.pow((i - peakPeriod) / 3, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.97, i - peakPeriod);  // Very slow decay
        }
        val += 0.025;
        break;

      case 'low_early':
        // Nuclear injury short-term: low early, building concern
        val = 0.02 + 0.08 * Math.exp(-0.3 * Math.pow((i - peakPeriod) / 2, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.85, i - peakPeriod);
        }
        break;

      case 'delayed_rise':
        // Nuclear injury medium-term: gradual rise to delayed peak
        val = 0.03 * (1 - Math.exp(-0.15 * i)) +
              0.15 * Math.exp(-0.3 * Math.pow((i - peakPeriod) / 4, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.95, i - peakPeriod);
        }
        break;

      case 'latency_driven':
        // Nuclear injury long-term: very delayed peak (latency effects)
        val = 0.02 + 0.02 * Math.log1p(i / 10);  // Slow initial rise
        val += 0.12 * Math.exp(-0.2 * Math.pow((i - peakPeriod) / 15, 2));  // Broad peak
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.98, i - peakPeriod);
        }
        break;

      case 'rapid_rise':
        // Nuclear property short-term: rapid rise for evacuation
        val = 0.05 + 0.25 * (1 - Math.exp(-0.5 * i));
        val *= Math.exp(-0.15 * Math.pow((i - peakPeriod) / 3, 2));
        val += tailWeight * 0.1;
        break;

      case 'evacuation_plateau':
        // Nuclear property medium-term: plateau from ongoing evacuation/displacement
        if (i < peakPeriod) {
          val = 0.1 * (1 - Math.exp(-0.3 * i));
        } else {
          val = 0.1 * Math.exp(-0.02 * (i - peakPeriod));  // Very slow decay (plateau)
        }
        val += 0.03;
        break;

      case 'extended_plateau':
        // Extended plateau shape
        val = Math.exp(-0.3 * Math.pow((i - peakPeriod) / 4, 2)) + 0.04;
        break;

      case 'gradual_decay':
        // Gradual decay from early peak
        val = Math.exp(-0.4 * Math.pow((i - peakPeriod) / 2.5, 2)) + 0.02;
        break;

      case 'contamination_tail':
        // Chemical property long-term: contamination discovery tail
        val = Math.exp(-0.35 * Math.pow((i - peakPeriod) / 5, 2));
        if (i > peakPeriod + 12) {
          val += 0.15 * Math.exp(-0.5 * Math.pow((i - peakPeriod - 36) / 10, 2));  // Secondary discovery
        }
        val += 0.02;
        break;

      case 'stigma_tail':
        // Nuclear property long-term: stigma and policy-driven resurgence
        val = Math.exp(-0.25 * Math.pow((i - peakPeriod) / 8, 2));
        // Add periodic resurgences (policy decisions, new disclosures)
        if (i > 24) val += 0.08 * Math.exp(-0.5 * Math.pow((i - 48) / 6, 2));
        if (i > 72) val += 0.06 * Math.exp(-0.5 * Math.pow((i - 84) / 6, 2));
        val += 0.025;
        break;

      default:
        // Fallback to standard bell curve
        val = Math.exp(-0.5 * Math.pow((i - peakPeriod) / 2, 2)) + 0.015;
    }

    raw.push(Math.max(0.005, val));
  }

  // Normalise to sum to 1
  const sum = raw.reduce((a, b) => a + b, 0);
  return raw.map(v => v / sum);
}

// Get distribution for a specific incident type, claim type, and time horizon
function getClaimDistribution(incident, claimType, timeHorizon) {
  const horizonConfig = TIME_HORIZONS[timeHorizon];
  const numPeriods = timeHorizon === 'long' ? 120 : horizonConfig.weeks;  // 120 months for long term

  // Get the pattern configuration
  const patterns = CLAIM_PATTERNS[incident] || CLAIM_PATTERNS.fire;
  const pattern = patterns[claimType] || patterns.injury;
  const horizonPattern = pattern[timeHorizon] || pattern.short;

  // Determine peak period
  let peakPeriod;
  if (timeHorizon === 'long') {
    peakPeriod = horizonPattern.peakMonth || 6;
  } else {
    peakPeriod = horizonPattern.peakWeek || 4;
  }

  return generateShapedDistribution(
    numPeriods,
    peakPeriod,
    horizonPattern.shape,
    horizonPattern.tailWeight
  );
}

function allocateClaimsByDistribution(totalClaims, distribution) {
  if (totalClaims <= 0 || distribution.length === 0) return [];
  const raw = distribution.map(d => totalClaims * d);
  const allocation = raw.map(val => Math.floor(val));
  let remainder = totalClaims - allocation.reduce((sum, val) => sum + val, 0);
  if (remainder > 0) {
    const ranked = raw
      .map((val, idx) => ({ idx, frac: val - Math.floor(val) }))
      .sort((a, b) => b.frac - a.frac);
    for (let i = 0; i < remainder; i++) {
      allocation[ranked[i % ranked.length].idx] += 1;
    }
  }
  return allocation;
}

// Legacy function for backward compatibility
function getWeeklyDistribution(peakWeek) {
  peakWeek = peakWeek || 4;
  const raw = [];
  const sigma = 1.5 + (peakWeek - 2) * 0.15;
  const mu = peakWeek;
  for (let w = 1; w <= 12; w++) {
    const val = Math.exp(-0.5 * Math.pow((w - mu) / sigma, 2)) + 0.015;
    raw.push(val);
  }
  const sum = raw.reduce((a, b) => a + b, 0);
  return raw.map(v => v / sum);
}

// ===== PATTERN DESCRIPTIONS =====
const PATTERN_DESCRIPTIONS = {
  fire: {
    injury: 'Early spike from burns/inhalation, moderate tail for disability cases',
    property: 'Immediate spike with re-scope waves as hidden damage discovered'
  },
  explosion: {
    injury: 'Sharp immediate spike, fast decay - lower count but high severity',
    property: 'Instant sharp spike across blast radius, BI develops over time'
  },
  chemical: {
    injury: 'Very fast spike, then very long tail (decades) from chronic effects and litigation',
    property: 'Mid-fast spike, potential resurgence from contamination discovery'
  },
  nuclear: {
    injury: 'Small early spike, very long latency tail (cancers may appear 5-20 years later)',
    property: 'Large early spike (evacuation/decontamination), extended plateau, stigma effects'
  }
};

function updatePatternDescription() {
  const incident = document.getElementById('incidentSelect').value;
  const claimType = document.getElementById('claimTypeSelect').value;
  const timeHorizon = document.getElementById('timeHorizonSelect').value;

  let description = '';
  const patterns = PATTERN_DESCRIPTIONS[incident] || PATTERN_DESCRIPTIONS.fire;

  if (claimType === 'both') {
    description = `Injury: ${patterns.injury}. Property: ${patterns.property}`;
  } else if (claimType === 'injury') {
    description = patterns.injury;
  } else {
    description = patterns.property;
  }

  // Add time horizon context
  if (timeHorizon === 'long') {
    description += ' (10+ year projection with latency effects)';
  } else if (timeHorizon === 'medium') {
    description += ' (2-year projection)';
  }

  const descEl = document.getElementById('patternDescription');
  if (descEl) descEl.textContent = description;
}

// ===== SURGE RESOURCE MANAGEMENT =====
let surgeEntries = []; // { startWeek, extraStaff }

function addSurgeEntry() {
  surgeEntries.push({ startWeek: 3, extraStaff: 4 });
  renderSurgeList();
  runScenario();
}

function removeSurgeEntry(idx) {
  surgeEntries.splice(idx, 1);
  renderSurgeList();
  runScenario();
}

function updateSurgeEntry(idx, field, value) {
  surgeEntries[idx][field] = parseInt(value) || 0;
  runScenario();
}

function renderSurgeList() {
  const container = document.getElementById('surgeList');
  container.innerHTML = '';
  surgeEntries.forEach((entry, idx) => {
    const div = document.createElement('div');
    div.className = 'surge-entry';
    div.innerHTML = `
      <span style="color:#94a3b8;white-space:nowrap">+</span>
      <input type="number" value="${entry.extraStaff}" min="1" max="100" style="width:50px"
        onchange="updateSurgeEntry(${idx},'extraStaff',this.value)">
      <span style="color:#94a3b8;white-space:nowrap">staff from W</span>
      <select onchange="updateSurgeEntry(${idx},'startWeek',this.value)">
        ${[1,2,3,4,5,6,7,8,9,10,11,12].map(w => `<option value="${w}" ${w === entry.startWeek ? 'selected' : ''}>W${w}</option>`).join('')}
      </select>
      <button class="btn btn-danger" onclick="removeSurgeEntry(${idx})">×</button>
    `;
    container.appendChild(div);
  });
}

let lastScenario = null;

// ===== SCENARIO CALCULATION =====
function runScenario() {
  const siteId = document.getElementById('siteSelect').value;
  const incident = document.getElementById('incidentSelect').value;
  const severity = document.getElementById('severitySelect').value;
  const claimType = document.getElementById('claimTypeSelect').value;
  const timeHorizon = document.getElementById('timeHorizonSelect').value;

  // Update pattern description
  updatePatternDescription();

  const site = config.sites.find(s => s.id === siteId);
  if (!site) return;

  const totalAffected = site.population + site.staffOnSite;
  const claimRate = config.severityRates[severity];
  const multiplier = config.incidentMultipliers[incident] || 1.0;
  const baseTotalClaims = Math.round(totalAffected * claimRate * multiplier);

  // Get claim type splits
  const splits = config.claimTypeSplits?.[incident] || DEFAULT_CONFIG.claimTypeSplits[incident] || { injury: 0.5, property: 0.5 };
  const splitSum = (splits.injury || 0) + (splits.property || 0);
  const injuryRatio = splitSum > 0 ? splits.injury / splitSum : 0.5;
  const normalizedSplits = { injury: injuryRatio, property: 1 - injuryRatio };

  // Calculate claims by type
  let injuryClaims = 0, propertyClaims = 0, totalClaims = 0;
  if (claimType === 'both') {
    injuryClaims = Math.round(baseTotalClaims * injuryRatio);
    propertyClaims = Math.max(0, baseTotalClaims - injuryClaims);
    totalClaims = baseTotalClaims;
  } else if (claimType === 'injury') {
    injuryClaims = baseTotalClaims;
    totalClaims = injuryClaims;
  } else {
    propertyClaims = baseTotalClaims;
    totalClaims = propertyClaims;
  }

  // Get time horizon configuration
  const horizonConfig = TIME_HORIZONS[timeHorizon];
  const isLongTerm = timeHorizon === 'long';
  const numPeriods = isLongTerm ? 120 : horizonConfig.weeks;  // 120 months for long, weeks otherwise

  // Get distributions for each claim type
  const injuryDist = injuryClaims > 0 ? getClaimDistribution(incident, 'injury', timeHorizon) : [];
  const propertyDist = propertyClaims > 0 ? getClaimDistribution(incident, 'property', timeHorizon) : [];

  // Calculate claims per period
  const injuryPerPeriod = allocateClaimsByDistribution(injuryClaims, injuryDist);
  const propertyPerPeriod = allocateClaimsByDistribution(propertyClaims, propertyDist);

  // Combined claims per period
  const periodicClaims = [];
  for (let i = 0; i < numPeriods; i++) {
    periodicClaims.push({
      injury: injuryPerPeriod[i] || 0,
      property: propertyPerPeriod[i] || 0,
      total: (injuryPerPeriod[i] || 0) + (propertyPerPeriod[i] || 0)
    });
  }

  const baseWeeklyCapacity = getWeeklyCapacity();
  const weightedDaysPerClaim = getWeightedDaysPerClaim();
  const baseClaimsPerStaff = weightedDaysPerClaim > 0 ? config.organisation.workDaysPerWeek / weightedDaysPerClaim : config.organisation.workDaysPerWeek;

  // Adjust capacity for time horizon
  let periodCapacityMultiplier = 1;
  if (timeHorizon === 'long') {
    periodCapacityMultiplier = 4.33;  // Monthly capacity (weeks per month)
  }
  const basePeriodCapacity = Math.round(baseWeeklyCapacity * periodCapacityMultiplier);

  const targetWeeks = parseInt(document.getElementById('targetWeeksInput').value) || 12;
  const targetPeriods = isLongTerm ? Math.ceil(targetWeeks / 4.33) : targetWeeks;

  // Build period breakdown with backlog
  const periods = [];
  let cumulative = 0, cumulativeInjury = 0, cumulativeProperty = 0;
  let totalProcessed = 0;
  let backlog = 0;
  let peakPeriod = 0;
  let peakClaims = 0;
  let periodsToClear = 0;

  const extraSimPeriods = isLongTerm ? 60 : 52;
  const maxSimPeriods = Math.max(numPeriods + extraSimPeriods, 52);

  for (let i = 0; i < maxSimPeriods; i++) {
    const periodNum = i + 1;

    // Calculate surge staff active this period (only for short/medium term)
    let surgeStaff = 0;
    if (!isLongTerm) {
      surgeEntries.forEach(entry => {
        if (periodNum >= entry.startWeek) surgeStaff += entry.extraStaff;
      });
    }
    const surgeCapacity = Math.round(surgeStaff * baseClaimsPerStaff * periodCapacityMultiplier);
    const effectiveCapacity = basePeriodCapacity + surgeCapacity;

    const newClaims = i < numPeriods ? (periodicClaims[i]?.total || 0) : 0;
    const newInjury = i < numPeriods ? (periodicClaims[i]?.injury || 0) : 0;
    const newProperty = i < numPeriods ? (periodicClaims[i]?.property || 0) : 0;

    cumulative += newClaims;
    cumulativeInjury += newInjury;
    cumulativeProperty += newProperty;

    const prevBacklog = backlog;
    const available = prevBacklog + newClaims;
    const processed = Math.min(available, effectiveCapacity);
    totalProcessed += processed;
    backlog = available - processed;

    if (newClaims > peakClaims) { peakClaims = newClaims; peakPeriod = periodNum; }

    periods.push({
      period: periodNum,
      week: isLongTerm ? null : periodNum,
      month: isLongTerm ? periodNum : null,
      newClaims,
      newInjury,
      newProperty,
      cumulative,
      cumulativeInjury,
      cumulativeProperty,
      processed,
      backlog,
      effectiveCapacity,
      surgeStaff,
      utilisation: effectiveCapacity > 0 ? (available / effectiveCapacity) * 100 : 0
    });

  }

  // Find when all claims are actually cleared (backlog reaches 0 after last incoming period)
  let lastIncomingPeriod = 0;
  for (let i = 0; i < periods.length; i++) {
    if (periods[i].newClaims > 0) {
      lastIncomingPeriod = periods[i].period;
    }
  }

  if (lastIncomingPeriod === 0) {
    periodsToClear = 0;
  } else {
    let clearPeriod = null;
    for (let i = lastIncomingPeriod - 1; i < periods.length; i++) {
      if (periods[i].backlog === 0) {
        clearPeriod = periods[i].period;
        break;
      }
    }
    periodsToClear = clearPeriod === null ? -1 : clearPeriod;
  }

  // Convert periods to weeks for display (short/medium term)
  const weeksToClear = isLongTerm ? (periodsToClear > 0 ? Math.round(periodsToClear * 4.33) : -1) : periodsToClear;
  // Compare in appropriate units: months for long-term, weeks for short/medium
  const canMeetTarget = isLongTerm
    ? (periodsToClear > 0 && periodsToClear <= targetPeriods)
    : (weeksToClear > 0 && weeksToClear <= targetWeeks);

  // Calculate resource needs
  const maxBacklog = Math.max(...periods.map(w => w.backlog));
  const overCapacityPeriods = periods.filter(w => w.newClaims > w.effectiveCapacity).length;
  const claimsPerStaffPerWeek = baseClaimsPerStaff;
  const staffNeededAtPeak = Math.ceil(peakClaims / (claimsPerStaffPerWeek * periodCapacityMultiplier));
  const additionalStaff = Math.max(0, staffNeededAtPeak - config.organisation.staffCount);

  // Store last scenario for report generation
  lastScenario = {
    site, incident, severity, claimType, timeHorizon, totalClaims, injuryClaims, propertyClaims,
    periods, peakPeriod, peakClaims, weeklyCapacity: baseWeeklyCapacity, periodCapacity: basePeriodCapacity,
    maxBacklog, overCapacityPeriods, additionalStaff, staffNeededAtPeak, claimsPerStaffPerWeek,
    surgeEntries: JSON.parse(JSON.stringify(surgeEntries)), weightedDaysPerClaim,
    targetWeeks, targetPeriods, weeksToClear, periodsToClear, canMeetTarget, isLongTerm, splits: normalizedSplits,
    maxSimPeriods,
    claimComplexity: JSON.parse(JSON.stringify(config.claimComplexity || DEFAULT_CONFIG.claimComplexity))
  };

  // Display results
  showResults(lastScenario);
}

function showResults(scenario) {
  const s = scenario;

  document.getElementById('welcomeArea').style.display = 'none';
  document.getElementById('resultsArea').style.display = '';

  const incidentLabels = { fire: 'Fire', explosion: 'Explosion', chemical: 'Chemical (Toxic Release)', nuclear: 'Nuclear (Radiological)' };
  const severityLabels = { minor: 'Minor', moderate: 'Moderate', major: 'Major', catastrophic: 'Catastrophic' };
  const claimTypeLabels = { both: 'All Claims', injury: 'Injury Claims', property: 'Property Claims' };
  const horizonLabels = { short: 'Short Term (12 Weeks)', medium: 'Medium Term (2 Years)', long: 'Long Term (10+ Years)' };

  document.getElementById('mainTitle').textContent = s.site.name + ' - Scenario Analysis';
  document.getElementById('mainSub').textContent =
    incidentLabels[s.incident] + ' | ' + severityLabels[s.severity] + ' | ' + claimTypeLabels[s.claimType] + ' | ' + horizonLabels[s.timeHorizon];

  // Period label based on time horizon
  const periodLabel = s.isLongTerm ? 'Month' : 'Week';
  const peakPeriodLabel = s.isLongTerm ? `Month ${s.peakPeriod}` : `Week ${s.peakPeriod}`;

  // Metrics
  const maxClearLabel = s.isLongTerm
    ? `${Math.round(s.maxSimPeriods / 12)}+ years`
    : `${s.maxSimPeriods}+ weeks`;
  const timeToClearLabel = s.weeksToClear === -1
    ? maxClearLabel
    : (s.isLongTerm ? s.periodsToClear + ' months' : s.weeksToClear + ' weeks');
  const targetLabel = s.isLongTerm ? s.targetPeriods + ' Months' : s.targetWeeks + ' Weeks';
  const showClaimBreakdown = s.claimType === 'both' && (s.injuryClaims > 0 || s.propertyClaims > 0);

  let metricsHTML = `
    <div class="metric-card">
      <div class="metric-value metric-blue">${s.totalClaims.toLocaleString()}</div>
      <div class="metric-label">Total Estimated Claims</div>
    </div>`;

  if (showClaimBreakdown) {
    metricsHTML += `
    <div class="metric-card">
      <div class="metric-value" style="color:#f97316">${s.injuryClaims.toLocaleString()}</div>
      <div class="metric-label">Injury Claims (${Math.round(s.splits.injury * 100)}%)</div>
    </div>
    <div class="metric-card">
      <div class="metric-value" style="color:#8b5cf6">${s.propertyClaims.toLocaleString()}</div>
      <div class="metric-label">Property Claims (${Math.round(s.splits.property * 100)}%)</div>
    </div>`;
  }

  metricsHTML += `
    <div class="metric-card">
      <div class="metric-value metric-yellow">${peakPeriodLabel}</div>
      <div class="metric-label">Peak ${periodLabel} (${s.peakClaims} claims)</div>
    </div>
    <div class="metric-card">
      <div class="metric-value ${s.canMeetTarget ? 'metric-green' : 'metric-red'}">${s.canMeetTarget ? 'Yes' : 'No'}</div>
      <div class="metric-label">Cleared Within ${targetLabel}?</div>
    </div>
    <div class="metric-card">
      <div class="metric-value ${s.canMeetTarget ? 'metric-green' : 'metric-red'}">${timeToClearLabel}</div>
      <div class="metric-label">Time to Clear All Claims</div>
    </div>
    <div class="metric-card">
      <div class="metric-value ${s.additionalStaff === 0 ? 'metric-green' : 'metric-red'}">+${s.additionalStaff}</div>
      <div class="metric-label">Additional Staff Required</div>
    </div>
    <div class="metric-card">
      <div class="metric-value metric-yellow">${s.maxBacklog.toLocaleString()}</div>
      <div class="metric-label">Peak Backlog</div>
    </div>
    <div class="metric-card">
      <div class="metric-value ${s.overCapacityPeriods === 0 ? 'metric-green' : 'metric-red'}">${s.overCapacityPeriods}</div>
      <div class="metric-label">${periodLabel}s Over Capacity</div>
    </div>
  `;
  document.getElementById('metricsGrid').innerHTML = metricsHTML;

  // Determine display periods - show full horizon for accuracy
  const displayPeriods = s.periods;

  // Period table
  const tbody = document.getElementById('weeklyBody');
  tbody.innerHTML = '';
  const hasSurge = displayPeriods.some(w => w.surgeStaff > 0);
  const hasClaimBreakdown = s.claimType === 'both';

  // Update table header
  const thead = document.querySelector('#weeklyTable thead tr');
  let headerHTML = `<th>${periodLabel}</th>`;
  if (hasClaimBreakdown) {
    headerHTML += `<th>Injury</th><th>Property</th>`;
  }
  headerHTML += `<th>New Claims</th><th>Cumulative</th><th>Capacity</th><th>Processed</th><th>Backlog</th>`;
  if (hasSurge) headerHTML += `<th>Surge Staff</th>`;
  headerHTML += `<th>Status</th>`;
  thead.innerHTML = headerHTML;

  displayPeriods.forEach(w => {
    const statusClass = w.backlog === 0 ? 'status-ok' : (w.backlog < w.effectiveCapacity ? 'status-warn' : 'status-over');
    const statusText = w.backlog === 0 ? 'On Track' : (w.backlog < w.effectiveCapacity ? 'Building Backlog' : 'Critical Backlog');
    const periodDisplay = s.isLongTerm ? `Month ${w.month}` : `Week ${w.week || w.period}`;

    const tr = document.createElement('tr');
    let rowHTML = `<td>${periodDisplay}</td>`;
    if (hasClaimBreakdown) {
      rowHTML += `<td style="color:#f97316">${w.newInjury.toLocaleString()}</td>`;
      rowHTML += `<td style="color:#8b5cf6">${w.newProperty.toLocaleString()}</td>`;
    }
    rowHTML += `
      <td>${w.newClaims.toLocaleString()}</td>
      <td>${w.cumulative.toLocaleString()}</td>
      <td>${w.effectiveCapacity.toLocaleString()}${w.surgeStaff > 0 ? ' <span style="color:#8b5cf6;font-size:11px">(+' + (w.effectiveCapacity - s.periodCapacity) + ')</span>' : ''}</td>
      <td>${w.processed.toLocaleString()}</td>
      <td>${w.backlog.toLocaleString()}</td>
      ${hasSurge ? '<td>' + (w.surgeStaff > 0 ? '+' + w.surgeStaff : '-') + '</td>' : ''}
      <td class="${statusClass}">${statusText}</td>
    `;
    tr.innerHTML = rowHTML;
    tbody.appendChild(tr);
  });

  // Resource requirements
  const capacityLabel = s.isLongTerm ? 'Claims/month' : 'Claims/week';
  const resHTML = `
    <div class="admin-grid" style="gap:16px">
      <div>
        <h4 style="margin-bottom:8px;font-size:14px">Current Capacity</h4>
        <p style="font-size:13px;color:#94a3b8">
          Staff: <strong style="color:#e2e8f0">${config.organisation.staffCount}</strong><br>
          ${capacityLabel}: <strong style="color:#e2e8f0">${s.periodCapacity}</strong><br>
          Claims/staff/week: <strong style="color:#e2e8f0">${s.claimsPerStaffPerWeek.toFixed(1)}</strong><br>
          Avg days per claim: <strong style="color:#e2e8f0">${s.weightedDaysPerClaim.toFixed(1)}</strong> (weighted)
        </p>
      </div>
      <div>
        <h4 style="margin-bottom:8px;font-size:14px">Required at Peak</h4>
        <p style="font-size:13px;color:#94a3b8">
          Staff needed: <strong style="color:#e2e8f0">${s.staffNeededAtPeak}</strong><br>
          Additional staff: <strong style="color:${s.additionalStaff > 0 ? '#ef4444' : '#22c55e'}">${s.additionalStaff > 0 ? '+' + s.additionalStaff : 'None'}</strong><br>
          Peak ${periodLabel.toLowerCase()} claims: <strong style="color:#e2e8f0">${s.peakClaims}</strong><br>
          ${periodLabel}s over capacity: <strong style="color:${s.overCapacityPeriods > 0 ? '#ef4444' : '#22c55e'}">${s.overCapacityPeriods}</strong>
        </p>
      </div>
      <div>
        <h4 style="margin-bottom:8px;font-size:14px">Target Assessment</h4>
        <p style="font-size:13px;color:#94a3b8">
          Target: <strong style="color:#e2e8f0">${targetLabel}</strong><br>
          Estimated clearance: <strong style="color:${s.canMeetTarget ? '#22c55e' : '#ef4444'}">${timeToClearLabel}</strong><br>
          Status: <strong style="color:${s.canMeetTarget ? '#22c55e' : '#ef4444'}">${s.canMeetTarget ? 'On Target' : 'Exceeds Target'}</strong>
        </p>
      </div>
    </div>
    <div style="margin-top:16px">
      <h4 style="margin-bottom:8px;font-size:14px">Capacity vs Demand at Peak</h4>
      <div class="progress-bar" style="height:20px;border-radius:6px">
        <div class="progress-fill" style="width:${Math.min(100, (s.periodCapacity / s.peakClaims) * 100)}%;background:${s.periodCapacity >= s.peakClaims ? '#22c55e' : '#ef4444'};border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:700">
          ${Math.round((s.periodCapacity / s.peakClaims) * 100)}%
        </div>
      </div>
      <p style="font-size:11px;color:#64748b;margin-top:4px">Current capacity covers ${Math.round((s.periodCapacity / s.peakClaims) * 100)}% of peak demand</p>
    </div>
  `;
  document.getElementById('resourceContent').innerHTML = resHTML;

  // Recommendations - incident-specific
  const recs = buildRecommendations(s);
  const recList = document.getElementById('recList');
  recList.innerHTML = '';
  recs.forEach(r => {
    const li = document.createElement('li');
    li.className = r.level;
    li.textContent = r.text;
    recList.appendChild(li);
  });

  // Draw charts
  const chartTitle = s.isLongTerm ? `Claims Forecast Over ${displayPeriods.length} Months` :
                     `Claims Forecast Over ${displayPeriods.length} Weeks`;
  document.getElementById('forecastChartTitle').textContent = chartTitle;
  drawForecastChartNew(displayPeriods, s);
  drawCapacityChartNew(displayPeriods, s);
}

// Build recommendations based on incident type and claim patterns
function buildRecommendations(s) {
  const recs = [];
  const periodLabel = s.isLongTerm ? 'month' : 'week';
  const maxClearLabel = s.isLongTerm
    ? `${Math.round(s.maxSimPeriods / 12)}+ years`
    : `${s.maxSimPeriods}+ weeks`;

  // General capacity recommendations
  if (!s.canMeetTarget) {
    const clearLabel = s.weeksToClear === -1 ? maxClearLabel : (s.isLongTerm ? s.periodsToClear + ' months' : s.weeksToClear + ' weeks');
    const targetLabel = s.isLongTerm ? s.targetPeriods + '-month' : s.targetWeeks + '-week';
    recs.push({ level: 'critical', text: `Claims will not be cleared within the ${targetLabel} target (estimated ${clearLabel}). Increase staff or add surge resources.` });
  }
  if (s.additionalStaff > 0) {
    recs.push({ level: 'critical', text: `Recruit or reassign ${s.additionalStaff} additional claims staff before peak ${periodLabel} (${s.isLongTerm ? 'Month' : 'Week'} ${s.peakPeriod}).` });
  }
  if (s.maxBacklog > s.periodCapacity * 2) {
    recs.push({ level: 'critical', text: `Peak backlog of ${s.maxBacklog.toLocaleString()} claims exceeds 2 ${periodLabel}s of capacity. Consider emergency outsourcing.` });
  }

  // Incident-specific recommendations
  if (s.incident === 'chemical') {
    recs.push({ level: 'warning', text: 'Chemical release incidents typically show a sharp early spike in injury claims followed by a very long tail (potentially decades) from chronic health effects, disability reassessments, and litigation.' });
    recs.push({ level: 'warning', text: 'Establish robust medical documentation protocols early - causation disputes are common in chemical exposure cases.' });
    if (s.claimType === 'both' || s.claimType === 'injury') {
      recs.push({ level: 'info', text: 'Consider setting up medical monitoring programs for affected populations - late-onset conditions may generate claims years later.' });
    }
    if (s.claimType === 'both' || s.claimType === 'property') {
      recs.push({ level: 'info', text: 'Property claims may resurge if contamination is discovered in soil or groundwater - plan for potential secondary waves.' });
    }
  }

  if (s.incident === 'nuclear') {
    recs.push({ level: 'warning', text: 'Nuclear incidents show distinct claim patterns: property/evacuation claims dominate early, while injury claims have very long latency (thyroid cancers may appear 5-20 years later).' });
    recs.push({ level: 'warning', text: 'Ensure specialist assessors are available for radiological claims. Standard claims staff may need additional training.' });
    if (s.claimType === 'both' || s.claimType === 'property') {
      recs.push({ level: 'info', text: 'Property claims will include evacuation costs, loss of use, decontamination, and stigma-related value impacts. Plan for extended displacement periods.' });
    }
    if (s.claimType === 'both' || s.claimType === 'injury') {
      recs.push({ level: 'info', text: 'Medical monitoring claims and psychological distress claims are common in nuclear incidents - establish clear eligibility criteria early.' });
    }
    if (s.isLongTerm) {
      recs.push({ level: 'info', text: 'Nuclear stigma effects can persist for decades and may cause claim resurgences following policy decisions or new disclosures.' });
    }
  }

  if (s.incident === 'explosion') {
    recs.push({ level: 'warning', text: 'Explosion incidents create immediate high-volume property claims across a wide blast radius. Expect thousands of third-party property damage claims.' });
    recs.push({ level: 'info', text: 'Business interruption claims often become the pacing item - they require forensic accounting and develop over time as downtime impacts become clear.' });
    if (s.claimType === 'both' || s.claimType === 'injury') {
      recs.push({ level: 'info', text: 'Injury claims are typically lower count but high severity (burns, amputations, TBI). Ensure specialist medical assessors are available.' });
    }
  }

  if (s.incident === 'fire') {
    recs.push({ level: 'info', text: 'Fire incidents often show property claim re-scope waves as hidden damage (soot, corrosion, smoke damage) is discovered weeks after the incident.' });
    if (s.claimType === 'both' || s.claimType === 'property') {
      recs.push({ level: 'info', text: 'Business interruption losses often exceed property damage for industrial fires (historically ~2.7x PD for petrochemical events).' });
    }
  }

  // Time horizon specific recommendations
  if (s.isLongTerm) {
    recs.push({ level: 'info', text: 'Long-term projections are subject to significant uncertainty. Plan for periodic reviews and model updates as actual claim patterns emerge.' });
    if (s.incident === 'chemical' || s.incident === 'nuclear') {
      recs.push({ level: 'info', text: 'Maintain claim tracking systems and reserves for potential late-emerging claims. Historical incidents show claims continuing for decades.' });
    }
  }

  // General recommendations
  if (s.totalClaims > 1000) {
    recs.push({ level: 'warning', text: 'High claim volume expected. Implement digital/online claim submission to reduce processing bottlenecks.' });
  }
  recs.push({ level: 'info', text: 'Establish a dedicated claims hotline and information centre for affected parties.' });
  recs.push({ level: 'info', text: 'Coordinate with local authorities and emergency services for efficient claim validation.' });

  return recs;
}

// ===== CHART DRAWING (Pure Canvas, no dependencies) =====

function drawForecastChartNew(periods, scenario) {
  const canvas = document.getElementById('forecastChart');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 300 * dpr;
  canvas.style.height = '300px';
  ctx.scale(dpr, dpr);
  const W = rect.width;
  const H = 300;

  ctx.clearRect(0, 0, W, H);

  const pad = { top: 20, right: 20, bottom: 40, left: 60 };
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;

  const s = scenario;
  const hasSurge = s.surgeEntries.length > 0 && !s.isLongTerm;
  const hasClaimBreakdown = s.claimType === 'both';
  const periodLabel = s.isLongTerm ? 'M' : 'W';

  const maxVal = Math.max(s.periodCapacity, ...periods.map(w => w.newClaims), ...periods.map(w => w.effectiveCapacity)) * 1.15;
  const xStep = chartW / Math.max(1, periods.length - 1);

  // Grid lines
  ctx.strokeStyle = '#334155';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (chartH / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(Math.round(maxVal - (maxVal / 4) * i).toLocaleString(), pad.left - 8, y + 4);
  }

  // X labels (sample if too many)
  ctx.textAlign = 'center';
  ctx.fillStyle = '#64748b';
  const labelStep = periods.length > 24 ? Math.ceil(periods.length / 12) : 1;
  periods.forEach((w, i) => {
    if (i % labelStep === 0 || i === periods.length - 1) {
      const periodNum = s.isLongTerm ? w.month : (w.week || w.period);
      ctx.fillText(periodLabel + periodNum, pad.left + i * xStep, H - pad.bottom + 20);
    }
  });

  // Capacity line
  const capY = pad.top + chartH - (s.periodCapacity / maxVal) * chartH;
  ctx.strokeStyle = '#ef4444';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath(); ctx.moveTo(pad.left, capY); ctx.lineTo(pad.left + chartW, capY); ctx.stroke();
  ctx.setLineDash([]);

  // If showing both claim types, draw stacked area
  if (hasClaimBreakdown) {
    // Property claims area (bottom)
    ctx.beginPath();
    ctx.moveTo(pad.left, pad.top + chartH);
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.newProperty / maxVal) * chartH;
      ctx.lineTo(x, y);
    });
    ctx.lineTo(pad.left + (periods.length - 1) * xStep, pad.top + chartH);
    ctx.closePath();
    const gradProp = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
    gradProp.addColorStop(0, 'rgba(139,92,246,0.4)');
    gradProp.addColorStop(1, 'rgba(139,92,246,0.05)');
    ctx.fillStyle = gradProp;
    ctx.fill();

    // Injury claims area (on top of property)
    ctx.beginPath();
    ctx.moveTo(pad.left, pad.top + chartH - (periods[0].newProperty / maxVal) * chartH);
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const yBase = pad.top + chartH - (w.newProperty / maxVal) * chartH;
      const yTop = yBase - (w.newInjury / maxVal) * chartH;
      ctx.lineTo(x, yTop);
    });
    for (let i = periods.length - 1; i >= 0; i--) {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (periods[i].newProperty / maxVal) * chartH;
      ctx.lineTo(x, y);
    }
    ctx.closePath();
    const gradInj = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
    gradInj.addColorStop(0, 'rgba(249,115,22,0.4)');
    gradInj.addColorStop(1, 'rgba(249,115,22,0.05)');
    ctx.fillStyle = gradInj;
    ctx.fill();

    // Draw injury line
    ctx.strokeStyle = '#f97316';
    ctx.lineWidth = 2;
    ctx.beginPath();
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - ((w.newProperty + w.newInjury) / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Draw property line
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.newProperty / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

  } else {
    // Single claim type - draw area fill
    ctx.beginPath();
    ctx.moveTo(pad.left, pad.top + chartH);
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.newClaims / maxVal) * chartH;
      ctx.lineTo(x, y);
    });
    ctx.lineTo(pad.left + (periods.length - 1) * xStep, pad.top + chartH);
    ctx.closePath();
    const grad = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
    grad.addColorStop(0, 'rgba(59,130,246,0.3)');
    grad.addColorStop(1, 'rgba(59,130,246,0.02)');
    ctx.fillStyle = grad;
    ctx.fill();

    // Claims line
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 3;
    ctx.beginPath();
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.newClaims / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Data points (only if not too many)
    if (periods.length <= 24) {
      periods.forEach((w, i) => {
        const x = pad.left + i * xStep;
        const y = pad.top + chartH - (w.newClaims / maxVal) * chartH;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#3b82f6';
        ctx.fill();
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 2;
        ctx.stroke();
      });
    }
  }

  // Cumulative line (secondary Y-axis scale)
  const maxCum = periods[periods.length - 1].cumulative * 1.1;
  ctx.strokeStyle = '#22c55e';
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 3]);
  ctx.beginPath();
  periods.forEach((w, i) => {
    const x = pad.left + i * xStep;
    const y = pad.top + chartH - (w.cumulative / maxCum) * chartH;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();
  ctx.setLineDash([]);

  // Effective capacity line (if surge active)
  if (hasSurge) {
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 3]);
    ctx.beginPath();
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.effectiveCapacity / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Legend
  let legendHTML = '';
  if (hasClaimBreakdown) {
    legendHTML = `
      <div class="legend-item"><div class="legend-swatch" style="background:#f97316"></div> Injury Claims</div>
      <div class="legend-item"><div class="legend-swatch" style="background:#8b5cf6"></div> Property Claims</div>
    `;
  } else {
    legendHTML = `<div class="legend-item"><div class="legend-swatch" style="background:#3b82f6"></div> New Claims/${s.isLongTerm ? 'Month' : 'Week'}</div>`;
  }
  legendHTML += `
    <div class="legend-item"><div class="legend-swatch" style="background:#22c55e"></div> Cumulative Claims</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#ef4444"></div> Base Capacity (${s.periodCapacity})</div>
  `;
  if (hasSurge) {
    legendHTML += `<div class="legend-item"><div class="legend-swatch" style="background:#a855f7"></div> Effective Capacity (with surge)</div>`;
  }
  document.getElementById('forecastLegend').innerHTML = legendHTML;
}

function drawCapacityChartNew(periods, scenario) {
  const canvas = document.getElementById('capacityChart');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 250 * dpr;
  canvas.style.height = '250px';
  ctx.scale(dpr, dpr);
  const W = rect.width;
  const H = 250;

  ctx.clearRect(0, 0, W, H);

  const pad = { top: 20, right: 20, bottom: 40, left: 60 };
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;

  const s = scenario;
  const periodLabel = s.isLongTerm ? 'M' : 'W';

  // Sample if too many periods
  let displayPeriods = periods;
  if (periods.length > 24) {
    const step = Math.ceil(periods.length / 24);
    displayPeriods = periods.filter((_, i) => i % step === 0);
  }

  const barW = (chartW / displayPeriods.length) * 0.7;
  const gap = (chartW / displayPeriods.length) * 0.3;

  const maxUtil = Math.max(100, ...displayPeriods.map(w => w.utilisation)) * 1.15;

  // Grid
  ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
  [0, 25, 50, 75, 100].forEach(pct => {
    const y = pad.top + chartH - (pct / maxUtil) * chartH;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b'; ctx.font = '11px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText(pct + '%', pad.left - 8, y + 4);
  });

  // 100% line
  const y100 = pad.top + chartH - (100 / maxUtil) * chartH;
  ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
  ctx.beginPath(); ctx.moveTo(pad.left, y100); ctx.lineTo(pad.left + chartW, y100); ctx.stroke();
  ctx.setLineDash([]);

  // Bars
  displayPeriods.forEach((w, i) => {
    const x = pad.left + i * (chartW / displayPeriods.length) + gap / 2;
    const barH = (w.utilisation / maxUtil) * chartH;
    const y = pad.top + chartH - barH;

    let color;
    if (w.utilisation <= 70) color = '#22c55e';
    else if (w.utilisation <= 100) color = '#eab308';
    else color = '#ef4444';

    ctx.fillStyle = color;
    ctx.beginPath();
    const r = 3;
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + barW - r, y);
    ctx.quadraticCurveTo(x + barW, y, x + barW, y + r);
    ctx.lineTo(x + barW, pad.top + chartH);
    ctx.lineTo(x, pad.top + chartH);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.fill();

    // Label (only if not too many bars)
    if (displayPeriods.length <= 16) {
      ctx.fillStyle = '#e2e8f0'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText(Math.round(w.utilisation) + '%', x + barW / 2, y - 6);
    }

    // X label
    const periodNum = s.isLongTerm ? w.month : (w.week || w.period);
    ctx.fillStyle = '#64748b'; ctx.font = '11px sans-serif';
    ctx.fillText(periodLabel + periodNum, x + barW / 2, H - pad.bottom + 20);
  });

  document.getElementById('capacityLegend').innerHTML = `
    <div class="legend-item"><div class="legend-swatch" style="background:#22c55e"></div> Under 70%</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#eab308"></div> 70-100%</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#ef4444"></div> Over Capacity</div>
  `;
}

// Legacy chart functions for backward compatibility
function drawForecastChart(weeks, capacity, hasSurge) {
  const canvas = document.getElementById('forecastChart');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 300 * dpr;
  canvas.style.height = '300px';
  ctx.scale(dpr, dpr);
  const W = rect.width;
  const H = 300;

  ctx.clearRect(0, 0, W, H);

  const pad = { top: 20, right: 20, bottom: 40, left: 60 };
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;

  const maxVal = Math.max(capacity, ...weeks.map(w => w.newClaims), ...weeks.map(w => w.effectiveCapacity)) * 1.15;
  const xStep = chartW / 11;

  // Grid lines
  ctx.strokeStyle = '#334155';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (chartH / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(Math.round(maxVal - (maxVal / 4) * i).toLocaleString(), pad.left - 8, y + 4);
  }

  // X labels
  ctx.textAlign = 'center';
  ctx.fillStyle = '#64748b';
  weeks.forEach((w, i) => {
    ctx.fillText('W' + w.week, pad.left + i * xStep, H - pad.bottom + 20);
  });

  // Capacity line
  const capY = pad.top + chartH - (capacity / maxVal) * chartH;
  ctx.strokeStyle = '#ef4444';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath(); ctx.moveTo(pad.left, capY); ctx.lineTo(pad.left + chartW, capY); ctx.stroke();
  ctx.setLineDash([]);

  // Area fill under claims curve
  ctx.beginPath();
  ctx.moveTo(pad.left, pad.top + chartH);
  weeks.forEach((w, i) => {
    const x = pad.left + i * xStep;
    const y = pad.top + chartH - (w.newClaims / maxVal) * chartH;
    if (i === 0) ctx.lineTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.lineTo(pad.left + 11 * xStep, pad.top + chartH);
  ctx.closePath();
  const grad = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
  grad.addColorStop(0, 'rgba(59,130,246,0.3)');
  grad.addColorStop(1, 'rgba(59,130,246,0.02)');
  ctx.fillStyle = grad;
  ctx.fill();

  // Claims line with smooth curve
  ctx.strokeStyle = '#3b82f6';
  ctx.lineWidth = 3;
  ctx.beginPath();
  const points = weeks.map((w, i) => ({
    x: pad.left + i * xStep,
    y: pad.top + chartH - (w.newClaims / maxVal) * chartH
  }));

  // Draw smooth curve using bezier
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    const prev = points[i - 1];
    const curr = points[i];
    const cpx = (prev.x + curr.x) / 2;
    ctx.bezierCurveTo(cpx, prev.y, cpx, curr.y, curr.x, curr.y);
  }
  ctx.stroke();

  // Data points
  points.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#3b82f6';
    ctx.fill();
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 2;
    ctx.stroke();
  });

  // Cumulative line
  const maxCum = weeks[weeks.length - 1].cumulative * 1.1;
  ctx.strokeStyle = '#22c55e';
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 3]);
  ctx.beginPath();
  weeks.forEach((w, i) => {
    const x = pad.left + i * xStep;
    const y = pad.top + chartH - (w.cumulative / maxCum) * chartH;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();
  ctx.setLineDash([]);

  // Effective capacity line (if surge active)
  if (hasSurge) {
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 3]);
    ctx.beginPath();
    weeks.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.effectiveCapacity / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Legend
  document.getElementById('forecastLegend').innerHTML = `
    <div class="legend-item"><div class="legend-swatch" style="background:#3b82f6"></div> New Claims/Week</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#22c55e"></div> Cumulative Claims</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#ef4444"></div> Base Capacity (${capacity})</div>
    ${hasSurge ? '<div class="legend-item"><div class="legend-swatch" style="background:#8b5cf6"></div> Effective Capacity (with surge)</div>' : ''}
  `;
}

function drawCapacityChart(weeks, capacity) {
  const canvas = document.getElementById('capacityChart');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 250 * dpr;
  canvas.style.height = '250px';
  ctx.scale(dpr, dpr);
  const W = rect.width;
  const H = 250;

  ctx.clearRect(0, 0, W, H);

  const pad = { top: 20, right: 20, bottom: 40, left: 60 };
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;
  const barW = (chartW / 12) * 0.7;
  const gap = (chartW / 12) * 0.3;

  const maxUtil = Math.max(100, ...weeks.map(w => w.utilisation)) * 1.15;

  // Grid
  ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
  [0, 25, 50, 75, 100].forEach(pct => {
    const y = pad.top + chartH - (pct / maxUtil) * chartH;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b'; ctx.font = '11px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText(pct + '%', pad.left - 8, y + 4);
  });

  // 100% line
  const y100 = pad.top + chartH - (100 / maxUtil) * chartH;
  ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
  ctx.beginPath(); ctx.moveTo(pad.left, y100); ctx.lineTo(pad.left + chartW, y100); ctx.stroke();
  ctx.setLineDash([]);

  // Bars
  weeks.forEach((w, i) => {
    const x = pad.left + i * (chartW / 12) + gap / 2;
    const barH = (w.utilisation / maxUtil) * chartH;
    const y = pad.top + chartH - barH;

    let color;
    if (w.utilisation <= 70) color = '#22c55e';
    else if (w.utilisation <= 100) color = '#eab308';
    else color = '#ef4444';

    ctx.fillStyle = color;
    ctx.beginPath();
    // Rounded top corners
    const r = 3;
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + barW - r, y);
    ctx.quadraticCurveTo(x + barW, y, x + barW, y + r);
    ctx.lineTo(x + barW, pad.top + chartH);
    ctx.lineTo(x, pad.top + chartH);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.fill();

    // Label
    ctx.fillStyle = '#e2e8f0'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(Math.round(w.utilisation) + '%', x + barW / 2, y - 6);

    // X label
    ctx.fillStyle = '#64748b'; ctx.font = '11px sans-serif';
    ctx.fillText('W' + w.week, x + barW / 2, H - pad.bottom + 20);
  });

  document.getElementById('capacityLegend').innerHTML = `
    <div class="legend-item"><div class="legend-swatch" style="background:#22c55e"></div> Under 70%</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#eab308"></div> 70-100%</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#ef4444"></div> Over Capacity</div>
  `;
}

// ===== REPORT GENERATION =====
function generateReport() {
  if (!lastScenario) { alert('Run a scenario first.'); return; }
  const s = lastScenario;
  const incidentLabels = { fire: 'Fire', explosion: 'Explosion', chemical: 'Chemical (Toxic Release)', nuclear: 'Nuclear (Radiological)' };
  const severityLabels = { minor: 'Minor', moderate: 'Moderate', major: 'Major', catastrophic: 'Catastrophic' };
  const claimTypeLabels = { both: 'All Claims (Injury + Property)', injury: 'Injury Claims Only', property: 'Property Claims Only' };
  const horizonLabels = { short: 'Short Term (12 Weeks)', medium: 'Medium Term (2 Years)', long: 'Long Term (10+ Years)' };

  const now = new Date();
  const dateStr = now.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
  const timeStr = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });

  const periodLabel = s.isLongTerm ? 'Month' : 'Week';
  const capacityLabel = s.isLongTerm ? 'claims/month' : 'claims/week';

  const surgeRows = (s.surgeEntries.length > 0 && !s.isLongTerm)
    ? `<tr><td colspan="2" style="font-weight:700;padding-top:12px">Surge Resources Planned</td></tr>` +
      s.surgeEntries.map(e => `<tr><td>+${e.extraStaff} staff</td><td>From Week ${e.startWeek} onwards</td></tr>`).join('')
    : '';

  // Sample periods for display
  let displayPeriods = s.periods;
  if (s.isLongTerm && s.periods.length > 24) {
    displayPeriods = s.periods.filter((p, i) => i < 12 || i % 3 === 0);
  } else if (s.timeHorizon === 'medium' && s.periods.length > 26) {
    displayPeriods = s.periods.filter((p, i) => i < 12 || i % 2 === 0);
  }
  if (displayPeriods.length > 40) {
    displayPeriods = displayPeriods.slice(0, 40);
  }

  const hasClaimBreakdown = s.claimType === 'both';
  const periodRows = displayPeriods.map(w => {
    const statusClass = w.backlog === 0 ? '#22c55e' : (w.backlog < w.effectiveCapacity ? '#eab308' : '#ef4444');
    const statusText = w.backlog === 0 ? 'On Track' : (w.backlog < w.effectiveCapacity ? 'Building Backlog' : 'Critical Backlog');
    const periodNum = s.isLongTerm ? w.month : (w.week || w.period);
    let row = `<tr>
      <td>${periodLabel} ${periodNum}</td>`;
    if (hasClaimBreakdown) {
      row += `<td style="color:#d97706">${w.newInjury.toLocaleString()}</td>
              <td style="color:#7c3aed">${w.newProperty.toLocaleString()}</td>`;
    }
    row += `<td>${w.newClaims.toLocaleString()}</td>
      <td>${w.cumulative.toLocaleString()}</td>
      <td>${w.effectiveCapacity.toLocaleString()}${w.surgeStaff > 0 ? ' (+' + (w.effectiveCapacity - s.periodCapacity) + ')' : ''}</td>
      <td>${w.processed.toLocaleString()}</td>
      <td>${w.backlog.toLocaleString()}</td>
      <td style="color:${statusClass};font-weight:600">${statusText}</td>
    </tr>`;
    return row;
  }).join('');

  // Build recommendations
  const recs = buildRecommendations(s).map(r => {
    const level = r.level === 'critical' ? 'CRITICAL' : (r.level === 'warning' ? 'WARNING' : 'INFO');
    return { level, text: r.text };
  });

  const recsHtml = recs.map(r => {
    const color = r.level === 'CRITICAL' ? '#ef4444' : (r.level === 'WARNING' ? '#eab308' : '#3b82f6');
    return `<li style="padding:8px 12px;border-left:3px solid ${color};margin-bottom:6px;background:#f8fafc;border-radius:0 6px 6px 0">
      <strong style="color:${color}">[${r.level}]</strong> ${r.text}</li>`;
  }).join('');

  // Table headers
  let tableHeaders = `<th>${periodLabel}</th>`;
  if (hasClaimBreakdown) {
    tableHeaders += `<th>Injury</th><th>Property</th>`;
  }
  tableHeaders += `<th>New Claims</th><th>Cumulative</th><th>Capacity</th><th>Processed</th><th>Backlog</th><th>Status</th>`;

  // Claim breakdown metrics
  let claimBreakdownMetrics = '';
  if (hasClaimBreakdown) {
    claimBreakdownMetrics = `
  <div class="metric"><div class="metric-val" style="color:#d97706">${s.injuryClaims.toLocaleString()}</div><div class="metric-lbl">Injury Claims (${Math.round(s.splits.injury * 100)}%)</div></div>
  <div class="metric"><div class="metric-val" style="color:#7c3aed">${s.propertyClaims.toLocaleString()}</div><div class="metric-lbl">Property Claims (${Math.round(s.splits.property * 100)}%)</div></div>`;
  }

  const maxClearLabel = s.isLongTerm
    ? `${Math.round(s.maxSimPeriods / 12)}+ years`
    : `${s.maxSimPeriods}+ weeks`;
  const timeToClearLabel = s.weeksToClear === -1
    ? maxClearLabel
    : (s.isLongTerm ? s.periodsToClear + ' months' : s.weeksToClear + ' weeks');
  const targetLabel = s.isLongTerm ? s.targetPeriods + ' Months' : s.targetWeeks + ' Weeks';

  const html = `<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><title>Claims Resilience Report - ${s.site.name}</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1000px; margin: 0 auto; padding: 40px 20px; color: #1e293b; line-height: 1.6; }
  h1 { font-size: 24px; border-bottom: 2px solid #3b82f6; padding-bottom: 8px; }
  h2 { font-size: 18px; color: #3b82f6; margin-top: 32px; margin-bottom: 12px; }
  table { width: 100%; border-collapse: collapse; font-size: 12px; margin-bottom: 20px; }
  th, td { padding: 6px 8px; text-align: left; border-bottom: 1px solid #e2e8f0; }
  th { background: #f1f5f9; font-weight: 600; color: #64748b; text-transform: uppercase; font-size: 10px; }
  .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin: 20px 0; }
  .metric { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 14px; text-align: center; }
  .metric-val { font-size: 22px; font-weight: 800; }
  .metric-lbl { font-size: 10px; color: #64748b; text-transform: uppercase; }
  .green { color: #22c55e; } .red { color: #ef4444; } .blue { color: #3b82f6; } .yellow { color: #eab308; }
  ul { list-style: none; padding: 0; }
  .footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #e2e8f0; font-size: 11px; color: #94a3b8; }
  .pattern-note { background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px; padding: 12px; margin: 16px 0; font-size: 13px; }
  @media print { body { padding: 20px; } }
</style></head><body>
<h1>Claims Resilience Report</h1>
<p style="color:#64748b;margin-top:-4px">Generated: ${dateStr} at ${timeStr}</p>

<h2>Scenario Parameters</h2>
<table>
  <tr><td style="font-weight:600;width:200px">Site</td><td>${s.site.name} - ${s.site.location}</td></tr>
  <tr><td style="font-weight:600">Incident Type</td><td>${incidentLabels[s.incident]}</td></tr>
  <tr><td style="font-weight:600">Claim Type</td><td>${claimTypeLabels[s.claimType]}</td></tr>
  <tr><td style="font-weight:600">Time Horizon</td><td>${horizonLabels[s.timeHorizon]}</td></tr>
  <tr><td style="font-weight:600">Severity</td><td>${severityLabels[s.severity]}</td></tr>
  <tr><td style="font-weight:600">Affected Population</td><td>${(s.site.population + s.site.staffOnSite).toLocaleString()} (${s.site.population.toLocaleString()} local + ${s.site.staffOnSite.toLocaleString()} staff)</td></tr>
  <tr><td style="font-weight:600">Base Capacity</td><td>${s.periodCapacity} ${capacityLabel} (${config.organisation.staffCount} staff)</td></tr>
  <tr><td style="font-weight:600">Weighted Avg Days/Claim</td><td>${s.weightedDaysPerClaim.toFixed(1)} days</td></tr>
  <tr><td style="font-weight:600">Claim Complexity Mix</td><td>Auto: ${s.claimComplexity.autoProcessedPct}% | 2-day: ${s.claimComplexity.twoDayPct}% | ${s.claimComplexity.customDays}-day: ${s.claimComplexity.customDayPct}% | Standard (${s.claimComplexity.standardDays || 4}d): ${Math.max(0, 100 - s.claimComplexity.autoProcessedPct - s.claimComplexity.twoDayPct - s.claimComplexity.customDayPct)}%</td></tr>
  <tr><td style="font-weight:600">Target Processing Time</td><td>${targetLabel}</td></tr>
  ${surgeRows}
</table>

${s.incident === 'chemical' || s.incident === 'nuclear' ? `
<div class="pattern-note">
  <strong>Claim Pattern Note:</strong> ${s.incident === 'chemical' ?
    'Chemical (toxic release) incidents typically show a sharp early spike in injury claims followed by a very long tail extending potentially for decades (based on Bhopal and similar incidents). Property claims may resurge if contamination is discovered in soil or groundwater.' :
    'Nuclear (radiological) incidents show distinct patterns: property/evacuation claims dominate early, while injury claims have very long latency periods (5-20+ years for radiation-related cancers). Based on patterns from Fukushima, Chernobyl, and Three Mile Island.'}
</div>` : ''}

<h2>Key Metrics</h2>
<div class="metrics">
  <div class="metric"><div class="metric-val blue">${s.totalClaims.toLocaleString()}</div><div class="metric-lbl">Total Estimated Claims</div></div>
  ${claimBreakdownMetrics}
  <div class="metric"><div class="metric-val yellow">${periodLabel} ${s.peakPeriod}</div><div class="metric-lbl">Peak ${periodLabel} (${s.peakClaims} claims)</div></div>
  <div class="metric"><div class="metric-val ${s.canMeetTarget ? 'green' : 'red'}">${s.canMeetTarget ? 'Yes' : 'No'}</div><div class="metric-lbl">Cleared Within ${targetLabel}?</div></div>
  <div class="metric"><div class="metric-val ${s.canMeetTarget ? 'green' : 'red'}">${timeToClearLabel}</div><div class="metric-lbl">Time to Clear</div></div>
  <div class="metric"><div class="metric-val ${s.additionalStaff === 0 ? 'green' : 'red'}">+${s.additionalStaff}</div><div class="metric-lbl">Additional Staff Required</div></div>
  <div class="metric"><div class="metric-val yellow">${s.maxBacklog.toLocaleString()}</div><div class="metric-lbl">Peak Backlog</div></div>
</div>

<h2>${periodLabel}ly Breakdown</h2>
<table>
  <thead><tr>${tableHeaders}</tr></thead>
  <tbody>${periodRows}</tbody>
</table>

<h2>Resource Requirements</h2>
<table>
  <tr><td style="font-weight:600">Current Staff</td><td>${config.organisation.staffCount}</td></tr>
  <tr><td style="font-weight:600">Staff Needed at Peak</td><td>${s.staffNeededAtPeak}</td></tr>
  <tr><td style="font-weight:600">Additional Staff Required</td><td style="color:${s.additionalStaff > 0 ? '#ef4444' : '#22c55e'};font-weight:700">${s.additionalStaff > 0 ? '+' + s.additionalStaff : 'None'}</td></tr>
  <tr><td style="font-weight:600">Claims/Staff/Week</td><td>${s.claimsPerStaffPerWeek.toFixed(1)}</td></tr>
  <tr><td style="font-weight:600">Capacity Coverage at Peak</td><td>${Math.round((s.periodCapacity / s.peakClaims) * 100)}%</td></tr>
</table>

<h2>Recommendations</h2>
<ul>${recsHtml}</ul>

<div class="footer">
  <p>Claims Resilience Testing Tool — Report generated automatically. This analysis is for planning purposes and based on modelled estimates derived from historical incident patterns including Bhopal (1984), Seveso (1976), Three Mile Island (1979), Chernobyl (1986), Fukushima (2011), Buncefield (2005), Grenfell (2017), and others.</p>
</div>
</body></html>`;

  // Open in a new window and trigger print (Save as PDF)
  const printWindow = window.open('', '_blank');
  if (!printWindow) { alert('Please allow pop-ups to generate the PDF report.'); return; }
  printWindow.document.write(html);
  printWindow.document.close();
  printWindow.onload = function() { printWindow.print(); };
}

// ===== INIT =====
populateSites();
runScenario();

// Redraw on resize
window.addEventListener('resize', () => {
  if (document.getElementById('resultsArea').style.display !== 'none') {
    runScenario();
  }
});
</script>
</body>
</html>
