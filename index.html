<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claims Resilience Testing Tool</title>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,sans-serif;background:#0f172a;color:#e2e8f0;min-height:100vh}
a{color:#60a5fa}
.app{display:flex;min-height:100vh}
/* Focus indicators for accessibility */
:focus-visible{outline:2px solid #3b82f6;outline-offset:2px;border-radius:4px}
select:focus-visible,input:focus-visible{outline:2px solid #3b82f6;outline-offset:1px}
button:focus-visible{outline:2px solid #3b82f6;outline-offset:2px}
.skip-link{position:absolute;top:-40px;left:0;background:#3b82f6;color:#fff;padding:8px 16px;z-index:100;font-size:14px;font-weight:600;transition:top .2s}
.skip-link:focus{top:0}
/* Loading overlay */
.loading-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(15,23,42,0.85);display:flex;align-items:center;justify-content:center;z-index:1000;opacity:0;pointer-events:none;transition:opacity .2s}
.loading-overlay.active{opacity:1;pointer-events:auto}
.loading-spinner{width:40px;height:40px;border:3px solid #334155;border-top-color:#3b82f6;border-radius:50%;animation:spin .8s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.loading-text{color:#94a3b8;margin-top:12px;font-size:14px}
/* Confirmation dialog */
.confirm-dialog-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(15,23,42,0.85);display:flex;align-items:center;justify-content:center;z-index:1001;opacity:0;pointer-events:none;transition:opacity .2s}
.confirm-dialog-overlay.active{opacity:1;pointer-events:auto}
.confirm-dialog{background:#1e293b;border:1px solid #334155;border-radius:12px;padding:24px;max-width:400px;width:90%}
.confirm-dialog h3{font-size:16px;font-weight:700;margin-bottom:12px}
.confirm-dialog p{font-size:14px;color:#94a3b8;margin-bottom:20px;line-height:1.5}
.confirm-dialog-buttons{display:flex;gap:8px;justify-content:flex-end}
.confirm-dialog-buttons button{padding:8px 16px;border:none;border-radius:6px;font-size:13px;font-weight:600;cursor:pointer}
.confirm-dialog-buttons .btn-confirm{background:#ef4444;color:#fff}
.confirm-dialog-buttons .btn-cancel{background:#475569;color:#e2e8f0}
/* Toast notifications */
.toast-container{position:fixed;top:20px;right:20px;z-index:1002;display:flex;flex-direction:column;gap:8px}
.toast{background:#1e293b;border:1px solid #334155;border-radius:8px;padding:12px 16px;font-size:13px;color:#e2e8f0;box-shadow:0 4px 12px rgba(0,0,0,0.3);transform:translateX(120%);transition:transform .3s;max-width:350px}
.toast.show{transform:translateX(0)}
.toast.toast-success{border-left:3px solid #22c55e}
.toast.toast-error{border-left:3px solid #ef4444}
.toast.toast-warning{border-left:3px solid #eab308}
.toast.toast-info{border-left:3px solid #3b82f6}
/* Tooltip styles */
.help-tooltip{position:relative;display:inline-block;cursor:help;margin-left:4px}
.help-tooltip .tooltip-icon{display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;border-radius:50%;background:#475569;color:#94a3b8;font-size:9px;font-weight:700;line-height:1}
.help-tooltip .tooltip-content{position:absolute;bottom:calc(100% + 8px);left:50%;transform:translateX(-50%);background:#0f172a;border:1px solid #475569;border-radius:6px;padding:8px 10px;font-size:11px;color:#94a3b8;white-space:normal;width:220px;z-index:100;opacity:0;pointer-events:none;transition:opacity .2s;line-height:1.4}
.help-tooltip:hover .tooltip-content,.help-tooltip:focus .tooltip-content{opacity:1;pointer-events:auto}
/* Chart tooltip */
.chart-tooltip{position:absolute;background:#1e293b;border:1px solid #3b82f6;border-radius:6px;padding:8px 12px;font-size:11px;color:#e2e8f0;pointer-events:none;z-index:10;display:none;white-space:nowrap;box-shadow:0 2px 8px rgba(0,0,0,0.3)}
/* Screen reader only */
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
/* Color blind mode */
.color-blind .metric-green,.color-blind .status-ok{color:#0072B2!important}
.color-blind .metric-red,.color-blind .status-over{color:#D55E00!important}
.color-blind .metric-yellow,.color-blind .status-warn{color:#E69F00!important}
/* Unsaved changes indicator */
.unsaved-indicator{display:none;font-size:10px;color:#eab308;margin-top:4px}
.unsaved-indicator.visible{display:block}
.sidebar{width:280px;background:#1e293b;border-right:1px solid #334155;padding:20px;flex-shrink:0;overflow-y:auto}
.main{flex:1;padding:24px;overflow-y:auto}
.nav-title{font-size:14px;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:#94a3b8;margin-bottom:16px}
.nav-tabs{display:flex;gap:4px;margin-bottom:20px}
.nav-tab{flex:1;padding:8px 4px;text-align:center;font-size:12px;font-weight:600;background:#334155;color:#94a3b8;border:none;border-radius:6px;cursor:pointer;transition:all .2s}
.nav-tab.active{background:#3b82f6;color:#fff}
.nav-tab:hover:not(.active){background:#475569}
.form-group{margin-bottom:16px}
.form-group label{display:block;font-size:12px;font-weight:600;color:#94a3b8;margin-bottom:6px;text-transform:uppercase;letter-spacing:.5px}
select,input[type="number"],input[type="text"]{width:100%;padding:10px 12px;background:#0f172a;border:1px solid #334155;border-radius:8px;color:#e2e8f0;font-size:14px;outline:none;transition:border-color .2s}
select:focus,input:focus{border-color:#3b82f6}
.btn{padding:10px 20px;border:none;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s;width:100%}
.btn-primary{background:#3b82f6;color:#fff}
.btn-primary:hover{background:#2563eb}
.btn-success{background:#22c55e;color:#fff}
.btn-success:hover{background:#16a34a}
.btn-danger{background:#ef4444;color:#fff;margin-top:8px}
.btn-danger:hover{background:#dc2626}
.btn-secondary{background:#475569;color:#e2e8f0;margin-top:8px}
.btn-secondary:hover{background:#64748b}
.card{background:#1e293b;border:1px solid #334155;border-radius:12px;padding:20px;margin-bottom:20px}
.card-title{font-size:16px;font-weight:700;margin-bottom:16px;padding-bottom:12px;border-bottom:1px solid #334155}
.metrics{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin-bottom:20px}
.metric-card{background:#1e293b;border:1px solid #334155;border-radius:12px;padding:16px;text-align:center}
.metric-value{font-size:28px;font-weight:800;margin-bottom:4px}
.metric-label{font-size:12px;color:#94a3b8;text-transform:uppercase;letter-spacing:.5px}
.metric-green{color:#22c55e} .metric-yellow{color:#eab308} .metric-red{color:#ef4444} .metric-blue{color:#3b82f6}
.chart-container{position:relative;width:100%;margin-bottom:12px}
canvas{width:100%;display:block}
.capacity-table{width:100%;border-collapse:collapse;font-size:13px}
.capacity-table th,.capacity-table td{padding:10px 12px;text-align:left;border-bottom:1px solid #334155}
.capacity-table th{color:#94a3b8;font-weight:600;text-transform:uppercase;font-size:11px;letter-spacing:.5px}
.status-ok{color:#22c55e;font-weight:600} .status-warn{color:#eab308;font-weight:600} .status-over{color:#ef4444;font-weight:600}
.rec-list{list-style:none}
.rec-list li{padding:10px 12px;border-left:3px solid #3b82f6;margin-bottom:8px;background:#0f172a;border-radius:0 8px 8px 0;font-size:13px}
.rec-list li.critical{border-left-color:#ef4444} .rec-list li.warning{border-left-color:#eab308} .rec-list li.info{border-left-color:#3b82f6}
.warning-box{background:#1e293b;border:2px solid #eab308;border-radius:8px;padding:16px;margin-bottom:20px}
.warning-box.critical{border-color:#ef4444;background:#1a1a2a}
.warning-box-title{font-size:14px;font-weight:700;color:#ef4444;margin-bottom:8px}
.admin-section{margin-bottom:24px}
.admin-section h3{font-size:14px;font-weight:700;color:#94a3b8;margin-bottom:12px;text-transform:uppercase;letter-spacing:.5px}
.admin-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.admin-grid .form-group{margin-bottom:8px}
.site-card{background:#0f172a;border:1px solid #334155;border-radius:8px;padding:16px;margin-bottom:12px}
.site-card-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.site-card-header h4{font-size:14px;font-weight:600}
.tag{display:inline-block;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600}
.tag-active{background:#22c55e22;color:#22c55e}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;flex-wrap:wrap;gap:12px}
.header h1{font-size:22px;font-weight:800}
.header-sub{font-size:13px;color:#94a3b8}
@media(max-width:900px){.app{flex-direction:column}.sidebar{width:100%;border-right:none;border-bottom:1px solid #334155}.metrics{grid-template-columns:1fr 1fr}canvas{min-height:200px}.mc-metrics{grid-template-columns:1fr 1fr}}
@media(max-width:500px){.metrics{grid-template-columns:1fr}.admin-grid{grid-template-columns:1fr}.mc-metrics{grid-template-columns:1fr}.header{flex-direction:column}.confirm-dialog{padding:16px}canvas{min-height:180px}select,input[type="number"],input[type="text"]{font-size:16px}}
.chart-legend{display:flex;gap:16px;flex-wrap:wrap;margin-top:8px;font-size:12px}
.legend-item{display:flex;align-items:center;gap:6px}
.legend-swatch{width:12px;height:12px;border-radius:3px}
.progress-bar{height:8px;background:#334155;border-radius:4px;overflow:hidden;margin-top:4px}
.progress-fill{height:100%;border-radius:4px;transition:width .3s}
.range-group{margin-bottom:16px}
.range-group label{display:block;font-size:12px;font-weight:600;color:#94a3b8;margin-bottom:6px;text-transform:uppercase;letter-spacing:.5px}
.range-value{font-size:13px;color:#3b82f6;font-weight:700;float:right}
input[type="range"]{-webkit-appearance:none;width:100%;height:6px;background:#334155;border-radius:3px;outline:none;margin-top:4px}
input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;background:#3b82f6;border-radius:50%;cursor:pointer}
input[type="range"]::-moz-range-thumb{width:16px;height:16px;background:#3b82f6;border-radius:50%;cursor:pointer;border:none}
.surge-entry{display:flex;gap:6px;align-items:center;margin-bottom:6px;background:#0f172a;padding:6px 8px;border-radius:6px;font-size:12px}
.surge-entry select,.surge-entry input{width:auto;padding:4px 6px;font-size:12px}
.surge-entry .btn{width:auto;padding:4px 8px;font-size:11px}
.surge-list{max-height:160px;overflow-y:auto;margin-bottom:8px}
.btn-report{background:#8b5cf6;color:#fff;margin-top:8px}
.btn-report:hover{background:#7c3aed}
.btn-mc{background:#f59e0b;color:#1e293b;margin-top:8px}
.btn-mc:hover{background:#d97706}
.mc-toggle{display:flex;gap:4px;margin-bottom:12px}
.mc-toggle button{flex:1;padding:6px 4px;font-size:11px;font-weight:600;background:#334155;color:#94a3b8;border:none;border-radius:6px;cursor:pointer;transition:all .2s}
.mc-toggle button.active{background:#f59e0b;color:#1e293b}
.mc-progress{background:#334155;border-radius:6px;height:24px;overflow:hidden;margin:12px 0;position:relative}
.mc-progress-fill{height:100%;background:linear-gradient(90deg,#f59e0b,#eab308);border-radius:6px;transition:width .1s;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:700;color:#1e293b}
.mc-results-area{margin-top:20px}
.mc-card{background:#1e293b;border:1px solid #f59e0b33;border-radius:12px;padding:20px;margin-bottom:20px}
.mc-card .card-title{color:#f59e0b;border-bottom-color:#f59e0b33}
.mc-metrics{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:16px;margin-bottom:20px}
.mc-metric-card{background:#1e293b;border:1px solid #334155;border-radius:12px;padding:16px}
.mc-metric-card .det-value{font-size:20px;font-weight:800;color:#3b82f6}
.mc-metric-card .mc-range{font-size:13px;color:#f59e0b;margin-top:4px}
.mc-metric-card .mc-ci{font-size:11px;color:#94a3b8;margin-top:2px}
.mc-metric-card .metric-label{font-size:11px;color:#94a3b8;text-transform:uppercase;letter-spacing:.5px;margin-top:6px}
.mc-badge{display:inline-block;background:#f59e0b22;color:#f59e0b;font-size:10px;font-weight:700;padding:2px 6px;border-radius:4px;text-transform:uppercase;letter-spacing:.5px}
.mc-method{background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;margin-top:12px;font-size:11px;color:#94a3b8}
.mc-param-table{width:100%;border-collapse:collapse;font-size:12px}
.mc-param-table th,.mc-param-table td{padding:6px 8px;text-align:left;border-bottom:1px solid #334155}
.mc-param-table th{color:#94a3b8;font-weight:600;text-transform:uppercase;font-size:10px}
.mc-param-table input{width:70px;padding:4px 6px;background:#0f172a;border:1px solid #334155;border-radius:4px;color:#e2e8f0;font-size:12px}
.mc-convergence{display:flex;align-items:center;gap:8px;font-size:12px;color:#94a3b8;margin-top:8px}
.mc-convergence .dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.mc-convergence .dot.converged{background:#22c55e}
.mc-convergence .dot.running{background:#f59e0b;animation:pulse 1s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}
.hist-tooltip{position:absolute;background:#1e293b;border:1px solid #f59e0b;border-radius:6px;padding:8px;font-size:11px;color:#e2e8f0;pointer-events:none;z-index:10;display:none}
.validation-pass{color:#22c55e;font-weight:600}
.validation-warn{color:#eab308;font-weight:600}
.validation-fail{color:#ef4444;font-weight:600}
</style>
</head>
<body>
<!-- Skip link for keyboard accessibility -->
<a href="#mainContent" class="skip-link">Skip to main content</a>

<!-- Loading overlay -->
<div class="loading-overlay" id="loadingOverlay" role="status" aria-live="polite">
  <div style="text-align:center">
    <div class="loading-spinner"></div>
    <div class="loading-text" id="loadingText">Loading...</div>
  </div>
</div>

<!-- Confirmation dialog -->
<div class="confirm-dialog-overlay" id="confirmDialog" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
  <div class="confirm-dialog">
    <h3 id="confirmTitle">Confirm Action</h3>
    <p id="confirmMessage">Are you sure?</p>
    <div class="confirm-dialog-buttons">
      <button class="btn-cancel" onclick="closeConfirmDialog(false)">Cancel</button>
      <button class="btn-confirm" id="confirmOkBtn" onclick="closeConfirmDialog(true)">Confirm</button>
    </div>
  </div>
</div>

<!-- Toast container -->
<div class="toast-container" id="toastContainer" aria-live="polite" aria-atomic="true"></div>

<div class="app" role="application">
  <!-- Sidebar -->
  <nav class="sidebar" aria-label="Scenario configuration">
    <div class="nav-title" id="navTitle">Claims Resilience Tool</div>
    <div class="nav-tabs" role="tablist" aria-label="View selection">
      <button class="nav-tab active" role="tab" aria-selected="true" aria-controls="scenarioPanel" id="scenarioTab" onclick="switchView('scenario')">Scenario</button>
      <button class="nav-tab" role="tab" aria-selected="false" aria-controls="adminPanel" id="adminTab" onclick="switchView('admin')">Admin</button>
    </div>

    <!-- Scenario Panel -->
    <div id="scenarioPanel" role="tabpanel" aria-labelledby="scenarioTab">
      <div class="form-group">
        <label for="siteSelect">Select Site</label>
        <select id="siteSelect" aria-label="Select site for scenario analysis" onchange="debouncedRunScenario()"></select>
      </div>
      <div class="form-group">
        <label for="incidentSelect">Incident Type <span class="help-tooltip" tabindex="0" aria-label="Help: Incident type affects claim distribution patterns and severity multipliers"><span class="tooltip-icon">?</span><span class="tooltip-content">The type of industrial incident. Each type has different claim distribution patterns, severity multipliers, and historical reference data.</span></span></label>
        <select id="incidentSelect" aria-label="Select incident type" onchange="updateIncidentOptions(); updateTimeHorizonLabels(); debouncedRunScenario()">
          <option value="fire">Fire</option>
          <option value="explosion">Explosion</option>
          <option value="chemical">Chemical (Toxic Release)</option>
          <option value="nuclear">Nuclear (Radiological)</option>
          <option value="fertiliser">Fertiliser (Ammonium Nitrate)</option>
        </select>
      </div>
      <div class="form-group" id="blastRadiusGroup" style="display:none">
        <label for="blastRadiusSelect">Blast Radius Model</label>
        <select id="blastRadiusSelect" aria-label="Select blast radius model" onchange="debouncedRunScenario()">
          <option value="uniform">Uniform Distribution</option>
          <option value="concentrated">Concentrated (Research-Based)</option>
        </select>
        <div style="font-size:10px;color:#64748b;margin-top:2px">90% claims within 500m for explosions</div>
      </div>
      <div class="form-group">
        <label for="claimTypeSelect">Claim Type</label>
        <select id="claimTypeSelect" aria-label="Select claim type filter" onchange="debouncedRunScenario()">
          <option value="both">Both (Injury + Property)</option>
          <option value="injury">Injury Claims (Bodily Injury)</option>
          <option value="property">Property Claims (PD/BI/Economic)</option>
        </select>
      </div>
      <div class="form-group">
        <label for="severitySelect">Severity Level <span class="help-tooltip" tabindex="0" aria-label="Help: Severity determines claim rate and time horizons"><span class="tooltip-icon">?</span><span class="tooltip-content">Severity determines the percentage of affected population filing claims and calibrates time horizons based on historical incident data.</span></span></label>
        <select id="severitySelect" aria-label="Select severity level" onchange="updateTimeHorizonLabels();debouncedRunScenario()">
          <option value="minor">Minor - Small local impact</option>
          <option value="moderate">Moderate - Neighbourhood impact</option>
          <option value="major">Major - Town/city impact</option>
          <option value="catastrophic">Catastrophic - Regional impact</option>
        </select>
      </div>
      <div class="form-group">
        <label for="timeHorizonSelect">Claims Spread View <span class="help-tooltip" tabindex="0" aria-label="Help: Controls how much of the claim lifecycle is displayed"><span class="tooltip-icon">?</span><span class="tooltip-content">Controls the time window displayed. The full claim lifecycle is always simulated; this controls how much is shown. Time horizons are calibrated by incident type and severity.</span></span></label>
        <select id="timeHorizonSelect" aria-label="Select claims spread time horizon" onchange="debouncedRunScenario()">
          <option value="short">Short Term (0-12 weeks)</option>
          <option value="medium">Medium Term (0-2 years)</option>
          <option value="long">Long Term (0-10+ years)</option>
        </select>
        <div id="severityHorizonNote" style="background:#0f172a;border:1px solid #334155;border-radius:6px;padding:8px;margin-top:6px;font-size:10px;color:#94a3b8">
          <strong style="color:#e2e8f0">Time Calibration:</strong> Based on incident severity and research data
        </div>
      </div>
      <!-- Claim pattern information panel -->
      <div id="claimPatternNote" style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:10px;margin-bottom:12px;font-size:11px;color:#94a3b8">
        <strong style="color:#e2e8f0">Claim Pattern:</strong> <span id="patternDescription">Based on historical incident data</span>
      </div>
      <div id="historicalRefContainer" style="background:#1a1a2e;border:1px solid #3b82f6;border-radius:8px;padding:10px;margin-bottom:16px;font-size:10px;color:#60a5fa">
        <strong style="color:#93c5fd">Historical Reference:</strong> <span id="historicalReference"></span>
      </div>

      <div class="form-group">
        <label>Surge Resources</label>
        <div class="surge-list" id="surgeList"></div>
        <button class="btn btn-secondary" style="font-size:12px;padding:6px 10px" onclick="addSurgeEntry()">+ Add Surge Staff</button>
      </div>

      <div class="form-group">
        <label for="targetWeeksInput">Target Processing Time (weeks) <span class="help-tooltip" tabindex="0" aria-label="Help: Target time to clear all claims"><span class="tooltip-icon">?</span><span class="tooltip-content">Set the target number of weeks within which all claims should be processed. The tool will indicate if current capacity can meet this target.</span></span></label>
        <input type="number" id="targetWeeksInput" value="12" min="1" max="520" step="1" aria-label="Target processing time in weeks" onchange="debouncedRunScenario()">
        <div style="font-size:10px;color:#64748b;margin-top:2px">All claims should be processed within this many weeks</div>
      </div>

      <div class="form-group">
        <label for="coverageLimitInput">Coverage Limit (£M) - Optional</label>
        <input type="number" id="coverageLimitInput" value="" placeholder="e.g. 50" min="0" step="1" aria-label="Coverage limit in millions of pounds" onchange="debouncedRunScenario()">
        <div style="font-size:10px;color:#64748b;margin-top:2px">Enter policy limit to check underinsurance risk</div>
      </div>

      <div style="margin-top:20px">
        <button class="btn btn-primary" onclick="runScenario()" aria-label="Run scenario analysis">Run Scenario</button>
        <button class="btn btn-mc" onclick="runMonteCarlo()" aria-label="Run Monte Carlo simulation with 10,000 iterations">Run Monte Carlo (10,000 sims)</button>
        <button class="btn btn-report" onclick="generateReport()" aria-label="Generate PDF report">Generate PDF Report</button>
        <button class="btn btn-secondary" onclick="exportCSV()" aria-label="Export scenario data as CSV">Export CSV</button>
      </div>

      <!-- MC Mode Toggle -->
      <div id="mcSidebarControls" style="margin-top:16px;display:none">
        <div class="form-group">
          <label>Monte Carlo Mode</label>
          <div class="mc-toggle">
            <button id="mcSimpleBtn" class="active" onclick="setMCMode('simple')">Simple</button>
            <button id="mcAdvancedBtn" onclick="setMCMode('advanced')">Advanced</button>
          </div>
        </div>
        <div id="mcAdvancedControls" style="display:none">
          <div class="form-group">
            <label for="mcIterations">Iterations</label>
            <input type="number" id="mcIterations" value="10000" min="1000" max="100000" step="1000" style="font-size:12px" aria-label="Number of Monte Carlo iterations" inputmode="numeric">
          </div>
          <div class="form-group">
            <label for="mcTolerance">Convergence Tolerance (%)</label>
            <input type="number" id="mcTolerance" value="2" min="0.5" max="10" step="0.5" style="font-size:12px" aria-label="Convergence tolerance percentage">
          </div>
          <div class="form-group">
            <label for="mcSeedInput">Random Seed (optional) <span class="help-tooltip" tabindex="0" aria-label="Help: Random seed for reproducibility"><span class="tooltip-icon">?</span><span class="tooltip-content">Set a numeric seed for reproducible Monte Carlo simulations. Leave blank for random results each run.</span></span></label>
            <input type="number" id="mcSeedInput" value="" placeholder="Leave blank for random" style="font-size:12px" aria-label="Random seed for reproducible simulations" inputmode="numeric">
          </div>
          <div style="font-size:10px;color:#64748b;margin-top:4px">
            Configure distributions in Admin → MC Config
          </div>
          <button class="btn btn-secondary" style="font-size:11px;padding:4px 10px;margin-top:8px" onclick="exportMCResults()" aria-label="Export Monte Carlo results as CSV">Export MC Results (CSV)</button>
        </div>
      </div>
    </div>

    <!-- Admin Panel -->
    <div id="adminPanel" role="tabpanel" aria-labelledby="adminTab" style="display:none">
      <div class="unsaved-indicator" id="unsavedIndicator">You have unsaved changes</div>
      <div class="admin-section">
        <h3>Organisation Settings</h3>
        <div class="form-group">
          <label for="adminStaff">Number of Claims Staff</label>
          <input type="number" id="adminStaff" value="8" min="1" max="1000" aria-label="Number of claims processing staff" inputmode="numeric" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label for="adminWorkDays">Working Days per Week</label>
          <input type="number" id="adminWorkDays" value="5" min="1" max="7" aria-label="Working days per week" inputmode="numeric" onchange="saveAdmin()">
        </div>
        <div style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;margin-top:8px">
          <div style="font-size:12px;font-weight:600;color:#94a3b8;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px">Calculated Weekly Capacity</div>
          <div id="calculatedCapacity" style="font-size:22px;font-weight:800;color:#3b82f6">10</div>
          <div id="capacityFormula" style="font-size:11px;color:#64748b;margin-top:2px">8 staff × 5 days ÷ 4.0 avg days/claim</div>
        </div>
      </div>

      <div class="admin-section">
        <h3>Claim Complexity Mix</h3>
        <p style="font-size:11px;color:#64748b;margin-bottom:10px">Adjust the proportion of claims at each processing speed. Remaining % uses standard processing time.</p>
        <div class="range-group">
          <label>Auto-Processed (0 days) <span class="range-value" id="autoProcessedValue">10%</span></label>
          <input type="range" id="autoProcessedSlider" min="0" max="100" value="10" oninput="updateComplexitySlider()">
        </div>
        <div class="range-group">
          <label>Fast Track - 2 Days <span class="range-value" id="twoDayValue">20%</span></label>
          <input type="range" id="twoDaySlider" min="0" max="100" value="20" oninput="updateComplexitySlider()">
        </div>
        <div class="range-group" style="margin-bottom:8px">
          <label>Medium Track <span class="range-value" id="customDayValue">30%</span></label>
          <input type="range" id="customDaySlider" min="0" max="100" value="30" oninput="updateComplexitySlider()">
        </div>
        <div class="form-group" style="margin-bottom:4px">
          <label>Medium Track Days</label>
          <input type="number" id="customDaysInput" value="3" min="1" max="20" step="0.5" onchange="updateComplexitySlider()">
        </div>
        <div class="form-group" style="margin-bottom:8px">
          <label>Standard Track Days</label>
          <input type="number" id="standardDaysInput" value="4" min="1" max="30" step="0.5" onchange="updateComplexitySlider()">
        </div>
        <div id="complexityBreakdown" style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:10px;font-size:12px">
        </div>
      </div>

      <div class="admin-section">
        <h3>Incident Multipliers</h3>
        <div class="form-group">
          <label>Fire Multiplier</label>
          <input type="number" id="multFire" value="1.0" step="0.1" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Explosion Multiplier</label>
          <input type="number" id="multExplosion" value="1.3" step="0.1" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Chemical Multiplier</label>
          <input type="number" id="multChemical" value="1.5" step="0.1" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Nuclear Multiplier</label>
          <input type="number" id="multNuclear" value="2.0" step="0.1" onchange="saveAdmin()">
        </div>
      </div>

      <div class="admin-section">
        <h3>Severity Claim Rates</h3>
        <p style="font-size:11px;color:#64748b;margin-bottom:8px">% of affected population filing claims</p>
        <div class="form-group">
          <label>Minor (%)</label>
          <input type="number" id="rateMinor" value="2" step="0.5" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Moderate (%)</label>
          <input type="number" id="rateModerate" value="8" step="0.5" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Major (%)</label>
          <input type="number" id="rateMajor" value="20" step="1" onchange="saveAdmin()">
        </div>
        <div class="form-group">
          <label>Catastrophic (%)</label>
          <input type="number" id="rateCatastrophic" value="45" step="1" onchange="saveAdmin()">
        </div>
      </div>

      <div class="admin-section">
        <h3>Sites Management</h3>
        <div id="sitesAdminList"></div>
        <button class="btn btn-success" onclick="addSitePrompt()" style="margin-top:12px">+ Add Site</button>
      </div>

      <div class="admin-section">
        <h3>Monte Carlo Configuration</h3>
        <p style="font-size:11px;color:#64748b;margin-bottom:10px">Triangular distribution parameters (min / mode / max) for each stochastic variable. Mode uses current config value.</p>
        <div style="overflow-x:auto">
          <table class="mc-param-table" id="mcParamTable">
            <thead><tr><th>Parameter</th><th>Min Factor</th><th>Max Factor</th><th>Notes</th></tr></thead>
            <tbody id="mcParamBody"></tbody>
          </table>
        </div>
        <div style="margin-top:12px">
          <div class="form-group">
            <label>Default Iterations</label>
            <input type="number" id="adminMCIterations" value="10000" min="1000" max="100000" step="1000" onchange="saveMCAdmin()">
          </div>
          <div class="form-group">
            <label>Convergence Tolerance (%)</label>
            <input type="number" id="adminMCTolerance" value="2" min="0.5" max="10" step="0.5" onchange="saveMCAdmin()">
          </div>
        </div>
        <button class="btn btn-secondary" onclick="confirmAction('Reset Monte Carlo Defaults', 'This will reset all Monte Carlo parameters to their default values. This cannot be undone.', resetMCDefaults)" style="font-size:12px;padding:6px 12px" aria-label="Reset Monte Carlo parameters to defaults">Reset MC to Defaults</button>
      </div>

      <div class="admin-section" style="margin-top:20px">
        <button class="btn btn-secondary" onclick="exportConfig()" aria-label="Export configuration as JSON file">Export Config</button>
        <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()" aria-label="Import configuration from JSON file">Import Config</button>
        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importConfig(event)" aria-label="Select configuration file to import">
      </div>
    </div>
  </nav>

  <!-- Main Content -->
  <main class="main" id="mainContent" aria-label="Scenario results">
    <div class="header">
      <div>
        <h1 id="mainTitle">Claims Resilience Testing</h1>
        <div class="header-sub" id="mainSub">Select a scenario to begin analysis</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <label style="font-size:11px;color:#94a3b8;display:flex;align-items:center;gap:4px;cursor:pointer">
          <input type="checkbox" id="colorBlindToggle" onchange="toggleColorBlindMode()" aria-label="Toggle color blind friendly mode"> Color blind mode
        </label>
      </div>
    </div>

    <div id="resultsArea" style="display:none">
      <!-- Key Metrics -->
      <div class="metrics" id="metricsGrid"></div>

      <!-- Underinsurance Warning Box -->
      <div id="underinsuranceWarning" class="warning-box critical" style="display:none">
        <div class="warning-box-title">UNDERINSURANCE WARNING</div>
        <div id="underinsuranceContent"></div>
      </div>

      <!-- Claims Forecast Chart -->
      <div class="card">
        <div class="card-title" id="forecastChartTitle">Claims Forecast Over 12 Weeks</div>
        <div class="chart-container" style="position:relative">
          <canvas id="forecastChart" height="300" role="img" aria-label="Claims forecast chart showing new claims per period over time"></canvas>
          <div class="chart-tooltip" id="forecastTooltip"></div>
          <div class="sr-only" id="forecastChartSR" aria-live="polite"></div>
        </div>
        <div class="chart-legend" id="forecastLegend"></div>
        <div style="margin-top:8px;text-align:right">
          <button class="btn btn-secondary" style="width:auto;padding:4px 10px;font-size:11px" onclick="exportChartAsImage('forecastChart','claims-forecast')" aria-label="Save forecast chart as image">Save as Image</button>
        </div>
      </div>

      <!-- Capacity Chart -->
      <div class="card">
        <div class="card-title">Capacity Utilisation</div>
        <div class="chart-container" style="position:relative">
          <canvas id="capacityChart" height="250" role="img" aria-label="Capacity utilisation chart showing processing load versus capacity"></canvas>
          <div class="chart-tooltip" id="capacityTooltip"></div>
          <div class="sr-only" id="capacityChartSR" aria-live="polite"></div>
        </div>
        <div class="chart-legend" id="capacityLegend"></div>
        <div style="margin-top:8px;text-align:right">
          <button class="btn btn-secondary" style="width:auto;padding:4px 10px;font-size:11px" onclick="exportChartAsImage('capacityChart','capacity-utilisation')" aria-label="Save capacity chart as image">Save as Image</button>
        </div>
      </div>

      <!-- Weekly Breakdown Table -->
      <div class="card">
        <div class="card-title">Weekly Breakdown</div>
        <div style="overflow-x:auto">
          <table class="capacity-table" id="weeklyTable">
            <thead><tr>
              <th>Week</th><th>New Claims</th><th>Cumulative</th><th>Processed</th><th>Backlog</th><th>Status</th>
            </tr></thead>
            <tbody id="weeklyBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Resource Requirements -->
      <div class="card">
        <div class="card-title">Resource Requirements</div>
        <div id="resourceContent"></div>
      </div>

      <!-- Claim Value Assumptions -->
      <div class="card">
        <div class="card-title">Claim Value Assumptions (Research-Based)</div>
        <div id="claimValueContent"></div>
      </div>

      <!-- Claim Distribution Template -->
      <div class="card" id="distributionTemplateCard">
        <div class="card-title">Claim Distribution Pattern (Research-Based)</div>
        <div id="distributionTemplateContent"></div>
      </div>

      <!-- UK Legal Framework -->
      <div class="card" id="legalFrameworkCard" style="display:none">
        <div class="card-title">UK Legal Framework</div>
        <div id="legalFrameworkContent"></div>
      </div>

      <!-- Claim Categories Timeline -->
      <div class="card">
        <div class="card-title">Claim Categories & Timelines</div>
        <div id="claimCategoriesContent"></div>
      </div>

      <!-- Recommendations -->
      <div class="card">
        <div class="card-title">Recommendations</div>
        <ul class="rec-list" id="recList"></ul>
      </div>
    </div>

    <!-- Monte Carlo Results -->
    <div id="mcResultsArea" class="mc-results-area" style="display:none">
      <!-- MC Progress Bar -->
      <div id="mcProgressContainer" style="display:none">
        <div class="card" style="border-color:#f59e0b33">
          <div class="card-title" style="color:#f59e0b">Monte Carlo Simulation Running</div>
          <div class="mc-progress"><div class="mc-progress-fill" id="mcProgressBar" style="width:0%">0%</div></div>
          <div class="mc-convergence" id="mcConvergenceStatus">
            <span class="dot running"></span> Running iterations...
          </div>
        </div>
      </div>

      <!-- MC Summary Metrics with CI -->
      <div class="mc-card">
        <div class="card-title">Monte Carlo Analysis <span class="mc-badge">Probabilistic</span></div>
        <div id="mcMethodNote" class="mc-method"></div>
        <div class="mc-metrics" id="mcMetricsGrid"></div>
      </div>

      <!-- MC Distribution Charts -->
      <div class="mc-card">
        <div class="card-title">Claims Distribution <span class="mc-badge">10,000 simulations</span></div>
        <div class="chart-container"><canvas id="mcClaimsHistogram" height="280"></canvas></div>
        <div class="chart-legend" id="mcClaimsHistLegend"></div>
      </div>

      <div class="mc-card">
        <div class="card-title">Financial Exposure Distribution</div>
        <div class="chart-container"><canvas id="mcValueHistogram" height="280"></canvas></div>
        <div class="chart-legend" id="mcValueHistLegend"></div>
      </div>

      <div class="mc-card">
        <div class="card-title">Time to Clear Distribution</div>
        <div class="chart-container"><canvas id="mcClearTimeHistogram" height="280"></canvas></div>
        <div class="chart-legend" id="mcClearTimeLegend"></div>
      </div>

      <!-- Exceedance Curves -->
      <div class="mc-card">
        <div class="card-title">Exceedance Probability Curves</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px">
          <div>
            <div style="font-size:12px;font-weight:600;color:#94a3b8;margin-bottom:8px">Claims Count</div>
            <div class="chart-container"><canvas id="mcClaimsExceedance" height="220"></canvas></div>
          </div>
          <div>
            <div style="font-size:12px;font-weight:600;color:#94a3b8;margin-bottom:8px">Financial Value</div>
            <div class="chart-container"><canvas id="mcValueExceedance" height="220"></canvas></div>
          </div>
        </div>
      </div>

      <!-- Tornado / Sensitivity Chart -->
      <div class="mc-card">
        <div class="card-title">Sensitivity Analysis (Tornado Chart)</div>
        <p style="font-size:11px;color:#94a3b8;margin-bottom:12px">Shows which input parameters contribute most to output uncertainty (Spearman rank correlation)</p>
        <div class="chart-container"><canvas id="mcTornadoChart" height="320"></canvas></div>
      </div>

      <!-- Deterministic vs MC Comparison -->
      <div class="mc-card">
        <div class="card-title">Deterministic vs Monte Carlo Comparison</div>
        <div id="mcComparisonContent"></div>
      </div>

      <!-- Historical Validation -->
      <div class="mc-card">
        <div class="card-title">Historical Validation</div>
        <p style="font-size:11px;color:#94a3b8;margin-bottom:12px">Back-testing: do known historical outcomes fall within the simulated confidence intervals?</p>
        <div id="mcValidationContent"></div>
      </div>
    </div>

    <div id="welcomeArea">
      <div class="card" style="text-align:center;padding:60px 20px">
        <div style="font-size:48px;margin-bottom:16px">&#9881;</div>
        <h2 style="margin-bottom:12px">Claims Resilience Testing Tool</h2>
        <p style="color:#94a3b8;max-width:500px;margin:0 auto;line-height:1.6">
          Test your organisation's claim processing resilience across different incident scenarios.
          Select a site, incident type, and severity level from the sidebar to begin.
        </p>
        <p style="color:#64748b;margin-top:16px;font-size:13px">
          Use the Admin panel to configure sites, staff capacity, and processing parameters.
        </p>
      </div>
    </div>
  </main>
</div>

<script>
// ╔══════════════════════════════════════════════════════════════╗
// ║  CLAIMS RESILIENCE TESTING TOOL                             ║
// ║  Configuration Data → State → Helpers → UI → Charts → Init ║
// ╚══════════════════════════════════════════════════════════════╝

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 0: UTILITY INFRASTRUCTURE
// Security, validation, browser compat, UX utilities
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ===== EXTRACTED CONSTANTS (Code Quality - Issue 12) =====
const CHART_PAD = { top: 20, right: 20, bottom: 40, left: 60 };
const CHART_CAPACITY_PAD = { top: 20, right: 20, bottom: 40, left: 60 };
const MAX_DISPLAY_PERIODS = 48;
const SAMPLING_THRESHOLD_HIGH = 60;
const SAMPLING_THRESHOLD_LOW = 30;
const SAMPLING_TARGET = 40;
const MC_BATCH_SIZE = 500;
const DEBOUNCE_DELAY = 250;
const RESIZE_DEBOUNCE = 150;
const CONFIG_SCHEMA_VERSION = 2;

// ===== BROWSER COMPATIBILITY (Issue 14) =====
const supportsLocalStorage = (() => {
  try {
    const t = '__test__';
    localStorage.setItem(t, t);
    localStorage.removeItem(t);
    return true;
  } catch(e) { return false; }
})();

const memoryStorage = {};
function safeStorageGet(key) {
  if (supportsLocalStorage) {
    try { return localStorage.getItem(key); } catch(e) { return memoryStorage[key] || null; }
  }
  return memoryStorage[key] || null;
}
function safeStorageSet(key, value) {
  if (supportsLocalStorage) {
    try { localStorage.setItem(key, value); } catch(e) { memoryStorage[key] = value; }
  } else {
    memoryStorage[key] = value;
  }
}

// Canvas API check
const supportsCanvas = (() => {
  try { return !!document.createElement('canvas').getContext('2d'); } catch(e) { return false; }
})();

// ===== SECURITY: INPUT SANITIZATION (Issue 13) =====
function sanitizeHTML(str) {
  if (typeof str !== 'string') return String(str);
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function sanitizeNumberInput(value, min, max, fallback) {
  const num = parseFloat(value);
  if (isNaN(num) || !isFinite(num)) return fallback;
  if (min !== undefined && num < min) return min;
  if (max !== undefined && num > max) return max;
  return num;
}

function sanitizeIntInput(value, min, max, fallback) {
  return Math.round(sanitizeNumberInput(value, min, max, fallback));
}

// ===== LOCALSTORAGE INTEGRITY (Issue 13) =====
function computeChecksum(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const chr = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + chr;
    hash |= 0;
  }
  return hash.toString(36);
}

function saveWithIntegrity(key, obj) {
  try {
    const json = JSON.stringify(obj);
    const checksum = computeChecksum(json);
    safeStorageSet(key, json);
    safeStorageSet(key + '_checksum', checksum);
  } catch(e) {
    showToast('Failed to save: ' + e.message, 'error');
  }
}

function loadWithIntegrity(key) {
  try {
    const json = safeStorageGet(key);
    if (!json) return null;
    const savedChecksum = safeStorageGet(key + '_checksum');
    if (savedChecksum) {
      const actualChecksum = computeChecksum(json);
      if (savedChecksum !== actualChecksum) {
        showToast('Config data integrity check failed for ' + key + '. Using defaults.', 'warning');
        return null;
      }
    }
    return JSON.parse(json);
  } catch(e) {
    showToast('Failed to load config: ' + e.message, 'error');
    return null;
  }
}

// ===== VALIDATION UTILITIES (Issue 1) =====
function validatePositiveNumber(value, fieldName) {
  if (typeof value !== 'number' || isNaN(value) || value < 0) {
    return { valid: false, message: fieldName + ' must be a positive number' };
  }
  return { valid: true };
}

function validatePopulation(value) {
  if (typeof value !== 'number' || isNaN(value) || value <= 0) {
    return { valid: false, message: 'Population must be greater than zero' };
  }
  return { valid: true };
}

function validatePercentage(value, fieldName) {
  if (typeof value !== 'number' || isNaN(value) || value < 0 || value > 100) {
    return { valid: false, message: fieldName + ' must be between 0 and 100' };
  }
  return { valid: true };
}

// Config import schema validation (Issue 4)
const CONFIG_REQUIRED_FIELDS = ['organisation', 'sites'];
const CONFIG_SCHEMA = {
  organisation: { staffCount: 'number', workDaysPerWeek: 'number' },
  sites: 'array'
};

function validateConfigSchema(obj) {
  const errors = [];

  if (!obj || typeof obj !== 'object') {
    return { valid: false, errors: ['Config must be a JSON object'] };
  }

  CONFIG_REQUIRED_FIELDS.forEach(field => {
    if (!(field in obj)) errors.push('Missing required field: ' + field);
  });

  if (obj.organisation) {
    if (typeof obj.organisation.staffCount !== 'number' && typeof obj.organisation.staffCount !== 'undefined') {
      if (typeof obj.organisation.staffCount === 'string') obj.organisation.staffCount = parseInt(obj.organisation.staffCount) || 8;
      else errors.push('organisation.staffCount must be a number');
    }
    if (obj.organisation.staffCount !== undefined && obj.organisation.staffCount <= 0) {
      errors.push('organisation.staffCount must be positive');
    }
    if (obj.organisation.workDaysPerWeek !== undefined) {
      if (obj.organisation.workDaysPerWeek <= 0 || obj.organisation.workDaysPerWeek > 7) {
        errors.push('organisation.workDaysPerWeek must be between 1 and 7');
      }
    }
  }

  if (obj.sites) {
    if (!Array.isArray(obj.sites)) {
      errors.push('sites must be an array');
    } else if (obj.sites.length === 0) {
      errors.push('sites must contain at least one site');
    } else {
      obj.sites.forEach((site, i) => {
        if (!site.id && !site.name) errors.push('Site ' + i + ' must have an id or name');
        if (site.population !== undefined && site.population < 0) errors.push('Site ' + i + ' population cannot be negative');
      });
    }
  }

  if (obj.severityRates) {
    Object.entries(obj.severityRates).forEach(([key, val]) => {
      if (typeof val !== 'number' || val < 0 || val > 1) {
        errors.push('severityRates.' + key + ' must be a number between 0 and 1');
      }
    });
  }

  return { valid: errors.length === 0, errors };
}

// ===== DEBOUNCING (Issue 7) =====
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}
const debouncedRunScenario = debounce(() => runScenario(), DEBOUNCE_DELAY);

// ===== UX: TOAST NOTIFICATIONS =====
function showToast(message, type) {
  type = type || 'info';
  const container = document.getElementById('toastContainer');
  if (!container) return;
  const toast = document.createElement('div');
  toast.className = 'toast toast-' + type;
  toast.textContent = message;
  toast.setAttribute('role', 'alert');
  container.appendChild(toast);
  requestAnimationFrame(() => { toast.classList.add('show'); });
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, 300);
  }, 4000);
}

// ===== UX: LOADING OVERLAY =====
function showLoading(message) {
  const overlay = document.getElementById('loadingOverlay');
  const text = document.getElementById('loadingText');
  if (overlay) { overlay.classList.add('active'); }
  if (text) { text.textContent = message || 'Loading...'; }
}
function hideLoading() {
  const overlay = document.getElementById('loadingOverlay');
  if (overlay) { overlay.classList.remove('active'); }
}

// ===== UX: CONFIRMATION DIALOG (Issue 3) =====
let confirmCallback = null;
function confirmAction(title, message, onConfirm) {
  document.getElementById('confirmTitle').textContent = title;
  document.getElementById('confirmMessage').textContent = message;
  document.getElementById('confirmDialog').classList.add('active');
  confirmCallback = onConfirm;
  document.getElementById('confirmOkBtn').focus();
}
function closeConfirmDialog(confirmed) {
  document.getElementById('confirmDialog').classList.remove('active');
  if (confirmed && typeof confirmCallback === 'function') {
    confirmCallback();
  }
  confirmCallback = null;
}

// ===== UNSAVED CHANGES WARNING (Issue 3) =====
let hasUnsavedChanges = false;
function markUnsaved() {
  hasUnsavedChanges = true;
  const indicator = document.getElementById('unsavedIndicator');
  if (indicator) indicator.classList.add('visible');
}
function clearUnsaved() {
  hasUnsavedChanges = false;
  const indicator = document.getElementById('unsavedIndicator');
  if (indicator) indicator.classList.remove('visible');
}
window.addEventListener('beforeunload', function(e) {
  if (hasUnsavedChanges) {
    e.preventDefault();
    e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
    return e.returnValue;
  }
});

// ===== COLOR BLIND MODE (Issue 6) =====
let colorBlindMode = false;
const CB_COLORS = {
  green: '#0072B2',
  red: '#D55E00',
  yellow: '#E69F00',
  blue: '#56B4E9',
  purple: '#CC79A7',
  orange: '#E69F00'
};
const NORMAL_COLORS = {
  green: '#22c55e',
  red: '#ef4444',
  yellow: '#eab308',
  blue: '#3b82f6',
  purple: '#8b5cf6',
  orange: '#f97316'
};
function getChartColor(name) {
  return colorBlindMode ? (CB_COLORS[name] || NORMAL_COLORS[name]) : (NORMAL_COLORS[name] || name);
}
function toggleColorBlindMode() {
  colorBlindMode = document.getElementById('colorBlindToggle').checked;
  document.body.classList.toggle('color-blind', colorBlindMode);
  safeStorageSet('claimsToolColorBlind', colorBlindMode ? '1' : '0');
  if (lastScenario) { showResults(lastScenario); }
  showToast('Color blind mode ' + (colorBlindMode ? 'enabled' : 'disabled'), 'info');
}

// ===== CHART EXPORT (Issue 6) =====
function exportChartAsImage(canvasId, filename) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) { showToast('Chart not found', 'error'); return; }
  try {
    const link = document.createElement('a');
    link.download = (filename || 'chart') + '.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
    showToast('Chart exported as ' + link.download, 'success');
  } catch(e) {
    showToast('Failed to export chart: ' + e.message, 'error');
  }
}

// ===== CHART TOOLTIPS (Issue 6) =====
function setupChartTooltip(canvasId, tooltipId, getDataAtPoint) {
  const canvas = document.getElementById(canvasId);
  const tooltip = document.getElementById(tooltipId);
  if (!canvas || !tooltip) return;

  canvas.addEventListener('mousemove', function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const data = getDataAtPoint(x, y, rect.width, rect.height);
    if (data) {
      tooltip.innerHTML = data;
      tooltip.style.display = 'block';
      tooltip.style.left = Math.min(x + 10, rect.width - 150) + 'px';
      tooltip.style.top = (y - 40) + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  });

  canvas.addEventListener('mouseleave', function() {
    tooltip.style.display = 'none';
  });

  // Touch support for mobile (Issue 15)
  canvas.addEventListener('touchstart', function(e) {
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    const data = getDataAtPoint(x, y, rect.width, rect.height);
    if (data) {
      tooltip.innerHTML = data;
      tooltip.style.display = 'block';
      tooltip.style.left = Math.min(x + 10, rect.width - 150) + 'px';
      tooltip.style.top = (y - 40) + 'px';
    }
  }, { passive: true });

  canvas.addEventListener('touchend', function() {
    setTimeout(() => { tooltip.style.display = 'none'; }, 2000);
  }, { passive: true });
}

// ===== CSV EXPORT (Issue 4) =====
function exportCSV() {
  if (!lastScenario) { showToast('Run a scenario first', 'warning'); return; }
  const s = lastScenario;
  const { displayPeriods, periodLabel, useMonthlyDisplay } = getDisplayPeriods(s);
  const hasBreakdown = s.claimType === 'both';

  let csv = 'Period';
  if (hasBreakdown) csv += ',Injury Claims,Property Claims';
  csv += ',New Claims,Cumulative,Capacity,Processed,Backlog,Surge Staff,Utilisation %\n';

  displayPeriods.forEach(w => {
    const periodNum = useMonthlyDisplay ? w.month : (w.week || w.period);
    let row = periodLabel + ' ' + periodNum;
    if (hasBreakdown) row += ',' + w.newInjury + ',' + w.newProperty;
    row += ',' + w.newClaims + ',' + w.cumulative + ',' + w.effectiveCapacity + ',' + w.processed + ',' + w.backlog + ',' + (w.surgeStaff || 0) + ',' + w.utilisation.toFixed(1);
    csv += row + '\n';
  });

  // Summary section
  csv += '\nSummary\n';
  csv += 'Site,' + sanitizeHTML(s.site.name) + '\n';
  csv += 'Incident,' + s.incident + '\n';
  csv += 'Severity,' + s.severity + '\n';
  csv += 'Total Claims,' + s.totalClaims + '\n';
  csv += 'Peak Claims,' + s.peakClaims + '\n';
  csv += 'Weeks to Clear,' + s.weeksToClear + '\n';
  csv += 'Additional Staff,' + s.additionalStaff + '\n';
  csv += 'Max Backlog,' + s.maxBacklog + '\n';
  csv += 'Ultimate Claims (Mid),' + s.ultimateClaimsMid + '\n';
  csv += 'Estimated Value,' + s.estimatedTotalValue + '\n';

  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'claims-scenario-' + s.site.id + '-' + s.incident + '-' + s.severity + '.csv';
  a.click();
  URL.revokeObjectURL(a.href);
  showToast('CSV exported successfully', 'success');
}

// ===== MC RESULTS EXPORT (Issue 4) =====
function exportMCResults() {
  if (!lastMCResults) { showToast('Run Monte Carlo simulation first', 'warning'); return; }
  const mc = lastMCResults;
  const st = mc.stats;

  let csv = 'Monte Carlo Results Summary\n';
  csv += 'Iterations,' + mc.iterations + '\n';
  csv += 'Converged,' + (mc.converged ? 'Yes' : 'No') + '\n\n';

  csv += 'Metric,Deterministic,P5,P10,P25,P50,P75,P90,P95,Mean,StdDev\n';
  const s = mc.baseScenario;
  const rows = [
    ['Total Claims', s.totalClaims, st.totalClaims],
    ['Injury Claims', s.injuryClaims, st.injuryClaims],
    ['Property Claims', s.propertyClaims, st.propertyClaims],
    ['Peak Claims', s.peakClaims, st.peakClaims],
    ['Weeks to Clear', s.weeksToClear, st.weeksToClear],
    ['Max Backlog', s.maxBacklog, st.maxBacklog],
    ['Additional Staff', s.additionalStaff, st.additionalStaff],
    ['Ultimate Claims', s.ultimateClaimsMid || 0, st.ultimateClaims],
    ['Estimated Value', s.estimatedTotalValue || 0, st.estimatedValue]
  ];

  rows.forEach(([label, det, stats]) => {
    csv += label + ',' + det + ',' + Math.round(stats.P5) + ',' + Math.round(stats.P10) + ',' + Math.round(stats.P25) + ',' + Math.round(stats.P50) + ',' + Math.round(stats.P75) + ',' + Math.round(stats.P90) + ',' + Math.round(stats.P95) + ',' + Math.round(stats.mean) + ',' + Math.round(stats.std) + '\n';
  });

  csv += '\nSensitivity Analysis (Spearman Rank Correlation)\n';
  csv += 'Parameter,Total Claims,Estimated Value,Weeks to Clear,Additional Staff\n';
  mc.sensitivity.totalClaims.forEach(item => {
    const val = mc.sensitivity.estimatedValue.find(v => v.key === item.key);
    const wk = mc.sensitivity.weeksToClear.find(v => v.key === item.key);
    const st = mc.sensitivity.additionalStaff.find(v => v.key === item.key);
    csv += item.param + ',' + item.correlation.toFixed(4) + ',' + (val ? val.correlation.toFixed(4) : '') + ',' + (wk ? wk.correlation.toFixed(4) : '') + ',' + (st ? st.correlation.toFixed(4) : '') + '\n';
  });

  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'monte-carlo-results.csv';
  a.click();
  URL.revokeObjectURL(a.href);
  showToast('Monte Carlo results exported', 'success');
}

// ===== SEEDED RANDOM NUMBER GENERATOR (Issue 5) =====
// Mulberry32 PRNG for reproducible simulations
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
let mcRandomSeed = null;
let seededRandom = null;

function getMCRandom() {
  if (seededRandom) return seededRandom();
  return Math.random();
}

// ===== DATA MIGRATION (Issue 8) =====
function migrateConfig(config) {
  if (!config) return config;

  // v1 -> v2: Add claimComplexity if missing
  if (!config.claimComplexity) {
    config.claimComplexity = JSON.parse(JSON.stringify(DEFAULT_CONFIG.claimComplexity));
  }

  // Ensure sites have required fields
  if (config.sites) {
    config.sites.forEach(site => {
      if (!site.id && site.name) site.id = site.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
      if (site.population === undefined) site.population = 10000;
      if (site.staffOnSite === undefined) site.staffOnSite = 500;
      if (site.active === undefined) site.active = true;
    });
  }

  // Ensure incidentMultipliers has all types
  if (config.incidentMultipliers) {
    if (!config.incidentMultipliers.fertiliser) config.incidentMultipliers.fertiliser = 1.2;
  }

  // Stamp version
  config._schemaVersion = CONFIG_SCHEMA_VERSION;

  return config;
}

// ===== CORRELATION MATRIX VALIDATION (Issue 5, 10) =====
function isPositiveSemiDefinite(matrix) {
  const n = matrix.length;
  // Check dimensions
  for (let i = 0; i < n; i++) {
    if (!matrix[i] || matrix[i].length !== n) return { valid: false, reason: 'Matrix is not square' };
  }
  // Check symmetry
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (Math.abs(matrix[i][j] - matrix[j][i]) > 1e-10) {
        return { valid: false, reason: 'Matrix is not symmetric at (' + i + ',' + j + ')' };
      }
    }
  }
  // Check diagonal is 1
  for (let i = 0; i < n; i++) {
    if (Math.abs(matrix[i][i] - 1.0) > 1e-10) {
      return { valid: false, reason: 'Diagonal element [' + i + '] is not 1.0' };
    }
  }
  // Try Cholesky decomposition - will fail if not PSD
  try {
    const L = choleskyDecompose(matrix);
    for (let i = 0; i < n; i++) {
      if (L[i][i] <= 0) return { valid: false, reason: 'Cholesky decomposition failed: non-positive diagonal at [' + i + ']' };
    }
    return { valid: true };
  } catch(e) {
    return { valid: false, reason: 'Cholesky decomposition failed: ' + e.message };
  }
}

function validateCorrelationMatrix(matrix, paramDefs) {
  const errors = [];
  if (!matrix || !Array.isArray(matrix)) {
    errors.push('Correlation matrix is missing or not an array');
    return { valid: false, errors };
  }
  if (matrix.length !== paramDefs.length) {
    errors.push('Correlation matrix size (' + matrix.length + ') does not match parameter count (' + paramDefs.length + ')');
    return { valid: false, errors };
  }
  const psd = isPositiveSemiDefinite(matrix);
  if (!psd.valid) {
    errors.push('Correlation matrix is not positive semi-definite: ' + psd.reason);
  }
  return { valid: errors.length === 0, errors };
}

// ===== SCENARIO COMPARISON (Issue 11) =====
let savedScenarios = [];
function saveCurrentScenario(name) {
  if (!lastScenario) { showToast('Run a scenario first', 'warning'); return; }
  const saved = {
    name: name || ('Scenario ' + (savedScenarios.length + 1)),
    timestamp: new Date().toISOString(),
    scenario: JSON.parse(JSON.stringify(lastScenario)),
    mcResults: lastMCResults ? {
      iterations: lastMCResults.iterations,
      converged: lastMCResults.converged,
      stats: JSON.parse(JSON.stringify(lastMCResults.stats))
    } : null
  };
  // Remove periods array to save space
  delete saved.scenario.periods;
  savedScenarios.push(saved);
  showToast('Scenario saved as "' + saved.name + '"', 'success');
}

// ===== SURGE COST CALCULATION (Issue 11) =====
const SURGE_COST_RATES = {
  internal: { dailyRate: 250, mobilisationCost: 500 },
  contractor: { dailyRate: 450, mobilisationCost: 2000 },
  outsource: { dailyRate: 350, mobilisationCost: 5000 }
};

function calculateSurgeCosts(surgeEntries, totalWeeks, workDaysPerWeek) {
  if (!surgeEntries || surgeEntries.length === 0) return null;
  let totalCost = 0;
  const breakdown = [];
  surgeEntries.forEach(entry => {
    const weeksActive = Math.max(0, totalWeeks - entry.startWeek + 1);
    const rate = SURGE_COST_RATES.contractor;
    const cost = (entry.extraStaff * weeksActive * workDaysPerWeek * rate.dailyRate) + (entry.extraStaff * rate.mobilisationCost);
    totalCost += cost;
    breakdown.push({ staff: entry.extraStaff, startWeek: entry.startWeek, weeksActive, cost });
  });
  return { totalCost, breakdown };
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 1: CONFIGURATION DATA
// All reference data, constants, and default settings
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ===== DEFAULT CONFIGURATION =====
const DEFAULT_CONFIG = {
  organisation: {
    staffCount: 8,
    workDaysPerWeek: 5
  },
  claimComplexity: {
    autoProcessedPct: 10,    // % of claims auto-processed (0 days)
    twoDayPct: 20,           // % of claims processed in 2 days
    customDayPct: 30,        // % of claims processed in customDays
    customDays: 3,           // number of days for the custom tier
    standardDays: 4,         // number of days for the standard tier
    // remainder = 100 - auto - twoDay - custom = processed in standardDays
  },
  // Processing days by claim type (for more detailed analysis)
  processingDays: {
    propertySimple: 3,      // Simple property: 3 days
    propertyComplex: 15,    // Complex property: 15 days
    bi: 60,                 // Business interruption: 60 days (10-20x simple property)
    injuryAcute: 5,         // Acute injury: 5 days
    injuryComplex: 20       // Complex/latent injury: 20 days
  },
  incidentMultipliers: {
    fire: 1.0,
    explosion: 1.3,
    chemical: 1.5,
    nuclear: 2.0
  },
  // Claim type split ratios (injury vs property) by incident type
  claimTypeSplits: {
    fire: { injury: 0.25, property: 0.75 },        // Fire: mostly property claims
    explosion: { injury: 0.30, property: 0.70 },   // Explosion: more injury than fire
    chemical: { injury: 0.75, property: 0.25 },    // FIXED: Bhopal pattern - injury dominant (574K injury vs small property)
    nuclear: { injury: 0.35, property: 0.65 },     // Nuclear: property-heavy (evacuation/decontamination)
    fertiliser: { injury: 0.35, property: 0.65 }   // Added fertiliser type (West, Texas pattern)
  },
  // Claim multiplier per person - accounts for multiple claims per affected individual
  // Bhopal: 1M+ registered cases for ~500K exposed (household members, follow-up, repeat filings)
  claimMultiplierPerPerson: {
    fire: 1.0,
    explosion: 1.1,
    chemical: 1.8,      // Multiple claims: household members, follow-up, repeat
    nuclear: 1.5,
    fertiliser: 1.2
  },
  severityRates: {
    minor: 0.02,
    moderate: 0.08,
    major: 0.20,
    catastrophic: 0.45
  },
  // Reserve development factors for ultimate claims estimates
  reserveDevelopmentFactors: {
    short: { min: 1.0, max: 1.2, midpoint: 1.1, note: 'Initial estimates often low' },
    medium: { min: 1.2, max: 1.5, midpoint: 1.35, note: 'Litigation costs emerge' },
    long: { min: 1.5, max: 3.0, midpoint: 2.25, note: 'Latent claims emerge' },
    chemicalLong: { min: 2.0, max: 5.0, midpoint: 3.5, note: 'Bhopal: claims for 40+ years' },
    nuclearLong: { min: 2.5, max: 6.0, midpoint: 4.25, note: '30-year limitation period' }
  },
  // Blast radius claim concentration - based on West, Texas and similar explosion data
  blastRadiusConcentration: {
    '0-500m': 0.90,     // 90% claim density (total loss, fatalities, severe injury)
    '500m-1km': 0.70,   // 60-80% → use 70% (significant structural, injury)
    '1-3km': 0.30,      // 20-40% → use 30% (windows, minor structural)
    '3-5km': 0.075      // 5-10% → use 7.5% (glass breakage, hearing)
  },
  sites: [
    { id: 'hinkley', name: 'Hinkley Point', location: 'Somerset, England', population: 35000, staffOnSite: 4000, active: true },
    { id: 'sizewell', name: 'Sizewell', location: 'Suffolk, England', population: 25000, staffOnSite: 2500, active: true },
    { id: 'heysham', name: 'Heysham', location: 'Lancashire, England', population: 30000, staffOnSite: 3000, active: true }
  ]
};

// ===== CLAIM CATEGORIES & TIMING (Research-Based) =====
// Based on historical incident analysis: BP Texas City, Buncefield, Fukushima, Bhopal, West Texas
const CLAIM_CATEGORIES = {
  acutePhysicalInjury: {
    name: 'Acute Physical Injury',
    description: 'Burns, trauma, immediate effects',
    loggingTimeline: { min: 0, max: 7, unit: 'days' },
    settlementTimeline: { min: 6, max: 24, unit: 'months' },
    applicableIncidents: ['fire', 'explosion', 'chemical', 'nuclear']
  },
  propertyDamage: {
    name: 'Property Damage',
    description: 'Structural, contents, vehicles',
    loggingTimeline: { min: 0, max: 30, unit: 'days' },
    settlementTimeline: { min: 3, max: 18, unit: 'months' },
    applicableIncidents: ['fire', 'explosion', 'chemical', 'nuclear']
  },
  businessInterruption: {
    name: 'Business Interruption',
    description: 'Ongoing assessment required',
    loggingTimeline: { min: 1, max: 3, unit: 'months' },
    settlementTimeline: { min: 12, max: 36, unit: 'months' },
    applicableIncidents: ['fire', 'explosion', 'chemical', 'nuclear']
  },
  evacuationDisplacement: {
    name: 'Evacuation/Displacement',
    description: 'Temporary accommodation costs',
    loggingTimeline: { min: 0, max: 14, unit: 'days' },
    settlementTimeline: { min: 6, max: 18, unit: 'months' },
    applicableIncidents: ['chemical', 'nuclear', 'explosion']
  },
  environmentalRemediation: {
    name: 'Environmental Remediation',
    description: 'Long-term monitoring needed',
    loggingTimeline: { min: 3, max: 24, unit: 'months' },
    settlementTimeline: { min: 5, max: 40, unit: 'years' },
    applicableIncidents: ['chemical', 'nuclear']
  },
  latentHealthClaims: {
    name: 'Latent Health Claims',
    description: 'Cancer, respiratory disease (5-60 years post-incident)',
    loggingTimeline: { min: 5, max: 60, unit: 'years' },
    settlementTimeline: { min: 1, max: 3, unit: 'yearsAfterDiagnosis' },
    applicableIncidents: ['chemical', 'nuclear']
  },
  psychologicalInjury: {
    name: 'Psychological Injury',
    description: 'PTSD, anxiety',
    loggingTimeline: { min: 1, max: 36, unit: 'months' },
    settlementTimeline: { min: 12, max: 36, unit: 'months' },
    applicableIncidents: ['fire', 'explosion', 'chemical', 'nuclear']
  },
  secondaryConsequential: {
    name: 'Secondary/Consequential',
    description: 'Supply chain, third parties',
    loggingTimeline: { min: 3, max: 24, unit: 'months' },
    settlementTimeline: { min: 12, max: 48, unit: 'months' },
    applicableIncidents: ['fire', 'explosion', 'chemical', 'nuclear']
  }
};

// ===== UK LEGAL FRAMEWORK & LIMITATION PERIODS =====
const UK_LEGAL_FRAMEWORK = {
  standardLimitations: {
    personalInjury: { years: 3, note: 'From injury/knowledge, court discretion to extend' },
    propertyDamage: { years: 6, note: 'From date of damage' },
    employersLiability: { years: 3, note: 'Discovery rule applies' }
  },
  nuclearLimitations: {
    // UK Nuclear Installations Act 1965 (as amended 2022)
    pre2022: {
      operatorLiabilityCap: '£140 million',
      personalInjury: { years: 10 },
      propertyDamage: { years: 10 },
      environmentalReinstatement: false
    },
    post2022: {
      operatorLiabilityCap: '€700 million → €1.2 billion',
      personalInjury: { years: 30, note: 'Extended from 10 years' },
      propertyDamage: { years: 10 },
      environmentalReinstatement: true
    }
  },
  discoveryRule: {
    description: 'For latent injuries, clock starts when claimant has knowledge of: (1) The injury, (2) That it was significant, (3) That it was attributable to defendant, (4) Identity of defendant'
  }
};

// ===== HISTORICAL CLAIM VOLUME DATA =====
// Based on actual incident data from research
const HISTORICAL_CLAIM_VOLUMES = {
  // Chemical Plant Explosions
  chemicalExplosion: {
    reference: 'BP Texas City (2005), Buncefield UK (2005)',
    byVariety: {
      minor: { fatalities: 0, directInjuries: '1-10', propertyClaims: '10-50', latentHealth: '0-10' },
      moderate: { fatalities: '0-5', directInjuries: '10-100', propertyClaims: '50-500', latentHealth: '10-100' },
      major: { fatalities: '5-20', directInjuries: '100-500', propertyClaims: '500-5,000', latentHealth: '100-1,000' },
      catastrophic: { fatalities: '20+', directInjuries: '500+', propertyClaims: '5,000+', latentHealth: '1,000+' }
    },
    historicalExamples: {
      bpTexasCity2005: {
        fatalities: 15,
        injured: 180,
        totalClaims: 4000,
        openClaimsAt3_5Years: 1000,
        totalSettlements: '$2.1 billion',
        propertyDamage: '$200 million',
        firstTrial: '2.5 years post-incident',
        finalOSHASettlement: '7 years post-incident'
      },
      buncefield2005: {
        fatalities: 0,
        injured: 43,
        totalClaims: 2700,
        totalEstimate: '£300 million - £1 billion',
        classActionHearing: '10 months post-incident',
        biSettlementTime: '9+ months to finalise'
      }
    }
  },
  // Nuclear Incidents
  nuclear: {
    reference: 'Fukushima (2011), Three Mile Island (1979), Windscale (1957)',
    claimDevelopment: {
      immediate: { timeline: '0-6 months', claimTypes: 'Evacuation, acute injury', percentOfUltimate: '5-10%' },
      shortTerm: { timeline: '6 months - 3 years', claimTypes: 'Property, business interruption', percentOfUltimate: '20-30%' },
      mediumTerm: { timeline: '3-10 years', claimTypes: 'Ongoing health monitoring, environment', percentOfUltimate: '30-40%' },
      longTerm: { timeline: '10-30 years', claimTypes: 'Latent cancers, genetic effects', percentOfUltimate: '20-40%' }
    },
    historicalExamples: {
      fukushima2011: {
        evacuees: 164000,
        compensationPaidBy2021: '¥9.7 trillion (~$70 billion)',
        avgFamilyCompensation: '~$900,000',
        monthlyPsychologicalPayments: '~$1,000/month for 6+ years',
        decommissioningEstimate: '30-40 years'
      },
      threeMileIsland1979: {
        lawsuitsFiled: 2000,
        documentedCompensation: '$82 million',
        classActionSettlement: '$25 million (1981, 2 years post)',
        cleanupCompleted: '1993 (14 years)',
        totalCleanupCost: '$1 billion'
      }
    }
  },
  // Fertiliser/Ammonium Nitrate Explosions
  fertiliserExplosion: {
    reference: 'West, Texas (2013), Texas City Disaster (1947)',
    claimConcentrationByRadius: {
      '0-500m': { density: 'Very High (90%+)', primaryTypes: 'Total loss, fatality, severe injury' },
      '500m-1km': { density: 'High (60-80%)', primaryTypes: 'Significant structural, injury' },
      '1-3km': { density: 'Moderate (20-40%)', primaryTypes: 'Windows, minor structural' },
      '3-5km': { density: 'Low (5-10%)', primaryTypes: 'Glass breakage, hearing' }
    },
    historicalExamples: {
      westTexas2013: {
        fatalities: 15,
        injured: 260,
        buildingsDamaged: 150,
        totalInsuredLosses: '~$230 million',
        companyInsurance: '$1 million (severe underinsurance)',
        citySettlement: '$10.44 million (5 years post)',
        femaAwards: '$63.4 million to school district'
      }
    }
  },
  // Toxic Chemical Releases
  toxicRelease: {
    reference: 'Bhopal (1984), Seveso (1976)',
    longTailCharacteristics: [
      'Latency periods: 5-40+ years for cancers',
      'Causation disputes: Proving link between exposure and illness',
      'Generational effects: Children born after incident showing effects',
      'Environmental persistence: Ongoing groundwater/soil contamination'
    ],
    historicalExamples: {
      bhopal1984: {
        immediateDeaths: 3000,
        totalInjuryClaimsAwarded: 574304,
        totalClaimsRejected: 455213,
        totalCasesRegistered: 1029517,
        settlementAmount: '$470 million',
        settlementYear: 1989,
        avgDeathCompensation: '$2,200',
        avgInjuryCompensation: '$300-$500',
        ongoingEffects: '40+ years later, health effects still documented'
      }
    }
  },
  // Industrial Fires
  industrialFire: {
    reference: 'NFPA data, Allianz Global Claims Review',
    context: {
      percentOfDirectPropertyDamage: '69% of industrial sector losses',
      avgAnnualInsuredLosses: '$700+ million (manufacturing/industrial)',
      globalRank: '#1 cause of corporate insurance losses (21% by value)'
    },
    bySeverity: {
      contained: { propertyClaims: '1-10', injuryClaims: '0-5', biClaims: '0-5', typicalDuration: '3-12 months' },
      significant: { propertyClaims: '10-100', injuryClaims: '5-50', biClaims: '10-50', typicalDuration: '6-24 months' },
      majorMultiBuilding: { propertyClaims: '100-1,000', injuryClaims: '50-200', biClaims: '50-200', typicalDuration: '12-48 months' },
      catastrophic: { propertyClaims: '1,000+', injuryClaims: '200+', biClaims: '200+', typicalDuration: '24-60+ months' }
    }
  }
};

// ===== CLAIM DISTRIBUTION TEMPLATES (Research-Based Percentages) =====
// Bimodal distribution: immediate spike + long tail for latent claims
const CLAIM_DISTRIBUTION_TEMPLATES = {
  explosionFire: {
    name: 'Explosion/Fire Incident',
    distribution: [
      { period: 'Week 1-4', percent: 70, types: 'Property damage, acute injury, evacuation' },
      { period: 'Month 2-12', percent: 20, types: 'Business interruption, delayed property, PTSD' },
      { period: 'Year 1-5', percent: 8, types: 'Complex injury, litigation, environmental' },
      { period: 'Year 5-30', percent: 2, types: 'Latent illness (if chemical exposure)' }
    ]
  },
  toxicRelease: {
    name: 'Toxic Release Incident',
    distribution: [
      { period: 'Week 1-4', percent: 25, types: 'Evacuation, acute poisoning, immediate property' },
      { period: 'Month 2-24', percent: 30, types: 'Respiratory illness, property decontamination' },
      { period: 'Year 2-10', percent: 25, types: 'Chronic illness develops, environmental cleanup' },
      { period: 'Year 10-40', percent: 20, types: 'Cancers, generational effects, ongoing environmental' }
    ]
  },
  nuclear: {
    name: 'Nuclear Incident',
    distribution: [
      { period: 'Week 1-4', percent: 10, types: 'Evacuation, acute radiation (if any)' },
      { period: 'Month 2-36', percent: 35, types: 'Property exclusion zones, business disruption' },
      { period: 'Year 3-15', percent: 30, types: 'Health monitoring, thyroid cancers, environment' },
      { period: 'Year 15-30', percent: 25, types: 'Late cancers, continued decommissioning' }
    ]
  }
};

// ===== TIME HORIZON CONFIGURATIONS =====
// Legacy fixed horizons (kept as fallback)
const TIME_HORIZONS = {
  short: { weeks: 12, label: '12 Weeks', unitLabel: 'Week' },
  medium: { weeks: 104, label: '2 Years', unitLabel: 'Week' },
  long: { weeks: 520, label: '10 Years', unitLabel: 'Month' }
};

// ===== SEVERITY-BASED TIME HORIZONS (Research-Calibrated) =====
// Time horizons dynamically calibrated by incident type and severity level.
// Based on historical claim lifecycle data: settlement timelines, latency periods,
// limitation periods, and documented claim development patterns.
const SEVERITY_TIME_HORIZONS = {
  // Fire: NFPA/Allianz data. Property 3-18mo resolution, BI 12-36mo.
  // Minor fires resolve quickly; catastrophic may involve chemical exposure tails.
  fire: {
    minor: {
      short: { weeks: 8 },
      medium: { weeks: 26 },
      long: { weeks: 104 },
      note: 'Minor fires: most claims resolve within weeks. Settlement 3-6 months for simple property.'
    },
    moderate: {
      short: { weeks: 12 },
      medium: { weeks: 52 },
      long: { weeks: 156 },
      note: 'Moderate fires: complex property + BI claims develop over 6-18 months. PTSD claims at 12-36 months.'
    },
    major: {
      short: { weeks: 12 },
      medium: { weeks: 78 },
      long: { weeks: 260 },
      note: 'Major fires: BI exceeds PD by ~2.7x. Litigation extends 3-5 years (BP Texas City pattern).'
    },
    catastrophic: {
      short: { weeks: 16 },
      medium: { weeks: 104 },
      long: { weeks: 364 },
      note: 'Catastrophic fires: potential chemical exposure creates long-tail health claims. 69% of direct PD in industrial sector.'
    }
  },
  // Explosion: BP Texas City ($2.1B/7yrs), Buncefield (£300M-1B, BI 9+ months).
  // 90%+ claims within 500m blast radius. BI becomes pacing item at 12-36 months.
  explosion: {
    minor: {
      short: { weeks: 8 },
      medium: { weeks: 26 },
      long: { weeks: 104 },
      note: 'Minor explosions: localised blast damage. Property claims within 500m resolve in weeks.'
    },
    moderate: {
      short: { weeks: 12 },
      medium: { weeks: 52 },
      long: { weeks: 156 },
      note: 'Moderate explosions: BI claims develop over 12-36 months. Buncefield: BI settlements took 9+ months.'
    },
    major: {
      short: { weeks: 12 },
      medium: { weeks: 78 },
      long: { weeks: 260 },
      note: 'Major explosions: BP Texas City pattern - 4,000 claims, settlements over 7 years. Forensic accounting required for BI.'
    },
    catastrophic: {
      short: { weeks: 16 },
      medium: { weeks: 104 },
      long: { weeks: 364 },
      note: 'Catastrophic explosions: $2.1B+ settlement potential (BP Texas City). Secondary/consequential claims emerge at 3-24 months.'
    }
  },
  // Chemical (toxic release): Bhopal (1M+ claims over 40 years), Seveso (1976).
  // Bimodal: 25% acute (weeks 1-4), then decades of chronic illness, cancers.
  // UK discovery rule: 3-year limitation from knowledge of injury.
  chemical: {
    minor: {
      short: { weeks: 12 },
      medium: { weeks: 104 },
      long: { weeks: 520 },
      note: 'Minor chemical release: acute poisoning 25% in weeks 1-4. Respiratory illness develops at months 2-24. Environmental remediation 5-10 years.'
    },
    moderate: {
      short: { weeks: 16 },
      medium: { weeks: 156 },
      long: { weeks: 1040 },
      note: 'Moderate toxic release: chronic illness at years 2-10. Environmental cleanup extends to decades. Discovery rule applies for latent injuries.'
    },
    major: {
      short: { weeks: 24 },
      medium: { weeks: 260 },
      long: { weeks: 1560 },
      note: 'Major toxic release: Bhopal pattern - 574,304 injury claims, $470M settlement. Cancers and generational effects documented 40+ years later.'
    },
    catastrophic: {
      short: { weeks: 26 },
      medium: { weeks: 260 },
      long: { weeks: 2080 },
      note: 'Catastrophic chemical disaster: Bhopal-scale. 1M+ claims spanning 40+ years. Long-tail cancers, generational effects, ongoing environmental remediation.'
    }
  },
  // Nuclear: Fukushima ($70B+ by 2021), Three Mile Island ($82M, 14-year cleanup).
  // UK Nuclear Installations Act 2022: 30-year personal injury limitation.
  // Thyroid cancers peak at 5-20 years post-incident.
  nuclear: {
    minor: {
      short: { weeks: 12 },
      medium: { weeks: 156 },
      long: { weeks: 780 },
      note: 'Minor nuclear incident: evacuation claims immediate. Health monitoring at years 3-15. Three Mile Island: $82M documented, 14-year cleanup.'
    },
    moderate: {
      short: { weeks: 16 },
      medium: { weeks: 260 },
      long: { weeks: 1040 },
      note: 'Moderate nuclear incident: property exclusion zones, BI disruption months 2-36. Thyroid cancers emerge years 5-20.'
    },
    major: {
      short: { weeks: 24 },
      medium: { weeks: 364 },
      long: { weeks: 1560 },
      note: 'Major nuclear incident: Fukushima-scale pattern. 164,000+ evacuees. UK law: 30-year personal injury limitation (2022 Act). $70B+ compensation.'
    },
    catastrophic: {
      short: { weeks: 26 },
      medium: { weeks: 520 },
      long: { weeks: 1560 },
      note: 'Catastrophic nuclear disaster: 30-year limitation period applies. 20-40% of ultimate claims emerge at years 10-30 (late cancers, genetic effects).'
    }
  },
  // Fertiliser (ammonium nitrate): West, Texas (2013) pattern.
  // Similar to explosion but with potential chemical exposure tail.
  // $230M losses vs $1M coverage. 150 buildings, 15 fatalities.
  fertiliser: {
    minor: {
      short: { weeks: 8 },
      medium: { weeks: 26 },
      long: { weeks: 104 },
      note: 'Minor fertiliser incident: localised blast + potential ammonia exposure. Property claims resolve in weeks.'
    },
    moderate: {
      short: { weeks: 12 },
      medium: { weeks: 52 },
      long: { weeks: 156 },
      note: 'Moderate fertiliser explosion: West, Texas parallel. BI and environmental claims develop over months.'
    },
    major: {
      short: { weeks: 12 },
      medium: { weeks: 78 },
      long: { weeks: 312 },
      note: 'Major fertiliser explosion: West, Texas - 150 buildings damaged, FEMA $63.4M to school district alone. Chemical exposure extends timeline.'
    },
    catastrophic: {
      short: { weeks: 16 },
      medium: { weeks: 104 },
      long: { weeks: 520 },
      note: 'Catastrophic fertiliser disaster: $230M+ losses (West, Texas). Chemical contamination creates long-tail similar to toxic release incidents.'
    }
  }
};

// ===== SEVERITY TIME HORIZON HELPERS =====

// Get the severity-calibrated time horizon configuration
function getSeverityTimeHorizon(incident, severity) {
  const incidentHorizons = SEVERITY_TIME_HORIZONS[incident] || SEVERITY_TIME_HORIZONS.fire;
  return incidentHorizons[severity] || incidentHorizons.moderate;
}

// Resolve a specific horizon (short/medium/long) into a full configuration object
function resolveHorizonConfig(incident, severity, horizon) {
  const severityHorizon = getSeverityTimeHorizon(incident, severity);
  const horizonDef = severityHorizon[horizon];
  const totalWeeks = horizonDef.weeks;

  // Determine display unit: weekly if <= 52 weeks, monthly otherwise
  const isMonthly = totalWeeks > 52;
  const numPeriods = isMonthly ? Math.round(totalWeeks / 4.33) : totalWeeks;
  const unitLabel = isMonthly ? 'Month' : 'Week';

  // Generate human-readable label
  let label;
  if (totalWeeks <= 16) {
    label = totalWeeks + ' Weeks';
  } else if (totalWeeks <= 52) {
    const months = Math.round(totalWeeks / 4.33);
    label = months + ' Months';
  } else {
    const years = totalWeeks / 52;
    label = years === Math.floor(years) ? years + ' Years' : years.toFixed(1) + ' Years';
  }

  return {
    weeks: totalWeeks,
    numPeriods,
    isMonthly,
    unitLabel,
    label,
    note: severityHorizon.note,
    periodCapacityMultiplier: isMonthly ? 4.33 : 1
  };
}

// Update the time horizon dropdown labels based on current incident + severity
function updateTimeHorizonLabels() {
  const incident = document.getElementById('incidentSelect').value;
  const severity = document.getElementById('severitySelect').value;
  const select = document.getElementById('timeHorizonSelect');

  const horizonNames = { short: 'Short Term', medium: 'Medium Term', long: 'Long Term' };

  ['short', 'medium', 'long'].forEach(h => {
    const config = resolveHorizonConfig(incident, severity, h);
    const option = select.querySelector(`option[value="${h}"]`);
    if (option) {
      option.textContent = `${horizonNames[h]} (0-${config.label})`;
    }
  });

  // Update the severity horizon info panel
  const severityHorizon = getSeverityTimeHorizon(incident, severity);
  const infoEl = document.getElementById('severityHorizonNote');
  if (infoEl) {
    infoEl.innerHTML = `<strong style="color:#e2e8f0">Time Calibration:</strong> ${severityHorizon.note}`;
  }
}

// ===== INCIDENT CLAIM PATTERNS =====
// Severity-differentiated patterns: shape and tail weight vary by severity level.
// Minor incidents: concentrated early spike, fast resolution, light tails.
// Catastrophic incidents: early spike still present but broader, heavier tails,
// more complex secondary peaks reflecting prolonged litigation and latent effects.
// All peak positions in weeks (simulation always runs weekly).
const CLAIM_PATTERNS = {
  // Fire patterns - NFPA/Allianz data
  fire: {
    // Fire injury: early spike from burns/smoke inhalation
    // Minor: concentrated spike, fast resolution (weeks). Catastrophic: heavier disability/PTSD tail.
    injury: {
      minor:        { peakWeek: 2, shape: 'sharp_spike',  tailWeight: 0.05 },  // Simple burns, fast resolution
      moderate:     { peakWeek: 2, shape: 'spike',         tailWeight: 0.12 },  // Some disability cases extend timeline
      major:        { peakWeek: 3, shape: 'spike',         tailWeight: 0.20 },  // PTSD + complex injury tail (12-36 months)
      catastrophic: { peakWeek: 3, shape: 'spike_long_tail', tailWeight: 0.30 } // Severe burns, disability, litigation extends years
    },
    // Fire property: immediate spike + re-scope waves as hidden damage discovered
    // Minor: single spike. Major/catastrophic: re-scope waves, BI exceeds PD by ~2.7x.
    property: {
      minor:        { peakWeek: 2, shape: 'spike',          tailWeight: 0.08 },  // Simple property, 3-6mo resolution
      moderate:     { peakWeek: 3, shape: 'spike_rescope',   tailWeight: 0.18 },  // Re-scope waves for hidden damage
      major:        { peakWeek: 3, shape: 'spike_rescope',   tailWeight: 0.28 },  // Complex property + BI develops 12-36mo
      catastrophic: { peakWeek: 4, shape: 'spike_rescope',   tailWeight: 0.38 }   // Major BI tail, rebuild delays, litigation
    }
  },
  // Explosion patterns - BP Texas City, Buncefield calibrated
  explosion: {
    // Explosion injury: sharp immediate spike (0-7 days), high severity, early reporting
    // Minor: concentrated. Catastrophic: more severe injuries, longer rehabilitation tail.
    injury: {
      minor:        { peakWeek: 1, shape: 'sharp_spike',  tailWeight: 0.05 },  // Localised, fast resolution
      moderate:     { peakWeek: 1, shape: 'sharp_spike',   tailWeight: 0.10 },  // Burns, TBI - specialist assessors needed
      major:        { peakWeek: 2, shape: 'spike',         tailWeight: 0.18 },  // Complex injuries, amputations, longer rehab
      catastrophic: { peakWeek: 2, shape: 'spike_long_tail', tailWeight: 0.25 } // Mass casualty, extended rehabilitation + litigation
    },
    // Explosion property: instant sharp spike across blast radius (90%+ claims within 500m)
    // Minor: concentrated blast. Catastrophic: wider radius + BI develops over 12-36 months.
    property: {
      minor:        { peakWeek: 1, shape: 'sharp_spike',   tailWeight: 0.10 },  // Localised blast damage
      moderate:     { peakWeek: 2, shape: 'sharp_spike',    tailWeight: 0.22 },  // Wider radius, BI starting
      major:        { peakWeek: 2, shape: 'spike_bi_tail',  tailWeight: 0.30 },  // Significant BI tail (9+ months, Buncefield)
      catastrophic: { peakWeek: 3, shape: 'spike_bi_tail',  tailWeight: 0.40 }   // Massive BI (BP Texas City: 7-year settlements)
    }
  },
  // Chemical (toxic release) patterns - Bhopal/Seveso calibrated
  chemical: {
    // Chemical injury: acute poisoning spike (25% in weeks 1-4), then LONG tail
    // Minor: mainly acute. Catastrophic: decades of chronic illness (Bhopal: 40+ years).
    injury: {
      minor:        { peakWeek: 2, shape: 'sharp_spike',     tailWeight: 0.15 },  // Acute poisoning, limited exposure
      moderate:     { peakWeek: 2, shape: 'spike_long_tail',  tailWeight: 0.30 },  // Respiratory illness at months 2-24
      major:        { peakWeek: 3, shape: 'spike_long_tail',  tailWeight: 0.45 },  // Chronic illness years 2-10, cancers
      catastrophic: { peakWeek: 3, shape: 'very_long_tail',   tailWeight: 0.55 }   // Bhopal-scale: 1M+ claims over 40 years
    },
    // Chemical property: mid-fast spike, contamination persistence varies with severity
    // Minor: standard property. Catastrophic: soil/groundwater contamination, decades of remediation.
    property: {
      minor:        { peakWeek: 3, shape: 'moderate_spike',    tailWeight: 0.10 },  // Limited contamination
      moderate:     { peakWeek: 4, shape: 'moderate_spike',     tailWeight: 0.22 },  // Some decontamination needed
      major:        { peakWeek: 4, shape: 'extended_plateau',   tailWeight: 0.32 },  // Environmental cleanup extends years
      catastrophic: { peakWeek: 5, shape: 'contamination_tail', tailWeight: 0.40 }   // Decades of remediation, secondary discovery peaks
    }
  },
  // Nuclear (radiological) patterns - Fukushima/Three Mile Island/Chernobyl calibrated
  nuclear: {
    // Nuclear injury: small immediate spike, VERY long tail (latency effects)
    // Minor: health monitoring only. Catastrophic: thyroid cancers peak at 5-20 years.
    injury: {
      minor:        { peakWeek: 3, shape: 'low_early',      tailWeight: 0.25 },  // Precautionary evacuation, monitoring
      moderate:     { peakWeek: 4, shape: 'delayed_rise',    tailWeight: 0.40 },  // Health monitoring, some latent effects
      major:        { peakWeek: 5, shape: 'delayed_rise',    tailWeight: 0.55 },  // Thyroid cancers emerge years 5-20
      catastrophic: { peakWeek: 6, shape: 'latency_driven',  tailWeight: 0.70 }   // Fukushima/Chernobyl-scale: 30-year claims
    },
    // Nuclear property: evacuation spike, extended plateau from exclusion zones
    // Minor: brief evacuation. Catastrophic: permanent exclusion zones, stigma-driven resurgences.
    property: {
      minor:        { peakWeek: 2, shape: 'rapid_rise',         tailWeight: 0.20 },  // Brief evacuation, quick return
      moderate:     { peakWeek: 3, shape: 'rapid_rise',          tailWeight: 0.40 },  // Extended evacuation, some BI
      major:        { peakWeek: 4, shape: 'evacuation_plateau',  tailWeight: 0.55 },  // Exclusion zones, years of displacement
      catastrophic: { peakWeek: 5, shape: 'stigma_tail',         tailWeight: 0.60 }   // Permanent exclusion, stigma resurgences decades later
    }
  },
  // Fertiliser (ammonium nitrate) patterns - West, Texas 2013 calibrated
  // Blast pattern similar to explosion but with chemical exposure tail
  fertiliser: {
    // Fertiliser injury: sharp blast injury spike + chemical exposure tail (ammonia/nitrate)
    injury: {
      minor:        { peakWeek: 1, shape: 'sharp_spike',     tailWeight: 0.06 },  // Localised blast, minor chemical
      moderate:     { peakWeek: 1, shape: 'sharp_spike',      tailWeight: 0.14 },  // Burns + ammonia exposure
      major:        { peakWeek: 2, shape: 'spike_long_tail',  tailWeight: 0.25 },  // Significant chemical exposure tail
      catastrophic: { peakWeek: 2, shape: 'spike_long_tail',  tailWeight: 0.35 }   // West Texas-scale: mass injury + chemical exposure
    },
    // Fertiliser property: blast damage spike + environmental contamination
    property: {
      minor:        { peakWeek: 1, shape: 'sharp_spike',     tailWeight: 0.08 },  // Localised blast radius
      moderate:     { peakWeek: 2, shape: 'spike_bi_tail',    tailWeight: 0.20 },  // BI developing, some contamination
      major:        { peakWeek: 2, shape: 'spike_bi_tail',    tailWeight: 0.30 },  // 150 buildings (West Texas), BI + environmental
      catastrophic: { peakWeek: 3, shape: 'contamination_tail', tailWeight: 0.38 } // Massive blast radius + chemical contamination tail
    }
  }
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 2: STATE MANAGEMENT
// Config persistence, mutable state
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Load config from localStorage or use defaults
let config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
try {
  const saved = loadWithIntegrity('claimsToolConfig');
  if (saved) {
    config = migrateConfig(saved);
  }
} catch(e) {
  console.warn('Failed to load config, using defaults:', e);
}

function saveConfig() {
  saveWithIntegrity('claimsToolConfig', config);
  clearUnsaved();
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 3: HELPER FUNCTIONS
// Calculations, data lookups, distribution model
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ===== CAPACITY CALCULATION =====
// Calculate weighted average days per claim based on complexity mix
function getWeightedDaysPerClaim() {
  const cc = config.claimComplexity || DEFAULT_CONFIG.claimComplexity;
  const autoPct = sanitizeNumberInput(cc.autoProcessedPct, 0, 100, 10) / 100;
  const twoDayPct = sanitizeNumberInput(cc.twoDayPct, 0, 100, 20) / 100;
  const customPct = sanitizeNumberInput(cc.customDayPct, 0, 100, 30) / 100;
  const standardPct = Math.max(0, 1 - autoPct - twoDayPct - customPct);
  const customDays = sanitizeNumberInput(cc.customDays, 0.5, 20, 3);
  const standardDays = sanitizeNumberInput(cc.standardDays, 0.5, 30, 4);
  // weighted average: auto=0 days, twoDay=2 days, custom=customDays, standard=standardDays
  return (autoPct * 0) + (twoDayPct * 2) + (customPct * customDays) + (standardPct * standardDays);
}

// Calculate weekly capacity from staff, working days, and weighted processing time
function getWeeklyCapacity() {
  const staffCount = sanitizeNumberInput(config.organisation.staffCount, 1, 10000, 8);
  const workDays = sanitizeNumberInput(config.organisation.workDaysPerWeek, 1, 7, 5);
  const weightedDays = getWeightedDaysPerClaim();
  if (weightedDays <= 0) return staffCount * workDays;
  return Math.max(1, Math.round(staffCount * workDays / weightedDays));
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 4: UI UPDATE FUNCTIONS
// View switching, admin panel, site management, surge resources
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ===== VIEW SWITCHING =====
function switchView(view) {
  const scenarioTab = document.getElementById('scenarioTab');
  const adminTab = document.getElementById('adminTab');
  document.querySelectorAll('.nav-tab').forEach(t => {
    t.classList.remove('active');
    t.setAttribute('aria-selected', 'false');
  });
  if (view === 'scenario') {
    document.getElementById('scenarioPanel').style.display = '';
    document.getElementById('adminPanel').style.display = 'none';
    scenarioTab.classList.add('active');
    scenarioTab.setAttribute('aria-selected', 'true');
  } else {
    document.getElementById('scenarioPanel').style.display = 'none';
    document.getElementById('adminPanel').style.display = '';
    adminTab.classList.add('active');
    adminTab.setAttribute('aria-selected', 'true');
    loadAdmin();
  }
}

// ===== POPULATE SITE DROPDOWN =====
function populateSites() {
  const sel = document.getElementById('siteSelect');
  sel.innerHTML = '';
  config.sites.filter(s => s.active).forEach(s => {
    const opt = document.createElement('option');
    opt.value = s.id; opt.textContent = s.name + ' - ' + s.location;
    sel.appendChild(opt);
  });
}

// ===== ADMIN PANEL =====
function loadAdmin() {
  document.getElementById('adminStaff').value = config.organisation.staffCount;
  document.getElementById('adminWorkDays').value = config.organisation.workDaysPerWeek;
  // Complexity sliders
  const cc = config.claimComplexity || DEFAULT_CONFIG.claimComplexity;
  document.getElementById('autoProcessedSlider').value = cc.autoProcessedPct;
  document.getElementById('twoDaySlider').value = cc.twoDayPct;
  document.getElementById('customDaySlider').value = cc.customDayPct;
  document.getElementById('customDaysInput').value = cc.customDays;
  document.getElementById('standardDaysInput').value = cc.standardDays || 4;
  updateComplexityDisplay();
  document.getElementById('multFire').value = config.incidentMultipliers.fire;
  document.getElementById('multExplosion').value = config.incidentMultipliers.explosion;
  document.getElementById('multChemical').value = config.incidentMultipliers.chemical || 1.5;
  document.getElementById('multNuclear').value = config.incidentMultipliers.nuclear || 2.0;
  document.getElementById('rateMinor').value = (config.severityRates.minor * 100);
  document.getElementById('rateModerate').value = (config.severityRates.moderate * 100);
  document.getElementById('rateMajor').value = (config.severityRates.major * 100);
  document.getElementById('rateCatastrophic').value = (config.severityRates.catastrophic * 100);
  renderSitesAdmin();
  if (typeof loadMCAdmin === 'function') loadMCAdmin();
}

function saveAdmin() {
  config.organisation.staffCount = sanitizeIntInput(document.getElementById('adminStaff').value, 1, 1000, 8);
  config.organisation.workDaysPerWeek = sanitizeIntInput(document.getElementById('adminWorkDays').value, 1, 7, 5);
  config.incidentMultipliers.fire = sanitizeNumberInput(document.getElementById('multFire').value, 0.1, 10, 1.0);
  config.incidentMultipliers.explosion = sanitizeNumberInput(document.getElementById('multExplosion').value, 0.1, 10, 1.3);
  config.incidentMultipliers.chemical = sanitizeNumberInput(document.getElementById('multChemical').value, 0.1, 10, 1.5);
  config.incidentMultipliers.nuclear = sanitizeNumberInput(document.getElementById('multNuclear').value, 0.1, 10, 2.0);
  config.severityRates.minor = sanitizeNumberInput(document.getElementById('rateMinor').value, 0, 100, 2) / 100;
  config.severityRates.moderate = sanitizeNumberInput(document.getElementById('rateModerate').value, 0, 100, 8) / 100;
  config.severityRates.major = sanitizeNumberInput(document.getElementById('rateMajor').value, 0, 100, 20) / 100;
  config.severityRates.catastrophic = sanitizeNumberInput(document.getElementById('rateCatastrophic').value, 0, 100, 45) / 100;
  updateComplexityDisplay();
  saveConfig();
  populateSites();
}

function updateComplexitySlider() {
  let autoPct = sanitizeIntInput(document.getElementById('autoProcessedSlider').value, 0, 100, 0);
  let twoDayPct = sanitizeIntInput(document.getElementById('twoDaySlider').value, 0, 100, 0);
  let customPct = sanitizeIntInput(document.getElementById('customDaySlider').value, 0, 100, 0);
  const customDays = sanitizeNumberInput(document.getElementById('customDaysInput').value, 0.5, 20, 3);
  const standardDays = sanitizeNumberInput(document.getElementById('standardDaysInput').value, 0.5, 30, 4);

  // Clamp so total doesn't exceed 100
  if (autoPct + twoDayPct + customPct > 100) {
    customPct = Math.max(0, 100 - autoPct - twoDayPct);
    document.getElementById('customDaySlider').value = customPct;
  }

  if (!config.claimComplexity) config.claimComplexity = {};
  config.claimComplexity.autoProcessedPct = autoPct;
  config.claimComplexity.twoDayPct = twoDayPct;
  config.claimComplexity.customDayPct = customPct;
  config.claimComplexity.customDays = customDays;
  config.claimComplexity.standardDays = standardDays;

  updateComplexityDisplay();
  saveConfig();
}

function updateComplexityDisplay() {
  const cc = config.claimComplexity || DEFAULT_CONFIG.claimComplexity;
  const standardPct = Math.max(0, 100 - cc.autoProcessedPct - cc.twoDayPct - cc.customDayPct);
  const weightedDays = getWeightedDaysPerClaim();
  const weeklyCapacity = getWeeklyCapacity();

  document.getElementById('autoProcessedValue').textContent = cc.autoProcessedPct + '%';
  document.getElementById('twoDayValue').textContent = cc.twoDayPct + '%';
  document.getElementById('customDayValue').textContent = cc.customDayPct + '%';

  document.getElementById('calculatedCapacity').textContent = weeklyCapacity;
  document.getElementById('capacityFormula').textContent =
    config.organisation.staffCount + ' staff × ' + config.organisation.workDaysPerWeek + ' days ÷ ' + weightedDays.toFixed(1) + ' avg days/claim';

  document.getElementById('complexityBreakdown').innerHTML = `
    <div style="display:flex;gap:4px;height:16px;border-radius:4px;overflow:hidden;margin-bottom:8px">
      ${cc.autoProcessedPct > 0 ? `<div style="width:${cc.autoProcessedPct}%;background:#22c55e" title="Auto"></div>` : ''}
      ${cc.twoDayPct > 0 ? `<div style="width:${cc.twoDayPct}%;background:#3b82f6" title="2-day"></div>` : ''}
      ${cc.customDayPct > 0 ? `<div style="width:${cc.customDayPct}%;background:#eab308" title="${cc.customDays}-day"></div>` : ''}
      ${standardPct > 0 ? `<div style="width:${standardPct}%;background:#ef4444" title="Standard"></div>` : ''}
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;color:#94a3b8">
      <span><span style="color:#22c55e">●</span> Auto: ${cc.autoProcessedPct}%</span>
      <span><span style="color:#3b82f6">●</span> 2-day: ${cc.twoDayPct}%</span>
      <span><span style="color:#eab308">●</span> ${cc.customDays}-day: ${cc.customDayPct}%</span>
      <span><span style="color:#ef4444">●</span> Standard (${cc.standardDays || 4}d): ${standardPct}%</span>
    </div>
    <div style="margin-top:6px;color:#64748b;font-size:11px">Weighted avg: ${weightedDays.toFixed(1)} days/claim → <strong style="color:#3b82f6">${weeklyCapacity} claims/week</strong></div>
  `;
}

function renderSitesAdmin() {
  const container = document.getElementById('sitesAdminList');
  container.innerHTML = '';
  config.sites.forEach((site, idx) => {
    const div = document.createElement('div');
    div.className = 'site-card';
    const safeName = sanitizeHTML(site.name);
    const safeLocation = sanitizeHTML(site.location);
    div.innerHTML = `
      <div class="site-card-header">
        <h4>${safeName}</h4>
        <span class="tag ${site.active ? 'tag-active' : ''}">${site.active ? 'Active' : 'Inactive'}</span>
      </div>
      <div class="admin-grid">
        <div class="form-group">
          <label for="siteName${idx}">Name</label>
          <input type="text" id="siteName${idx}" value="${safeName}" maxlength="100" onchange="updateSite(${idx},'name',this.value)" aria-label="Site name">
        </div>
        <div class="form-group">
          <label for="siteLoc${idx}">Location</label>
          <input type="text" id="siteLoc${idx}" value="${safeLocation}" maxlength="200" onchange="updateSite(${idx},'location',this.value)" aria-label="Site location">
        </div>
        <div class="form-group">
          <label for="sitePop${idx}">Local Population</label>
          <input type="number" id="sitePop${idx}" value="${site.population}" min="1" max="10000000" onchange="updateSite(${idx},'population',parseInt(this.value))" aria-label="Local population" inputmode="numeric">
        </div>
        <div class="form-group">
          <label for="siteStaff${idx}">Staff on Site</label>
          <input type="number" id="siteStaff${idx}" value="${site.staffOnSite}" min="0" max="100000" onchange="updateSite(${idx},'staffOnSite',parseInt(this.value))" aria-label="Staff on site" inputmode="numeric">
        </div>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button class="btn btn-secondary" style="width:auto;padding:6px 12px;font-size:12px" onclick="toggleSiteActive(${idx})" aria-label="${site.active ? 'Deactivate' : 'Activate'} ${safeName}">${site.active ? 'Deactivate' : 'Activate'}</button>
        <button class="btn btn-danger" style="width:auto;padding:6px 12px;font-size:12px" onclick="removeSite(${idx})" aria-label="Remove ${safeName}">Remove</button>
      </div>
    `;
    container.appendChild(div);
  });
}

function updateSite(idx, field, value) {
  // Validate input based on field type
  if (field === 'population' || field === 'staffOnSite') {
    value = sanitizeIntInput(value, 0, 10000000, config.sites[idx][field]);
    if (field === 'population' && value <= 0) {
      showToast('Population must be greater than zero', 'warning');
      value = 1;
    }
  }
  if (field === 'name' || field === 'location') {
    value = String(value).substring(0, field === 'name' ? 100 : 200);
  }
  config.sites[idx][field] = value;
  if (field === 'name') {
    config.sites[idx].id = value.toLowerCase().replace(/[^a-z0-9]/g, '_');
  }
  saveConfig();
  populateSites();
  renderSitesAdmin();
}

function toggleSiteActive(idx) {
  config.sites[idx].active = !config.sites[idx].active;
  saveConfig();
  populateSites();
  renderSitesAdmin();
}

function removeSite(idx) {
  if (config.sites.length <= 1) { showToast('You must have at least one site.', 'warning'); return; }
  const siteName = sanitizeHTML(config.sites[idx].name);
  confirmAction('Remove Site', 'Are you sure you want to remove "' + siteName + '"? This cannot be undone.', function() {
    config.sites.splice(idx, 1);
    saveConfig();
    populateSites();
    renderSitesAdmin();
    showToast('Site removed', 'info');
  });
}

function addSitePrompt() {
  const name = prompt('Enter site name:');
  if (!name || !name.trim()) return;
  const safeName = name.trim().substring(0, 100);
  const location = (prompt('Enter location:') || '').trim().substring(0, 200);
  const populationInput = prompt('Enter local population estimate:');
  const population = sanitizeIntInput(populationInput, 1, 10000000, 10000);
  const staffInput = prompt('Enter staff on site:');
  const staff = sanitizeIntInput(staffInput, 0, 100000, 500);
  config.sites.push({
    id: safeName.toLowerCase().replace(/[^a-z0-9]/g, '_'),
    name: safeName,
    location: location,
    population: population,
    staffOnSite: staff,
    active: true
  });
  saveConfig();
  populateSites();
  renderSitesAdmin();
  showToast('Site "' + sanitizeHTML(safeName) + '" added', 'success');
}

function exportConfig() {
  const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'claims-tool-config.json';
  a.click();
}

function importConfig(event) {
  const file = event.target.files[0];
  if (!file) return;

  // Validate file size (max 1MB)
  if (file.size > 1024 * 1024) {
    showToast('Config file too large (max 1MB)', 'error');
    event.target.value = '';
    return;
  }

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const parsed = JSON.parse(e.target.result);

      // Validate schema before applying
      const validation = validateConfigSchema(parsed);
      if (!validation.valid) {
        showToast('Invalid config: ' + validation.errors.join('; '), 'error');
        return;
      }

      // Migrate and apply
      config = migrateConfig(parsed);
      saveConfig();
      populateSites();
      loadAdmin();
      showToast('Configuration imported successfully', 'success');
    } catch(err) {
      showToast('Invalid config file: ' + err.message, 'error');
    }
  };
  reader.onerror = function() {
    showToast('Failed to read config file', 'error');
  };
  reader.readAsText(file);
  event.target.value = '';
}

// ===== CLAIMS DISTRIBUTION MODEL =====
// Advanced distribution model based on incident type, claim type, and time horizon

// Generate distribution based on shape type
function generateShapedDistribution(numPeriods, peakPeriod, shape, tailWeight) {
  const raw = [];

  for (let i = 1; i <= numPeriods; i++) {
    let val = 0;

    switch (shape) {
      case 'sharp_spike':
        // Very sharp spike, fast decay
        val = Math.exp(-0.8 * Math.pow((i - peakPeriod) / 1.2, 2)) + 0.01;
        break;

      case 'spike':
        // Standard spike with moderate decay
        val = Math.exp(-0.5 * Math.pow((i - peakPeriod) / 1.8, 2)) + 0.015;
        break;

      case 'moderate_spike':
        // Moderate spike, wider spread
        val = Math.exp(-0.4 * Math.pow((i - peakPeriod) / 2.5, 2)) + 0.02;
        break;

      case 'spike_rescope':
        // Initial spike with secondary bump (re-scoping for fire property)
        val = Math.exp(-0.5 * Math.pow((i - peakPeriod) / 1.5, 2)) +
              0.3 * Math.exp(-0.5 * Math.pow((i - peakPeriod - 4) / 2, 2)) + 0.02;
        break;

      case 'spike_bi_tail':
        // Spike with business interruption tail
        val = Math.exp(-0.6 * Math.pow((i - peakPeriod) / 1.5, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.exp(-0.1 * (i - peakPeriod));
        }
        val += 0.015;
        break;

      case 'fast_decay':
        // Fast initial spike, quick decay
        val = Math.exp(-0.7 * Math.pow((i - peakPeriod) / 1.3, 2)) + 0.01;
        break;

      case 'spike_long_tail':
        // Chemical injury: sharp spike with very long tail
        val = Math.exp(-0.6 * Math.pow((i - peakPeriod) / 1.5, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.92, i - peakPeriod);  // Slow exponential decay
        }
        val += 0.02;
        break;

      case 'very_long_tail':
        // Chemical long-term: decades of claims
        val = Math.exp(-0.4 * Math.pow((i - peakPeriod) / 3, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.97, i - peakPeriod);  // Very slow decay
        }
        val += 0.025;
        break;

      case 'low_early':
        // Nuclear injury short-term: low early, building concern
        val = 0.02 + 0.08 * Math.exp(-0.3 * Math.pow((i - peakPeriod) / 2, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.85, i - peakPeriod);
        }
        break;

      case 'delayed_rise':
        // Nuclear injury medium-term: gradual rise to delayed peak
        val = 0.03 * (1 - Math.exp(-0.15 * i)) +
              0.15 * Math.exp(-0.3 * Math.pow((i - peakPeriod) / 4, 2));
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.95, i - peakPeriod);
        }
        break;

      case 'latency_driven':
        // Nuclear injury long-term: very delayed peak (latency effects) - peak at ~month 84 (7 years)
        val = 0.01 + 0.015 * Math.log1p(i / 20);  // Slow initial rise
        val += 0.10 * Math.exp(-0.15 * Math.pow((i - peakPeriod) / 20, 2));  // Broader peak for month 84
        if (i > peakPeriod) {
          val += tailWeight * Math.pow(0.985, i - peakPeriod);  // Slow decay after peak
        }
        break;

      case 'rapid_rise':
        // Nuclear property short-term: rapid rise for evacuation
        val = 0.05 + 0.25 * (1 - Math.exp(-0.5 * i));
        val *= Math.exp(-0.15 * Math.pow((i - peakPeriod) / 3, 2));
        val += tailWeight * 0.1;
        break;

      case 'evacuation_plateau':
        // Nuclear property medium-term: plateau from ongoing evacuation/displacement
        if (i < peakPeriod) {
          val = 0.1 * (1 - Math.exp(-0.3 * i));
        } else {
          val = 0.1 * Math.exp(-0.02 * (i - peakPeriod));  // Very slow decay (plateau)
        }
        val += 0.03;
        break;

      case 'extended_plateau':
        // Extended plateau shape
        val = Math.exp(-0.3 * Math.pow((i - peakPeriod) / 4, 2)) + 0.04;
        break;

      case 'gradual_decay':
        // Gradual decay from early peak
        val = Math.exp(-0.4 * Math.pow((i - peakPeriod) / 2.5, 2)) + 0.02;
        break;

      case 'contamination_tail':
        // Chemical property long-term: contamination discovery tail
        val = Math.exp(-0.35 * Math.pow((i - peakPeriod) / 5, 2));
        if (i > peakPeriod + 12) {
          val += 0.15 * Math.exp(-0.5 * Math.pow((i - peakPeriod - 36) / 10, 2));  // Secondary discovery
        }
        val += 0.02;
        break;

      case 'stigma_tail':
        // Nuclear property long-term: stigma and policy-driven resurgence
        val = Math.exp(-0.25 * Math.pow((i - peakPeriod) / 8, 2));
        // Add periodic resurgences (policy decisions, new disclosures)
        if (i > 24) val += 0.08 * Math.exp(-0.5 * Math.pow((i - 48) / 6, 2));
        if (i > 72) val += 0.06 * Math.exp(-0.5 * Math.pow((i - 84) / 6, 2));
        val += 0.025;
        break;

      default:
        // Fallback to standard bell curve
        val = Math.exp(-0.5 * Math.pow((i - peakPeriod) / 2, 2)) + 0.015;
    }

    raw.push(Math.max(0.005, val));
  }

  // Normalise to sum to 1
  const sum = raw.reduce((a, b) => a + b, 0);
  return raw.map(v => v / sum);
}

// Get distribution for a specific incident type, claim type, and severity level.
// Distribution shape varies by incident type AND severity (e.g., minor fire has a sharp
// concentrated spike while catastrophic fire has a broader spike with heavier tail).
// numPeriods controls resolution; simulation always runs weekly.
function getClaimDistribution(incident, claimType, severity, dynNumPeriods, dynIsMonthly) {
  // Use dynamic period count if provided, else fall back to legacy
  let numPeriods, isMonthly;
  if (dynNumPeriods !== undefined) {
    numPeriods = dynNumPeriods;
    isMonthly = dynIsMonthly || false;
  } else {
    const hConfig = TIME_HORIZONS.long;
    numPeriods = 120;
    isMonthly = true;
  }

  // Get the pattern configuration keyed by severity level
  const patterns = CLAIM_PATTERNS[incident] || CLAIM_PATTERNS.fire;
  const claimTypePatterns = patterns[claimType] || patterns.injury;
  // Select pattern for this severity level, fall back to moderate
  const severityPattern = claimTypePatterns[severity] || claimTypePatterns.moderate || claimTypePatterns.minor;

  // Peak is always in weeks (simulation runs weekly)
  let peakPeriod = severityPattern.peakWeek || 4;

  // Clamp peak period to not exceed total periods
  peakPeriod = Math.min(peakPeriod, numPeriods - 1);

  return generateShapedDistribution(
    numPeriods,
    peakPeriod,
    severityPattern.shape,
    severityPattern.tailWeight
  );
}

// Aggregate weekly period data into monthly summaries for display
function aggregateToMonthly(weeklyPeriods) {
  const monthly = [];
  const totalMonths = Math.ceil(weeklyPeriods.length / 4.33);
  for (let m = 0; m < totalMonths; m++) {
    const startWeek = Math.round(m * 4.33);
    const endWeek = Math.min(Math.round((m + 1) * 4.33), weeklyPeriods.length);
    const weeksInMonth = weeklyPeriods.slice(startWeek, endWeek);
    if (weeksInMonth.length === 0) continue;

    const last = weeksInMonth[weeksInMonth.length - 1];
    monthly.push({
      period: m + 1,
      week: null,
      month: m + 1,
      newClaims: weeksInMonth.reduce((s, w) => s + w.newClaims, 0),
      newInjury: weeksInMonth.reduce((s, w) => s + (w.newInjury || 0), 0),
      newProperty: weeksInMonth.reduce((s, w) => s + (w.newProperty || 0), 0),
      cumulative: last.cumulative,
      cumulativeInjury: last.cumulativeInjury,
      cumulativeProperty: last.cumulativeProperty,
      effectiveCapacity: weeksInMonth.reduce((s, w) => s + w.effectiveCapacity, 0),
      processed: weeksInMonth.reduce((s, w) => s + w.processed, 0),
      backlog: last.backlog,
      surgeStaff: Math.round(weeksInMonth.reduce((s, w) => s + w.surgeStaff, 0) / weeksInMonth.length),
      utilisation: 0
    });
    const entry = monthly[monthly.length - 1];
    entry.utilisation = entry.effectiveCapacity > 0
      ? (entry.newClaims / entry.effectiveCapacity) * 100
      : 0;
  }
  return monthly;
}

// Prepare display periods from a scenario: clips to view window, aggregates to monthly
// if needed, and applies intelligent sampling for large period counts.
function getDisplayPeriods(scenario) {
  const s = scenario;
  const viewWeeklyPeriods = s.periods.slice(0, Math.min(s.viewWeeks, s.periods.length));
  const viewCumulative = viewWeeklyPeriods.length > 0 ? viewWeeklyPeriods[viewWeeklyPeriods.length - 1].cumulative : 0;
  const viewPeakClaims = Math.max(...viewWeeklyPeriods.map(w => w.newClaims), 0);
  const viewPeakWeek = viewWeeklyPeriods.findIndex(w => w.newClaims === viewPeakClaims) + 1;

  const useMonthlyDisplay = s.viewWeeks > 52;
  const periodLabel = useMonthlyDisplay ? 'Month' : 'Week';
  let displayPeriods = useMonthlyDisplay ? aggregateToMonthly(viewWeeklyPeriods) : viewWeeklyPeriods;

  // Intelligent sampling for very long display lists
  if (displayPeriods.length > 60) {
    const samplingRate = Math.ceil(displayPeriods.length / 40);
    displayPeriods = displayPeriods.filter((p, i) => i < 12 || i % samplingRate === 0);
  } else if (displayPeriods.length > 30) {
    displayPeriods = displayPeriods.filter((p, i) => i < 12 || i % 2 === 0);
  }
  if (displayPeriods.length > 48) {
    displayPeriods = displayPeriods.slice(0, 48);
  }

  const peakPeriodLabel = useMonthlyDisplay
    ? `Month ${Math.ceil(viewPeakWeek / 4.33)}`
    : `Week ${viewPeakWeek}`;

  return { displayPeriods, periodLabel, useMonthlyDisplay, viewCumulative, viewPeakClaims, viewPeakWeek, peakPeriodLabel };
}

// ===== PATTERN DESCRIPTIONS =====
// Severity-aware descriptions: shows how pattern shape changes with severity level
const PATTERN_DESCRIPTIONS = {
  fire: {
    injury: {
      base: 'Early spike (0-7 days) from burns/smoke inhalation; 6-24 month settlement',
      minor: 'Concentrated spike, fast resolution in weeks. Simple burns, minimal tail.',
      moderate: 'Early spike with moderate disability/PTSD tail extending 12-36 months.',
      major: 'Early spike + significant PTSD and complex injury tail (12-36 months). Specialist assessors needed.',
      catastrophic: 'Early spike followed by prolonged tail: severe burns, long-term disability, litigation extending years.'
    },
    property: {
      base: 'Immediate spike (0-30 days), re-scope waves as hidden damage discovered. BI exceeds PD by ~2.7x',
      minor: 'Single concentrated spike, simple property claims resolve in 3-6 months.',
      moderate: 'Spike + re-scope waves as hidden damage discovered. 6-18 month resolution.',
      major: 'Spike + re-scope waves + significant BI tail developing over 12-36 months.',
      catastrophic: 'Spike + multiple re-scope waves + major BI tail, rebuild delays, extended litigation.'
    },
    template: 'explosionFire',
    historicalRef: 'NFPA/Allianz data: Fire/explosion = #1 cause of corporate losses (21% by value)'
  },
  explosion: {
    injury: {
      base: 'Sharp immediate spike (0-7 days), high severity injuries. Burns, TBI, amputations',
      minor: 'Concentrated sharp spike, localised injuries resolve in weeks.',
      moderate: 'Sharp spike with specialist assessor demand. Burns, TBI require extended rehabilitation.',
      major: 'Sharp spike + complex injury rehabilitation tail. Amputations, longer rehab timelines.',
      catastrophic: 'Sharp spike + mass casualty tail: extended rehabilitation, litigation (BP Texas City: 7 years).'
    },
    property: {
      base: 'Instant sharp spike across blast radius (90%+ claims within 500m). BI develops over 12-36 months',
      minor: 'Concentrated blast radius damage, localised property claims.',
      moderate: 'Sharp spike across wider radius. BI claims beginning to develop.',
      major: 'Sharp spike + significant BI tail (9+ months, Buncefield pattern).',
      catastrophic: 'Sharp spike + massive BI tail (BP Texas City: $2.1B over 7 years). Forensic accounting required.'
    },
    template: 'explosionFire',
    historicalRef: 'BP Texas City: 15 fatalities, 4,000 claims, $2.1B settlements. Buncefield: 2,700 claims, £300M-1B'
  },
  chemical: {
    injury: {
      base: 'Bimodal: acute poisoning spike (25% in weeks 1-4), then long tail for chronic illness',
      minor: 'Acute poisoning spike with limited exposure. Mainly short-term respiratory effects.',
      moderate: 'Spike + long tail: respiratory illness developing at months 2-24. Discovery rule applies.',
      major: 'Spike + very long tail: chronic illness at years 2-10, cancers. Bhopal-scale development.',
      catastrophic: 'Spike + decades-long tail: 1M+ claims over 40 years (Bhopal). Generational effects, ongoing litigation.'
    },
    property: {
      base: 'Mid-fast spike for immediate damage, then resurgence as contamination discovered. Environmental: 5-40 years',
      minor: 'Moderate spike for immediate property damage. Limited contamination.',
      moderate: 'Moderate spike + decontamination phase over months.',
      major: 'Spike + extended plateau: environmental cleanup extends years.',
      catastrophic: 'Spike + contamination tail with secondary discovery peaks (months 12-36). Decades of remediation.'
    },
    template: 'toxicRelease',
    historicalRef: 'Bhopal (1984): 574,304 injury claims awarded, $470M settlement, avg compensation $300-500. Effects documented 40+ years later'
  },
  nuclear: {
    injury: {
      base: 'Only 10% of ultimate claims in first month. Peak at 3-15 years (thyroid cancers). UK 30-year limitation (2022 Act)',
      minor: 'Low early claims from precautionary evacuation. Health monitoring drives later claims.',
      moderate: 'Low initial spike + delayed rise. Health monitoring with some latent effects emerging.',
      major: 'Low initial + delayed rise to significant volume. Thyroid cancers emerge years 5-20.',
      catastrophic: 'Minimal early claims, latency-driven peak at years 5-20 (Fukushima/Chernobyl-scale). 30-year claims window.'
    },
    property: {
      base: 'Large early spike (evacuation), extended plateau from exclusion zones, stigma-driven resurgences',
      minor: 'Brief evacuation spike, quick return. Limited property impact.',
      moderate: 'Evacuation spike + extended displacement. Some BI claims developing.',
      major: 'Evacuation spike + exclusion zone plateau. Years of displacement (Fukushima: 164,000+).',
      catastrophic: 'Evacuation spike + permanent exclusion zones + stigma-driven resurgences decades later.'
    },
    template: 'nuclear',
    historicalRef: 'Fukushima: $70B+ compensation by 2021, avg family $900K. Three Mile Island: $82M documented, 14-year cleanup ($1B)'
  },
  fertiliser: {
    injury: {
      base: 'Sharp blast injury spike + chemical exposure tail (ammonia/nitrate compounds)',
      minor: 'Concentrated blast spike, minor chemical exposure. Fast resolution.',
      moderate: 'Sharp spike from burns + ammonia exposure extending timeline.',
      major: 'Sharp spike + significant chemical exposure tail. West Texas-scale injuries.',
      catastrophic: 'Sharp spike + prolonged chemical exposure tail: mass injury + ammonia/nitrate illness.'
    },
    property: {
      base: 'Blast damage spike + environmental contamination. Similar to explosion with chemical tail',
      minor: 'Concentrated blast radius, localised property damage.',
      moderate: 'Blast spike + BI developing. Some environmental contamination.',
      major: 'Blast spike + BI + environmental claims (West Texas: 150 buildings, FEMA $63.4M).',
      catastrophic: 'Blast spike + contamination tail: massive radius + chemical contamination ($230M+, West Texas).'
    },
    template: 'explosionFire',
    historicalRef: 'West, Texas (2013): 15 fatalities, 260 injured, 150 buildings. $230M losses vs $1M coverage. FEMA $63.4M to school district.'
  }
};

// Get applicable claim categories for an incident type
function getApplicableClaimCategories(incident) {
  return Object.entries(CLAIM_CATEGORIES)
    .filter(([key, cat]) => cat.applicableIncidents.includes(incident))
    .map(([key, cat]) => ({ key, ...cat }));
}

// Get reserve development factor for time horizon
function getReserveDevelopmentFactor(timeHorizon, incident) {
  const factors = config.reserveDevelopmentFactors || DEFAULT_CONFIG.reserveDevelopmentFactors;

  // Special case for chemical and nuclear long-term
  if (timeHorizon === 'long') {
    if (incident === 'chemical') {
      return factors.chemicalLong || factors.long;
    } else if (incident === 'nuclear') {
      return factors.nuclearLong || factors.long;
    }
  }

  return factors[timeHorizon] || factors.short;
}

// Apply blast radius concentration model for explosion/fertiliser incidents
function applyBlastRadiusConcentration(totalClaims, site, useConcentrated) {
  if (!useConcentrated) {
    return { total: totalClaims, byRadius: null };
  }

  const concentration = config.blastRadiusConcentration || DEFAULT_CONFIG.blastRadiusConcentration;

  // Estimate population distribution by radius (simplified)
  const popDistribution = {
    '0-500m': 0.10,
    '500m-1km': 0.20,
    '1-3km': 0.40,
    '3-5km': 0.30
  };

  const byRadius = {};
  let weightedTotal = 0;

  for (const radius in concentration) {
    const popPct = popDistribution[radius] || 0;
    const claimDensity = concentration[radius];
    byRadius[radius] = {
      population: Math.round(site.population * popPct),
      claimDensity: Math.round(claimDensity * 100) + '%',
      estimatedClaims: Math.round(totalClaims * popPct * claimDensity)
    };
    weightedTotal += byRadius[radius].estimatedClaims;
  }

  return { total: weightedTotal, byRadius };
}

// Get average claim value for underinsurance calculation
// Average claim values by incident type and severity (in £)
// Sources cited for transparency and validation
const AVERAGE_CLAIM_VALUES = {
  fire: {
    values: { minor: 15000, moderate: 45000, major: 120000, catastrophic: 350000 },
    sources: [
      'Allianz Global Claims Review 2023: Average industrial fire claim £45K-£350K',
      'ABI UK Commercial Property Claims Data 2022'
    ]
  },
  explosion: {
    values: { minor: 25000, moderate: 75000, major: 200000, catastrophic: 500000 },
    sources: [
      'BP Texas City 2005: $2.1B total / 4,000 claims ≈ $525K avg',
      'Buncefield 2005: £1B / 2,700 claims ≈ £370K avg'
    ]
  },
  chemical: {
    values: { minor: 8000, moderate: 25000, major: 80000, catastrophic: 250000 },
    sources: [
      'Bhopal 1984: $470M / 574,304 injury claims ≈ $818 avg (historically low)',
      'Adjusted for UK jurisdiction and inflation to £8K-£250K range'
    ]
  },
  nuclear: {
    values: { minor: 50000, moderate: 150000, major: 400000, catastrophic: 900000 },
    sources: [
      'Fukushima 2011: ¥9.7T / 164,000 evacuees ≈ $590K/family avg',
      'Three Mile Island 1979: $82M documented compensation',
      'UK Nuclear Installations Act 2022: €700M-1.2B operator liability'
    ]
  },
  fertiliser: {
    values: { minor: 20000, moderate: 60000, major: 180000, catastrophic: 450000 },
    sources: [
      'West, Texas 2013: $230M losses / 150 buildings + 260 injuries',
      'FEMA awards: $63.4M to school district alone'
    ]
  }
};

function getAverageClaimValue(incident, severity) {
  return AVERAGE_CLAIM_VALUES[incident]?.values?.[severity] || 50000;
}

function getClaimValueSources(incident) {
  return AVERAGE_CLAIM_VALUES[incident]?.sources || [];
}

// Get claim distribution template
function getClaimDistributionTemplate(incident) {
  const pattern = PATTERN_DESCRIPTIONS[incident];
  if (pattern && pattern.template) {
    return CLAIM_DISTRIBUTION_TEMPLATES[pattern.template];
  }
  return CLAIM_DISTRIBUTION_TEMPLATES.explosionFire;
}

function updatePatternDescription() {
  const incident = document.getElementById('incidentSelect').value;
  const claimType = document.getElementById('claimTypeSelect').value;
  const timeHorizon = document.getElementById('timeHorizonSelect').value;
  const severity = document.getElementById('severitySelect').value;

  let description = '';
  const patterns = PATTERN_DESCRIPTIONS[incident] || PATTERN_DESCRIPTIONS.fire;

  // Helper to get severity-specific description for a claim type
  function getDesc(typePatterns) {
    if (typeof typePatterns === 'string') return typePatterns;  // Legacy fallback
    return typePatterns[severity] || typePatterns.base || typePatterns.moderate || '';
  }

  if (claimType === 'both') {
    description = `Injury: ${getDesc(patterns.injury)}  Property: ${getDesc(patterns.property)}`;
  } else if (claimType === 'injury') {
    description = getDesc(patterns.injury);
  } else {
    description = getDesc(patterns.property);
  }

  // Add full lifecycle context (distribution covers the complete lifecycle)
  const fullConfig = resolveHorizonConfig(incident, severity, 'long');
  const viewConfig = resolveHorizonConfig(incident, severity, timeHorizon);
  description += ` | Viewing ${viewConfig.label} of ${fullConfig.label} full lifecycle`;

  const descEl = document.getElementById('patternDescription');
  if (descEl) descEl.textContent = description;

  // Update historical reference
  const histRefEl = document.getElementById('historicalReference');
  if (histRefEl && patterns.historicalRef) {
    histRefEl.textContent = patterns.historicalRef;
    histRefEl.parentElement.style.display = '';
  } else if (histRefEl) {
    histRefEl.parentElement.style.display = 'none';
  }
}

// Update incident-specific options (e.g., show blast radius for explosions)
function updateIncidentOptions() {
  const incident = document.getElementById('incidentSelect').value;
  const blastGroup = document.getElementById('blastRadiusGroup');

  if (incident === 'explosion' || incident === 'fertiliser') {
    blastGroup.style.display = '';
  } else {
    blastGroup.style.display = 'none';
  }
}

// ===== SURGE RESOURCE MANAGEMENT =====
let surgeEntries = []; // { startWeek, extraStaff }

function addSurgeEntry() {
  surgeEntries.push({ startWeek: 3, extraStaff: 4 });
  renderSurgeList();
  runScenario();
}

function removeSurgeEntry(idx) {
  surgeEntries.splice(idx, 1);
  renderSurgeList();
  runScenario();
}

function updateSurgeEntry(idx, field, value) {
  surgeEntries[idx][field] = parseInt(value) || 0;
  runScenario();
}

function renderSurgeList() {
  const container = document.getElementById('surgeList');
  container.innerHTML = '';
  surgeEntries.forEach((entry, idx) => {
    const div = document.createElement('div');
    div.className = 'surge-entry';
    div.innerHTML = `
      <span style="color:#94a3b8;white-space:nowrap">+</span>
      <input type="number" value="${entry.extraStaff}" min="1" max="100" style="width:50px"
        onchange="updateSurgeEntry(${idx},'extraStaff',this.value)">
      <span style="color:#94a3b8;white-space:nowrap">staff from W</span>
      <select onchange="updateSurgeEntry(${idx},'startWeek',this.value)">
        ${[1,2,3,4,5,6,7,8,9,10,11,12].map(w => `<option value="${w}" ${w === entry.startWeek ? 'selected' : ''}>W${w}</option>`).join('')}
      </select>
      <button class="btn btn-danger" onclick="removeSurgeEntry(${idx})">×</button>
    `;
    container.appendChild(div);
  });
}

let lastScenario = null;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 5: SCENARIO CALCULATION & RESULTS
// Core simulation logic, results display, recommendations
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ===== SCENARIO CALCULATION =====
function runScenario() {
  const siteId = document.getElementById('siteSelect').value;
  const incident = document.getElementById('incidentSelect').value;
  const severity = document.getElementById('severitySelect').value;
  const claimType = document.getElementById('claimTypeSelect').value;
  const timeHorizon = document.getElementById('timeHorizonSelect').value;

  // Update pattern description
  updatePatternDescription();

  const site = config.sites.find(s => s.id === siteId);
  if (!site) return;

  // Validate site data (Issue 1: edge case validation)
  const population = sanitizeIntInput(site.population, 0, 10000000, 10000);
  const staffOnSite = sanitizeIntInput(site.staffOnSite, 0, 100000, 500);
  if (population <= 0 && staffOnSite <= 0) {
    showToast('Site has zero population and staff. Please update site configuration.', 'warning');
    return;
  }

  const totalAffected = population + staffOnSite;
  const claimRate = config.severityRates[severity];
  const multiplier = config.incidentMultipliers[incident] || 1.0;
  // Apply claim multiplier per person (accounts for multiple claims per affected individual)
  const claimMultPerPerson = config.claimMultiplierPerPerson?.[incident] || DEFAULT_CONFIG.claimMultiplierPerPerson?.[incident] || 1.0;
  const baseTotalClaims = Math.round(totalAffected * claimRate * multiplier * claimMultPerPerson);

  // Get claim type splits
  const splits = config.claimTypeSplits?.[incident] || DEFAULT_CONFIG.claimTypeSplits[incident] || { injury: 0.5, property: 0.5 };

  // Calculate claims by type
  let injuryClaims = 0, propertyClaims = 0, totalClaims = 0;
  if (claimType === 'both') {
    injuryClaims = Math.round(baseTotalClaims * splits.injury);
    propertyClaims = Math.round(baseTotalClaims * splits.property);
    totalClaims = injuryClaims + propertyClaims;
  } else if (claimType === 'injury') {
    injuryClaims = baseTotalClaims;
    totalClaims = injuryClaims;
  } else {
    propertyClaims = baseTotalClaims;
    totalClaims = propertyClaims;
  }

  // Apply blast radius concentration model for explosions/fertiliser
  const blastRadiusModel = document.getElementById('blastRadiusSelect')?.value || 'uniform';
  const useBlastConcentration = (incident === 'explosion' || incident === 'fertiliser') && blastRadiusModel === 'concentrated';
  const blastResult = applyBlastRadiusConcentration(totalClaims, site, useBlastConcentration);
  const blastRadiusByZone = blastResult.byRadius;

  // If using concentrated model, adjust total claims based on blast radius concentration
  if (useBlastConcentration && blastResult.total > 0) {
    const adjustmentFactor = blastResult.total / totalClaims;
    totalClaims = blastResult.total;
    injuryClaims = Math.round(injuryClaims * adjustmentFactor);
    propertyClaims = Math.round(propertyClaims * adjustmentFactor);
  }

  // ===== FULL LIFECYCLE SIMULATION =====
  // Distribution shape varies by incident type AND severity level.
  // Always simulate the FULL lifecycle (long horizon) in weekly periods.
  // The dropdown controls which portion of the timeline is displayed.

  // Full lifecycle config (always long-term, always weekly)
  const fullHorizonConfig = resolveHorizonConfig(incident, severity, 'long');
  const fullWeeks = fullHorizonConfig.weeks;
  const numPeriods = fullWeeks;  // Always simulate in weekly periods
  const isLongTerm = false;     // Weekly simulation (display may aggregate to months)

  // View config for display clipping
  const viewHorizonConfig = resolveHorizonConfig(incident, severity, timeHorizon);
  const viewWeeks = viewHorizonConfig.weeks;

  // Get distributions based on incident type AND severity level
  const injuryDist = injuryClaims > 0 ? getClaimDistribution(incident, 'injury', severity, numPeriods, false) : [];
  const propertyDist = propertyClaims > 0 ? getClaimDistribution(incident, 'property', severity, numPeriods, false) : [];

  // Calculate claims per period
  const injuryPerPeriod = injuryDist.map(d => Math.round(injuryClaims * d));
  const propertyPerPeriod = propertyDist.map(d => Math.round(propertyClaims * d));

  // Combined claims per period
  const periodicClaims = [];
  for (let i = 0; i < numPeriods; i++) {
    periodicClaims.push({
      injury: injuryPerPeriod[i] || 0,
      property: propertyPerPeriod[i] || 0,
      total: (injuryPerPeriod[i] || 0) + (propertyPerPeriod[i] || 0)
    });
  }

  const baseWeeklyCapacity = getWeeklyCapacity();
  const weightedDaysPerClaim = getWeightedDaysPerClaim();
  const baseClaimsPerStaff = weightedDaysPerClaim > 0 ? config.organisation.workDaysPerWeek / weightedDaysPerClaim : config.organisation.workDaysPerWeek;

  // Capacity always weekly (simulation is always in weekly periods)
  const periodCapacityMultiplier = 1;
  const basePeriodCapacity = baseWeeklyCapacity;

  const targetWeeks = parseInt(document.getElementById('targetWeeksInput').value) || 12;
  const targetPeriods = targetWeeks;

  // Build period breakdown with backlog
  const periods = [];
  let cumulative = 0, cumulativeInjury = 0, cumulativeProperty = 0;
  let totalProcessed = 0;
  let backlog = 0;
  let peakPeriod = 0;
  let peakClaims = 0;
  let periodsToClear = 0;

  const maxSimPeriods = numPeriods;

  for (let i = 0; i < Math.min(numPeriods, maxSimPeriods); i++) {
    const periodNum = i + 1;

    // Calculate surge staff active this week
    let surgeStaff = 0;
    surgeEntries.forEach(entry => {
      if (periodNum >= entry.startWeek) surgeStaff += entry.extraStaff;
    });
    const surgeCapacity = Math.round(surgeStaff * baseClaimsPerStaff * periodCapacityMultiplier);
    const effectiveCapacity = basePeriodCapacity + surgeCapacity;

    const newClaims = periodicClaims[i]?.total || 0;
    const newInjury = periodicClaims[i]?.injury || 0;
    const newProperty = periodicClaims[i]?.property || 0;

    cumulative += newClaims;
    cumulativeInjury += newInjury;
    cumulativeProperty += newProperty;

    const available = newClaims + backlog;
    const processed = Math.min(available, effectiveCapacity);
    totalProcessed += processed;
    backlog = available - processed;

    if (newClaims > peakClaims) { peakClaims = newClaims; peakPeriod = periodNum; }

    periods.push({
      period: periodNum,
      week: periodNum,
      month: Math.ceil(periodNum / 4.33),
      newClaims,
      newInjury,
      newProperty,
      cumulative,
      cumulativeInjury,
      cumulativeProperty,
      processed,
      backlog,
      effectiveCapacity,
      surgeStaff,
      utilisation: effectiveCapacity > 0 ? ((newClaims + (i > 0 ? periods[i-1].backlog : 0)) / effectiveCapacity) * 100 : 0
    });

  }

  // Find when all claims are actually cleared (backlog reaches 0 and stays 0)
  // Look backwards to find the last period with backlog > 0
  let lastBacklogPeriod = 0;
  for (let i = 0; i < periods.length; i++) {
    if (periods[i].backlog > 0) {
      lastBacklogPeriod = periods[i].period;
    }
  }

  if (lastBacklogPeriod > 0) {
    // Backlog existed at some point - clearance is when it finally went to 0
    // Check if it actually cleared within our simulation
    const nextPeriodIndex = lastBacklogPeriod; // periods array is 0-indexed
    if (nextPeriodIndex < periods.length && periods[nextPeriodIndex].backlog === 0) {
      periodsToClear = lastBacklogPeriod + 1;
    } else {
      // Backlog never fully cleared within simulation
      periodsToClear = -1;
    }
  } else if (cumulative > 0) {
    // No backlog ever built up - claims processed as they arrived
    // Time to clear = last period where claims arrived
    for (let i = periods.length - 1; i >= 0; i--) {
      if (periods[i].newClaims > 0) {
        periodsToClear = periods[i].period;
        break;
      }
    }
  }

  // Periods are always weeks
  const weeksToClear = periodsToClear;
  const canMeetTarget = weeksToClear > 0 && weeksToClear <= targetWeeks;

  // Calculate resource needs
  const maxBacklog = Math.max(...periods.map(w => w.backlog));
  const overCapacityPeriods = periods.filter(w => w.newClaims > w.effectiveCapacity).length;
  const claimsPerStaffPerWeek = baseClaimsPerStaff;
  const staffNeededAtPeak = Math.ceil(peakClaims / claimsPerStaffPerWeek);
  const additionalStaff = Math.max(0, staffNeededAtPeak - config.organisation.staffCount);

  // Calculate ultimate claims estimates with development factors
  const devFactor = getReserveDevelopmentFactor(timeHorizon, incident);
  const ultimateClaimsLow = Math.round(totalClaims * devFactor.min);
  const ultimateClaimsHigh = Math.round(totalClaims * devFactor.max);
  const ultimateClaimsMid = Math.round(totalClaims * devFactor.midpoint);

  // Underinsurance check
  const coverageLimit = parseFloat(document.getElementById('coverageLimitInput')?.value) || null;
  let underinsuranceRatio = null;
  let isUnderinsured = false;
  const avgClaimValue = getAverageClaimValue(incident, severity);
  const estimatedTotalValue = ultimateClaimsMid * avgClaimValue;

  if (coverageLimit && coverageLimit > 0) {
    const coverageLimitValue = coverageLimit * 1000000; // Convert from £M to £
    underinsuranceRatio = estimatedTotalValue / coverageLimitValue;
    isUnderinsured = underinsuranceRatio > 1;
  }

  // Store last scenario for report generation
  lastScenario = {
    site, incident, severity, claimType, timeHorizon, totalClaims, injuryClaims, propertyClaims,
    periods, peakPeriod, peakClaims, weeklyCapacity: baseWeeklyCapacity, periodCapacity: basePeriodCapacity,
    maxBacklog, overCapacityPeriods, additionalStaff, staffNeededAtPeak, claimsPerStaffPerWeek,
    surgeEntries: JSON.parse(JSON.stringify(surgeEntries)), weightedDaysPerClaim,
    targetWeeks, targetPeriods, weeksToClear, periodsToClear, canMeetTarget, isLongTerm, splits,
    claimComplexity: JSON.parse(JSON.stringify(config.claimComplexity || DEFAULT_CONFIG.claimComplexity)),
    // Ultimate claims estimates
    devFactor, ultimateClaimsLow, ultimateClaimsHigh, ultimateClaimsMid,
    // Blast radius concentration data
    useBlastConcentration, blastRadiusByZone,
    // Underinsurance data
    coverageLimit, underinsuranceRatio, isUnderinsured, avgClaimValue, estimatedTotalValue,
    // Severity-calibrated horizon configs
    fullHorizonConfig,    // Full lifecycle (always 'long')
    viewHorizonConfig,    // Selected view window
    viewWeeks,            // Weeks to show in current view
    horizonConfig: viewHorizonConfig  // Alias for backward compat
  };

  // Display results
  showResults(lastScenario);
}

function showResults(scenario) {
  const s = scenario;

  document.getElementById('welcomeArea').style.display = 'none';
  document.getElementById('resultsArea').style.display = '';

  const incidentLabels = { fire: 'Fire', explosion: 'Explosion', chemical: 'Chemical (Toxic Release)', nuclear: 'Nuclear (Radiological)', fertiliser: 'Fertiliser (Ammonium Nitrate)' };
  const severityLabels = { minor: 'Minor', moderate: 'Moderate', major: 'Major', catastrophic: 'Catastrophic' };
  const claimTypeLabels = { both: 'All Claims', injury: 'Injury Claims', property: 'Property Claims' };

  // Dynamic horizon labels from severity-calibrated config
  const horizonNames = { short: 'Short Term', medium: 'Medium Term', long: 'Long Term' };
  const viewLabel = `${horizonNames[s.timeHorizon]} (0-${s.viewHorizonConfig.label})`;
  const fullLabel = s.fullHorizonConfig.label;

  document.getElementById('mainTitle').textContent = sanitizeHTML(s.site.name) + ' - Scenario Analysis';
  document.getElementById('mainSub').textContent =
    incidentLabels[s.incident] + ' | ' + severityLabels[s.severity] + ' | ' + claimTypeLabels[s.claimType] + ' | ' + viewLabel;

  // ===== VIEW WINDOW CLIPPING =====
  const { displayPeriods, periodLabel, useMonthlyDisplay, viewCumulative, viewPeakClaims, viewPeakWeek, peakPeriodLabel } = getDisplayPeriods(s);

  // Metrics: full lifecycle values with view context
  const timeToClearLabel = s.weeksToClear === -1
    ? (fullLabel + '+')
    : (s.weeksToClear + ' weeks');
  const targetLabel = s.targetWeeks + ' Weeks';
  const showClaimBreakdown = s.claimType === 'both' && (s.injuryClaims > 0 || s.propertyClaims > 0);

  let metricsHTML = `
    <div class="metric-card">
      <div class="metric-value metric-blue">${s.totalClaims.toLocaleString()}</div>
      <div class="metric-label">Total Estimated Claims</div>
      <div style="font-size:10px;color:#64748b;margin-top:2px">${viewCumulative.toLocaleString()} in this view (${Math.round(viewCumulative / s.totalClaims * 100)}%)</div>
    </div>`;

  if (showClaimBreakdown) {
    metricsHTML += `
    <div class="metric-card">
      <div class="metric-value" style="color:#f97316">${s.injuryClaims.toLocaleString()}</div>
      <div class="metric-label">Injury Claims (${Math.round(s.splits.injury * 100)}%)</div>
    </div>
    <div class="metric-card">
      <div class="metric-value" style="color:#8b5cf6">${s.propertyClaims.toLocaleString()}</div>
      <div class="metric-label">Property Claims (${Math.round(s.splits.property * 100)}%)</div>
    </div>`;
  }

  metricsHTML += `
    <div class="metric-card">
      <div class="metric-value metric-yellow">${peakPeriodLabel}</div>
      <div class="metric-label">Peak ${periodLabel} (${viewPeakClaims} claims)</div>
    </div>
    <div class="metric-card">
      <div class="metric-value ${s.canMeetTarget ? 'metric-green' : 'metric-red'}">${s.canMeetTarget ? 'Yes' : 'No'}</div>
      <div class="metric-label">Cleared Within ${targetLabel}?</div>
    </div>
    <div class="metric-card">
      <div class="metric-value ${s.canMeetTarget ? 'metric-green' : 'metric-red'}">${timeToClearLabel}</div>
      <div class="metric-label">Time to Clear All Claims</div>
    </div>
    <div class="metric-card">
      <div class="metric-value ${s.additionalStaff === 0 ? 'metric-green' : 'metric-red'}">+${s.additionalStaff}</div>
      <div class="metric-label">Additional Staff Required</div>
    </div>
    <div class="metric-card">
      <div class="metric-value metric-yellow">${s.maxBacklog.toLocaleString()}</div>
      <div class="metric-label">Peak Backlog</div>
    </div>
    <div class="metric-card">
      <div class="metric-value ${s.overCapacityPeriods === 0 ? 'metric-green' : 'metric-red'}">${s.overCapacityPeriods}</div>
      <div class="metric-label">Weeks Over Capacity</div>
    </div>
    <div class="metric-card">
      <div class="metric-value" style="color:#a855f7">${s.ultimateClaimsMid.toLocaleString()}</div>
      <div class="metric-label">Ultimate Claims (${s.devFactor.midpoint}x)</div>
      <div style="font-size:10px;color:#64748b;margin-top:2px">Range: ${s.ultimateClaimsLow.toLocaleString()} - ${s.ultimateClaimsHigh.toLocaleString()}</div>
    </div>
    <div class="metric-card">
      <div class="metric-value" style="color:#14b8a6">£${(s.estimatedTotalValue / 1000000).toFixed(1)}M</div>
      <div class="metric-label">Estimated Total Value</div>
      <div style="font-size:10px;color:#64748b;margin-top:2px">${s.ultimateClaimsMid.toLocaleString()} claims × £${s.avgClaimValue.toLocaleString()} avg</div>
    </div>
  `;
  document.getElementById('metricsGrid').innerHTML = metricsHTML;

  // Period table
  const tbody = document.getElementById('weeklyBody');
  tbody.innerHTML = '';
  const hasSurge = displayPeriods.some(w => w.surgeStaff > 0);
  const hasClaimBreakdown = s.claimType === 'both';

  // Update table header
  const thead = document.querySelector('#weeklyTable thead tr');
  let headerHTML = `<th>${periodLabel}</th>`;
  if (hasClaimBreakdown) {
    headerHTML += `<th>Injury</th><th>Property</th>`;
  }
  headerHTML += `<th>New Claims</th><th>Cumulative</th><th>Capacity</th><th>Processed</th><th>Backlog</th>`;
  if (hasSurge) headerHTML += `<th>Surge Staff</th>`;
  headerHTML += `<th>Status</th>`;
  thead.innerHTML = headerHTML;

  displayPeriods.forEach(w => {
    const statusClass = w.backlog === 0 ? 'status-ok' : (w.backlog < w.effectiveCapacity ? 'status-warn' : 'status-over');
    const statusText = w.backlog === 0 ? 'On Track' : (w.backlog < w.effectiveCapacity ? 'Building Backlog' : 'Critical Backlog');
    const periodDisplay = useMonthlyDisplay ? `Month ${w.month}` : `Week ${w.week || w.period}`;

    const tr = document.createElement('tr');
    let rowHTML = `<td>${periodDisplay}</td>`;
    if (hasClaimBreakdown) {
      rowHTML += `<td style="color:#f97316">${w.newInjury.toLocaleString()}</td>`;
      rowHTML += `<td style="color:#8b5cf6">${w.newProperty.toLocaleString()}</td>`;
    }
    rowHTML += `
      <td>${w.newClaims.toLocaleString()}</td>
      <td>${w.cumulative.toLocaleString()}</td>
      <td>${w.effectiveCapacity.toLocaleString()}${w.surgeStaff > 0 ? ' <span style="color:#8b5cf6;font-size:11px">(+' + (w.effectiveCapacity - s.periodCapacity) + ')</span>' : ''}</td>
      <td>${w.processed.toLocaleString()}</td>
      <td>${w.backlog.toLocaleString()}</td>
      ${hasSurge ? '<td>' + (w.surgeStaff > 0 ? '+' + w.surgeStaff : '-') + '</td>' : ''}
      <td class="${statusClass}">${statusText}</td>
    `;
    tr.innerHTML = rowHTML;
    tbody.appendChild(tr);
  });

  // Resource requirements
  const capacityLabel = 'Claims/week';
  const resHTML = `
    <div class="admin-grid" style="gap:16px">
      <div>
        <h4 style="margin-bottom:8px;font-size:14px">Current Capacity</h4>
        <p style="font-size:13px;color:#94a3b8">
          Staff: <strong style="color:#e2e8f0">${config.organisation.staffCount}</strong><br>
          ${capacityLabel}: <strong style="color:#e2e8f0">${s.periodCapacity}</strong><br>
          Claims/staff/week: <strong style="color:#e2e8f0">${s.claimsPerStaffPerWeek.toFixed(1)}</strong><br>
          Avg days per claim: <strong style="color:#e2e8f0">${s.weightedDaysPerClaim.toFixed(1)}</strong> (weighted)
        </p>
      </div>
      <div>
        <h4 style="margin-bottom:8px;font-size:14px">Required at Peak</h4>
        <p style="font-size:13px;color:#94a3b8">
          Staff needed: <strong style="color:#e2e8f0">${s.staffNeededAtPeak}</strong><br>
          Additional staff: <strong style="color:${s.additionalStaff > 0 ? '#ef4444' : '#22c55e'}">${s.additionalStaff > 0 ? '+' + s.additionalStaff : 'None'}</strong><br>
          Peak week claims: <strong style="color:#e2e8f0">${s.peakClaims}</strong><br>
          Weeks over capacity: <strong style="color:${s.overCapacityPeriods > 0 ? '#ef4444' : '#22c55e'}">${s.overCapacityPeriods}</strong>
        </p>
      </div>
      <div>
        <h4 style="margin-bottom:8px;font-size:14px">Target Assessment</h4>
        <p style="font-size:13px;color:#94a3b8">
          Target: <strong style="color:#e2e8f0">${targetLabel}</strong><br>
          Estimated clearance: <strong style="color:${s.canMeetTarget ? '#22c55e' : '#ef4444'}">${timeToClearLabel}</strong><br>
          Status: <strong style="color:${s.canMeetTarget ? '#22c55e' : '#ef4444'}">${s.canMeetTarget ? 'On Target' : 'Exceeds Target'}</strong>
        </p>
      </div>
    </div>
    <div style="margin-top:16px">
      <h4 style="margin-bottom:8px;font-size:14px">Capacity vs Demand at Peak</h4>
      <div class="progress-bar" style="height:20px;border-radius:6px">
        <div class="progress-fill" style="width:${Math.min(100, (s.periodCapacity / s.peakClaims) * 100)}%;background:${s.periodCapacity >= s.peakClaims ? '#22c55e' : '#ef4444'};border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:700">
          ${Math.round((s.periodCapacity / s.peakClaims) * 100)}%
        </div>
      </div>
      <p style="font-size:11px;color:#64748b;margin-top:4px">Current capacity covers ${Math.round((s.periodCapacity / s.peakClaims) * 100)}% of peak demand</p>
    </div>
  `;
  document.getElementById('resourceContent').innerHTML = resHTML;

  // Populate claim value assumptions
  const claimValues = AVERAGE_CLAIM_VALUES[s.incident];
  const claimSources = getClaimValueSources(s.incident);
  const incidentLabelsForValues = { fire: 'Fire', explosion: 'Explosion', chemical: 'Chemical', nuclear: 'Nuclear', fertiliser: 'Fertiliser' };

  let claimValueHTML = `
    <div style="margin-bottom:16px">
      <h4 style="font-size:13px;font-weight:700;color:#14b8a6;margin-bottom:8px">Average Claim Values - ${incidentLabelsForValues[s.incident] || s.incident}</h4>
      <table class="capacity-table" style="font-size:12px">
        <thead><tr><th>Severity</th><th>Avg Claim Value</th><th>Used in Calculation</th></tr></thead>
        <tbody>
          <tr><td>Minor</td><td>£${(claimValues?.values?.minor || 0).toLocaleString()}</td><td>${s.severity === 'minor' ? '<span style="color:#22c55e">✓ Yes</span>' : '-'}</td></tr>
          <tr><td>Moderate</td><td>£${(claimValues?.values?.moderate || 0).toLocaleString()}</td><td>${s.severity === 'moderate' ? '<span style="color:#22c55e">✓ Yes</span>' : '-'}</td></tr>
          <tr><td>Major</td><td>£${(claimValues?.values?.major || 0).toLocaleString()}</td><td>${s.severity === 'major' ? '<span style="color:#22c55e">✓ Yes</span>' : '-'}</td></tr>
          <tr><td>Catastrophic</td><td>£${(claimValues?.values?.catastrophic || 0).toLocaleString()}</td><td>${s.severity === 'catastrophic' ? '<span style="color:#22c55e">✓ Yes</span>' : '-'}</td></tr>
        </tbody>
      </table>
    </div>
    <div style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;margin-bottom:12px">
      <div style="font-size:11px;font-weight:600;color:#94a3b8;text-transform:uppercase;margin-bottom:6px">Calculation Used</div>
      <div style="font-size:13px;color:#e2e8f0">
        <strong style="color:#14b8a6">£${(s.estimatedTotalValue / 1000000).toFixed(1)}M</strong> =
        ${s.ultimateClaimsMid.toLocaleString()} ultimate claims × £${s.avgClaimValue.toLocaleString()} avg value
      </div>
    </div>
    <div style="background:#1a1a2e;border:1px solid #3b82f6;border-radius:8px;padding:12px">
      <div style="font-size:11px;font-weight:600;color:#60a5fa;text-transform:uppercase;margin-bottom:6px">Sources</div>
      <ul style="font-size:11px;color:#94a3b8;margin:0;padding-left:16px;line-height:1.6">
        ${claimSources.map(src => `<li>${src}</li>`).join('')}
      </ul>
    </div>
  `;
  document.getElementById('claimValueContent').innerHTML = claimValueHTML;

  // Populate claim distribution template
  const distTemplate = getClaimDistributionTemplate(s.incident);
  if (distTemplate) {
    let distHTML = `<p style="font-size:13px;color:#94a3b8;margin-bottom:12px"><strong style="color:#e2e8f0">${distTemplate.name}</strong> - Bimodal distribution pattern based on historical incident data</p>`;
    distHTML += `<div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:12px">`;
    distTemplate.distribution.forEach((phase, idx) => {
      const colors = ['#22c55e', '#3b82f6', '#eab308', '#ef4444'];
      const percentWidth = phase.percent;
      distHTML += `
        <div style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px">
          <div style="font-size:12px;font-weight:700;color:${colors[idx]};margin-bottom:4px">${phase.period}</div>
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
            <div style="flex:1;height:8px;background:#334155;border-radius:4px;overflow:hidden">
              <div style="width:${percentWidth}%;height:100%;background:${colors[idx]};border-radius:4px"></div>
            </div>
            <span style="font-size:14px;font-weight:700;color:${colors[idx]}">${phase.percent}%</span>
          </div>
          <div style="font-size:11px;color:#94a3b8">${phase.types}</div>
        </div>`;
    });
    distHTML += `</div>`;
    distHTML += `<p style="font-size:11px;color:#64748b;margin-top:12px;font-style:italic">Note: Claim development follows bimodal distribution - immediate spike of property/acute injury claims, followed by long tail of latent illness claims (30+ years for chemical/nuclear).</p>`;
    document.getElementById('distributionTemplateContent').innerHTML = distHTML;
  }

  // Populate UK Legal Framework (show for nuclear incidents)
  const legalCard = document.getElementById('legalFrameworkCard');
  if (s.incident === 'nuclear') {
    legalCard.style.display = '';
    const nuc = UK_LEGAL_FRAMEWORK.nuclearLimitations;
    let legalHTML = `
      <div style="margin-bottom:16px">
        <h4 style="font-size:13px;font-weight:700;color:#ef4444;margin-bottom:8px">UK Nuclear Installations Act 1965 (as amended 2022)</h4>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px">
          <div style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px">
            <div style="font-size:11px;color:#94a3b8;text-transform:uppercase;margin-bottom:6px">Pre-2022</div>
            <div style="font-size:12px;color:#e2e8f0">
              <div>Operator Liability: <strong>${nuc.pre2022.operatorLiabilityCap}</strong></div>
              <div>Personal Injury Limit: <strong>${nuc.pre2022.personalInjury.years} years</strong></div>
              <div>Property Damage Limit: <strong>${nuc.pre2022.propertyDamage.years} years</strong></div>
              <div>Environmental: <strong style="color:#ef4444">Not covered</strong></div>
            </div>
          </div>
          <div style="background:#0f172a;border:1px solid #22c55e;border-radius:8px;padding:12px">
            <div style="font-size:11px;color:#22c55e;text-transform:uppercase;margin-bottom:6px">Post-2022 (Current)</div>
            <div style="font-size:12px;color:#e2e8f0">
              <div>Operator Liability: <strong>${nuc.post2022.operatorLiabilityCap}</strong></div>
              <div>Personal Injury Limit: <strong style="color:#22c55e">${nuc.post2022.personalInjury.years} years</strong> <span style="font-size:10px;color:#94a3b8">(extended)</span></div>
              <div>Property Damage Limit: <strong>${nuc.post2022.propertyDamage.years} years</strong></div>
              <div>Environmental: <strong style="color:#22c55e">Now covered</strong></div>
            </div>
          </div>
        </div>
      </div>`;
    legalHTML += `
      <div style="background:#1a1a2e;border:1px solid #3b82f6;border-radius:8px;padding:12px;font-size:12px">
        <strong style="color:#60a5fa">Discovery Rule for Latent Injuries:</strong>
        <span style="color:#94a3b8">${UK_LEGAL_FRAMEWORK.discoveryRule.description}</span>
      </div>`;
    document.getElementById('legalFrameworkContent').innerHTML = legalHTML;
  } else {
    legalCard.style.display = 'none';
  }

  // Populate claim categories
  const categories = getApplicableClaimCategories(s.incident);
  let catHTML = `<div style="overflow-x:auto"><table class="capacity-table" style="font-size:12px">
    <thead><tr>
      <th>Claim Category</th>
      <th>Description</th>
      <th>Logging Timeline</th>
      <th>Settlement Timeline</th>
    </tr></thead><tbody>`;
  categories.forEach(cat => {
    const logUnit = cat.loggingTimeline.unit === 'yearsAfterDiagnosis' ? 'years (after diagnosis)' : cat.loggingTimeline.unit;
    const settleUnit = cat.settlementTimeline.unit === 'yearsAfterDiagnosis' ? 'years (after diagnosis)' : cat.settlementTimeline.unit;
    catHTML += `<tr>
      <td style="font-weight:600;color:#e2e8f0">${cat.name}</td>
      <td style="color:#94a3b8">${cat.description}</td>
      <td>${cat.loggingTimeline.min}-${cat.loggingTimeline.max} ${logUnit}</td>
      <td>${cat.settlementTimeline.min}-${cat.settlementTimeline.max} ${settleUnit}</td>
    </tr>`;
  });
  catHTML += `</tbody></table></div>`;

  // Add reserve development factors
  const reserveFactor = getReserveDevelopmentFactor(s.timeHorizon, s.incident);
  if (reserveFactor) {
    catHTML += `
      <div style="margin-top:16px;background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px">
        <h4 style="font-size:12px;font-weight:700;color:#eab308;margin-bottom:8px">Reserve Development Factors (${s.timeHorizon} term)</h4>
        <div style="font-size:13px;color:#e2e8f0">
          Factor range: <strong>${reserveFactor.min}x - ${reserveFactor.max}x</strong> of initial estimates
          <span style="color:#94a3b8;font-size:11px;margin-left:8px">(${reserveFactor.note})</span>
        </div>
      </div>`;
  }
  document.getElementById('claimCategoriesContent').innerHTML = catHTML;

  // Recommendations - incident-specific
  const recs = buildRecommendations(s);
  const recList = document.getElementById('recList');
  recList.innerHTML = '';
  recs.forEach(r => {
    const li = document.createElement('li');
    li.className = r.level;
    li.textContent = r.text;
    recList.appendChild(li);
  });

  // Update underinsurance warning
  const underinsuranceWarning = document.getElementById('underinsuranceWarning');
  if (s.isUnderinsured && s.coverageLimit) {
    underinsuranceWarning.style.display = '';
    document.getElementById('underinsuranceContent').innerHTML = `
      <strong style="color:#ef4444">Estimated losses (£${(s.estimatedTotalValue / 1000000).toFixed(1)}M) exceed coverage limit (£${s.coverageLimit}M) by ${s.underinsuranceRatio.toFixed(1)}x</strong><br>
      <span style="font-size:12px;color:#94a3b8">
        Based on ${s.ultimateClaimsMid.toLocaleString()} ultimate claims × £${s.avgClaimValue.toLocaleString()} avg claim value.<br>
        Historical parallel: West, Texas had $1M coverage vs $230M losses (230x underinsured).
      </span>
    `;
  } else {
    underinsuranceWarning.style.display = 'none';
  }

  // Draw charts
  const chartTitle = `Claims Spread - ${viewLabel} (${displayPeriods.length} ${periodLabel}s shown, ${fullLabel} full lifecycle)`;
  document.getElementById('forecastChartTitle').textContent = chartTitle;
  // Pass display config to chart functions
  const displayScenario = Object.assign({}, s, { isLongTerm: useMonthlyDisplay, periodLabel });

  if (supportsCanvas) {
    drawForecastChart(displayPeriods, displayScenario);
    drawCapacityChart(displayPeriods, displayScenario);
  } else {
    document.getElementById('forecastChart').parentElement.innerHTML = '<p style="color:#94a3b8;padding:20px">Canvas not supported in this browser. Please use a modern browser to view charts.</p>';
    document.getElementById('capacityChart').parentElement.innerHTML = '<p style="color:#94a3b8;padding:20px">Canvas not supported in this browser.</p>';
  }

  // Screen reader accessible chart summary (Issue 2)
  const srForecast = document.getElementById('forecastChartSR');
  if (srForecast) {
    srForecast.textContent = 'Claims forecast: ' + s.totalClaims.toLocaleString() + ' total claims. ' +
      'Peak of ' + viewPeakClaims + ' claims at ' + peakPeriodLabel + '. ' +
      'Current capacity is ' + s.periodCapacity + ' claims per week. ' +
      (s.canMeetTarget ? 'Claims can be cleared within target.' : 'Claims will NOT be cleared within target.');
  }
  const srCapacity = document.getElementById('capacityChartSR');
  if (srCapacity) {
    srCapacity.textContent = 'Capacity utilisation: ' + s.overCapacityPeriods + ' periods over capacity. ' +
      'Maximum backlog of ' + s.maxBacklog.toLocaleString() + ' claims. ' +
      (s.additionalStaff > 0 ? s.additionalStaff + ' additional staff required.' : 'No additional staff required.');
  }

  // Surge cost estimate (Issue 11)
  if (s.surgeEntries && s.surgeEntries.length > 0) {
    const surgeCosts = calculateSurgeCosts(s.surgeEntries, s.weeksToClear > 0 ? s.weeksToClear : 52, config.organisation.workDaysPerWeek);
    if (surgeCosts) {
      const resContent = document.getElementById('resourceContent');
      if (resContent) {
        resContent.innerHTML += `
          <div style="margin-top:16px;background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px">
            <h4 style="font-size:13px;font-weight:700;color:#eab308;margin-bottom:8px">Estimated Surge Costs (Contractor Rates)</h4>
            <div style="font-size:13px;color:#e2e8f0">
              Total estimated cost: <strong style="color:#eab308">£${(surgeCosts.totalCost / 1000).toFixed(0)}K</strong>
            </div>
            <div style="font-size:11px;color:#64748b;margin-top:4px">Based on £450/day contractor rate + £2,000 mobilisation per person</div>
          </div>`;
      }
    }
  }
}

// Build recommendations based on incident type and claim patterns
function buildRecommendations(s) {
  const recs = [];
  // Determine if the full lifecycle is long-term (for research-based recommendations)
  const isFullLifecycleLong = s.fullHorizonConfig && s.fullHorizonConfig.weeks > 52;

  // General capacity recommendations
  if (!s.canMeetTarget) {
    const fullLabel = s.fullHorizonConfig ? s.fullHorizonConfig.label : 'unknown';
    const clearLabel = s.weeksToClear === -1 ? (fullLabel + '+') : (s.weeksToClear + ' weeks');
    const targetLabel = s.targetWeeks + '-week';
    recs.push({ level: 'critical', text: `Claims will not be cleared within the ${targetLabel} target (estimated ${clearLabel}). Increase staff or add surge resources.` });
  }
  if (s.additionalStaff > 0) {
    recs.push({ level: 'critical', text: `Recruit or reassign ${s.additionalStaff} additional claims staff before peak week (Week ${s.peakPeriod}).` });
  }
  if (s.maxBacklog > s.periodCapacity * 2) {
    recs.push({ level: 'critical', text: `Peak backlog of ${s.maxBacklog.toLocaleString()} claims exceeds 2 weeks of capacity. Consider emergency outsourcing.` });
  }

  // Processing bottleneck warnings (research-based)
  if (s.timeHorizon === 'medium' || s.timeHorizon === 'long') {
    recs.push({ level: 'warning', text: 'Processing bottlenecks typically occur at 3-6 months (adjuster capacity) and 18-36 months (litigation phase). Plan surge resources accordingly.' });
  }

  // Reserve development factor warning
  const reserveFactorRec = getReserveDevelopmentFactor(s.timeHorizon, s.incident);
  if (reserveFactorRec && (s.incident === 'chemical' || s.incident === 'nuclear')) {
    recs.push({ level: 'warning', text: `Reserve development factor for ${s.timeHorizon} term: ${reserveFactorRec.min}-${reserveFactorRec.max}x initial estimates. ${reserveFactorRec.note}.` });
  }

  // BI processing time warning
  const pd = config.processingDays || DEFAULT_CONFIG.processingDays;
  if (pd.bi > pd.propertySimple * 10 && (s.claimType === 'both' || s.claimType === 'property')) {
    recs.push({
      level: 'warning',
      text: `BI claims take ${Math.round(pd.bi / pd.propertySimple)}x longer than simple property (${pd.bi} days vs ${pd.propertySimple} days). For property incidents, BI may become the pacing constraint.`
    });
  }

  // Incident-specific recommendations
  if (s.incident === 'chemical') {
    recs.push({ level: 'warning', text: 'BIMODAL DISTRIBUTION: Chemical releases show 25% of claims in weeks 1-4 (acute), then 45% emerge over years 2-40 (chronic effects, cancers). Bhopal example: 1M+ cases over 40 years.' });
    recs.push({ level: 'warning', text: 'Establish robust medical documentation protocols early - causation disputes are common. Discovery rule applies: 3-year limitation from when claimant gains knowledge of injury.' });
    if (s.claimType === 'both' || s.claimType === 'injury') {
      recs.push({ level: 'info', text: 'Set up medical monitoring programs for affected populations. Latent health claims (cancers, respiratory disease) may emerge 5-60 years post-incident.' });
      recs.push({ level: 'info', text: 'Historical reference: Bhopal awarded 574,304 injury claims with average compensation of $300-500. Generational effects documented.' });
    }
    if (s.claimType === 'both' || s.claimType === 'property') {
      recs.push({ level: 'info', text: 'Environmental remediation claims: 3-24 months to log, 5-40+ years to settle. Property claims may resurge from soil/groundwater contamination discovery.' });
    }
  }

  if (s.incident === 'nuclear') {
    recs.push({ level: 'critical', text: 'UK Nuclear Installations Act 2022: Personal injury limitation now 30 YEARS (extended from 10). Environmental reinstatement now explicitly covered. Operator liability €700M-1.2B.' });
    recs.push({ level: 'warning', text: 'Nuclear claim development: Only 5-10% of ultimate claims in first 6 months. 20-40% emerge at 10-30 years (latent cancers, genetic effects). Peak thyroid cancers at years 5-20.' });
    recs.push({ level: 'warning', text: 'Ensure specialist radiological assessors are available. Standard claims staff require additional training for radiation exposure claims.' });
    if (s.claimType === 'both' || s.claimType === 'property') {
      recs.push({ level: 'info', text: 'Property claims include evacuation (Fukushima: 164,000+ evacuees), exclusion zone losses, decontamination, and stigma-driven value impacts. Avg family compensation at Fukushima: ~$900,000.' });
    }
    if (s.claimType === 'both' || s.claimType === 'injury') {
      recs.push({ level: 'info', text: 'Psychological distress claims are significant: Fukushima paid ~$1,000/month for 6+ years. Establish clear eligibility criteria early for medical monitoring claims.' });
    }
    if (isFullLifecycleLong) {
      recs.push({ level: 'info', text: 'Stigma effects persist decades and cause claim resurgences following policy decisions or new disclosures. Three Mile Island cleanup took 14 years ($1B).' });
    }
  }

  if (s.incident === 'explosion') {
    recs.push({ level: 'warning', text: 'BLAST RADIUS CLAIM CONCENTRATION: 90%+ claims within 500m (total loss/severe), 60-80% at 500m-1km (significant structural), 20-40% at 1-3km (windows), 5-10% at 3-5km (glass/hearing).' });
    recs.push({ level: 'warning', text: 'Historical reference: BP Texas City - 15 fatalities, 4,000 claims, $2.1B settlements over 7 years. Buncefield - 2,700 claims, £300M-1B, BI settlements 9+ months.' });
    recs.push({ level: 'info', text: 'Business interruption claims become the pacing item (12-36 months processing). Require forensic accounting as downtime impacts develop.' });
    if (s.claimType === 'both' || s.claimType === 'injury') {
      recs.push({ level: 'info', text: 'Injury claims: lower count but high severity (burns, TBI, amputations). Acute physical injury: 0-7 days logging, 6-24 months settlement. Ensure specialist medical assessors.' });
    }
  }

  if (s.incident === 'fire') {
    recs.push({ level: 'warning', text: 'Fire/explosion = #1 cause of corporate insurance losses globally (21% by value). UK industrial sector: avg $700M+ annual insured losses, 69% of direct property damage.' });
    recs.push({ level: 'info', text: 'Expect property claim re-scope waves as hidden damage (soot, corrosion, smoke) discovered. Simple property: 3-6mo resolution. Complex: 6-18 months.' });
    if (s.claimType === 'both' || s.claimType === 'property') {
      recs.push({ level: 'info', text: 'Business interruption typically exceeds property damage by ~2.7x for industrial/petrochemical fires. BI assessment: 3-12 months, settlement: 12-36 months.' });
    }
  }

  // Underinsurance warning (research-based)
  if (s.severity === 'major' || s.severity === 'catastrophic') {
    recs.push({ level: 'warning', text: 'UNDERINSURANCE RISK: Historical examples - West, Texas: $1M coverage vs $230M losses. Review coverage limits against modelled exposure.' });
  }

  // Long lifecycle recommendations (based on incident severity, not view selection)
  if (isFullLifecycleLong) {
    recs.push({ level: 'info', text: `Full lifecycle: ${s.fullHorizonConfig.label} (severity-calibrated). Long-term projections subject to significant uncertainty. Reserve development factors: 7-15 years = 1.5-3.0x; 15-30 years = 2.0-5.0x initial estimates.` });
    if (s.incident === 'chemical' || s.incident === 'nuclear') {
      recs.push({ level: 'info', text: 'Maintain claim tracking systems and IBNR reserves for late-emerging claims. Asbestos precedent: 20-60 year latency, $65B+ US insured losses.' });
    }
  }

  // Claim category-specific timelines
  const categories = getApplicableClaimCategories(s.incident);
  const psych = categories.find(c => c.key === 'psychologicalInjury');
  if (psych && (s.claimType === 'both' || s.claimType === 'injury')) {
    recs.push({ level: 'info', text: 'Psychological injury claims (PTSD, anxiety): 1-36 months to log, 12-36 months to settle. Common in all major incident types.' });
  }

  // General recommendations
  if (s.totalClaims > 1000) {
    recs.push({ level: 'warning', text: 'High claim volume expected. Implement digital/online claim submission. Processing bottleneck at 3-6 months due to adjuster capacity.' });
  }
  recs.push({ level: 'info', text: 'Establish dedicated claims hotline and information centre. Coordinate with local authorities and emergency services for efficient claim validation.' });
  recs.push({ level: 'info', text: 'Secondary/consequential claims (supply chain, third parties): 3-24 months to log, 12-48 months to settle. Plan for delayed reporting.' });

  return recs;
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 6: CHART RENDERING
// Pure canvas chart drawing, no external dependencies
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Shared chart setup function (Issue 12: reduce duplication)
function setupCanvas(canvasId, height) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return null;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = height * dpr;
  canvas.style.height = height + 'px';
  ctx.scale(dpr, dpr);
  return { canvas, ctx, W: rect.width, H: height, dpr };
}

function drawChartGrid(ctx, pad, chartW, chartH, maxVal, numLines) {
  numLines = numLines || 4;
  ctx.strokeStyle = '#334155';
  ctx.lineWidth = 1;
  for (let i = 0; i <= numLines; i++) {
    const y = pad.top + (chartH / numLines) * i;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(Math.round(maxVal - (maxVal / numLines) * i).toLocaleString(), pad.left - 8, y + 4);
  }
}

// Store display periods for tooltip lookup
let _forecastDisplayPeriods = [];
let _forecastScenario = null;

function drawForecastChart(periods, scenario) {
  const setup = setupCanvas('forecastChart', 300);
  if (!setup) return;
  const { canvas, ctx, W, H } = setup;

  ctx.clearRect(0, 0, W, H);

  const pad = { top: 20, right: 20, bottom: 40, left: 60 };
  _forecastDisplayPeriods = periods;
  _forecastScenario = scenario;
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;

  const s = scenario;
  const hasSurge = periods.some(w => w.surgeStaff > 0);
  const hasClaimBreakdown = s.claimType === 'both';
  const periodLabel = s.isLongTerm ? 'M' : 'W';

  const maxVal = Math.max(s.periodCapacity, ...periods.map(w => w.newClaims), ...periods.map(w => w.effectiveCapacity)) * 1.15;
  const xStep = chartW / Math.max(1, periods.length - 1);

  // Grid lines
  ctx.strokeStyle = '#334155';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (chartH / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(Math.round(maxVal - (maxVal / 4) * i).toLocaleString(), pad.left - 8, y + 4);
  }

  // X labels (sample if too many)
  ctx.textAlign = 'center';
  ctx.fillStyle = '#64748b';
  const labelStep = periods.length > 24 ? Math.ceil(periods.length / 12) : 1;
  periods.forEach((w, i) => {
    if (i % labelStep === 0 || i === periods.length - 1) {
      const periodNum = s.isLongTerm ? w.month : (w.week || w.period);
      ctx.fillText(periodLabel + periodNum, pad.left + i * xStep, H - pad.bottom + 20);
    }
  });

  // Capacity line
  const capY = pad.top + chartH - (s.periodCapacity / maxVal) * chartH;
  ctx.strokeStyle = getChartColor('red');
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath(); ctx.moveTo(pad.left, capY); ctx.lineTo(pad.left + chartW, capY); ctx.stroke();
  ctx.setLineDash([]);

  // If showing both claim types, draw stacked area
  if (hasClaimBreakdown) {
    // Property claims area (bottom)
    ctx.beginPath();
    ctx.moveTo(pad.left, pad.top + chartH);
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.newProperty / maxVal) * chartH;
      ctx.lineTo(x, y);
    });
    ctx.lineTo(pad.left + (periods.length - 1) * xStep, pad.top + chartH);
    ctx.closePath();
    const gradProp = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
    gradProp.addColorStop(0, 'rgba(139,92,246,0.4)');
    gradProp.addColorStop(1, 'rgba(139,92,246,0.05)');
    ctx.fillStyle = gradProp;
    ctx.fill();

    // Injury claims area (on top of property)
    ctx.beginPath();
    ctx.moveTo(pad.left, pad.top + chartH - (periods[0].newProperty / maxVal) * chartH);
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const yBase = pad.top + chartH - (w.newProperty / maxVal) * chartH;
      const yTop = yBase - (w.newInjury / maxVal) * chartH;
      ctx.lineTo(x, yTop);
    });
    for (let i = periods.length - 1; i >= 0; i--) {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (periods[i].newProperty / maxVal) * chartH;
      ctx.lineTo(x, y);
    }
    ctx.closePath();
    const gradInj = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
    gradInj.addColorStop(0, 'rgba(249,115,22,0.4)');
    gradInj.addColorStop(1, 'rgba(249,115,22,0.05)');
    ctx.fillStyle = gradInj;
    ctx.fill();

    // Draw injury line
    ctx.strokeStyle = '#f97316';
    ctx.lineWidth = 2;
    ctx.beginPath();
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - ((w.newProperty + w.newInjury) / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Draw property line
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.newProperty / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

  } else {
    // Single claim type - draw area fill
    ctx.beginPath();
    ctx.moveTo(pad.left, pad.top + chartH);
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.newClaims / maxVal) * chartH;
      ctx.lineTo(x, y);
    });
    ctx.lineTo(pad.left + (periods.length - 1) * xStep, pad.top + chartH);
    ctx.closePath();
    const grad = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
    grad.addColorStop(0, 'rgba(59,130,246,0.3)');
    grad.addColorStop(1, 'rgba(59,130,246,0.02)');
    ctx.fillStyle = grad;
    ctx.fill();

    // Claims line
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 3;
    ctx.beginPath();
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.newClaims / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Data points (only if not too many)
    if (periods.length <= 24) {
      periods.forEach((w, i) => {
        const x = pad.left + i * xStep;
        const y = pad.top + chartH - (w.newClaims / maxVal) * chartH;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#3b82f6';
        ctx.fill();
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 2;
        ctx.stroke();
      });
    }
  }

  // Cumulative line (secondary Y-axis scale)
  const maxCum = periods[periods.length - 1].cumulative * 1.1;
  ctx.strokeStyle = '#22c55e';
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 3]);
  ctx.beginPath();
  periods.forEach((w, i) => {
    const x = pad.left + i * xStep;
    const y = pad.top + chartH - (w.cumulative / maxCum) * chartH;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();
  ctx.setLineDash([]);

  // Effective capacity line (if surge active)
  if (hasSurge) {
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 3]);
    ctx.beginPath();
    periods.forEach((w, i) => {
      const x = pad.left + i * xStep;
      const y = pad.top + chartH - (w.effectiveCapacity / maxVal) * chartH;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Legend
  let legendHTML = '';
  if (hasClaimBreakdown) {
    legendHTML = `
      <div class="legend-item"><div class="legend-swatch" style="background:#f97316"></div> Injury Claims</div>
      <div class="legend-item"><div class="legend-swatch" style="background:#8b5cf6"></div> Property Claims</div>
    `;
  } else {
    legendHTML = `<div class="legend-item"><div class="legend-swatch" style="background:#3b82f6"></div> New Claims/${s.isLongTerm ? 'Month' : 'Week'}</div>`;
  }
  legendHTML += `
    <div class="legend-item"><div class="legend-swatch" style="background:#22c55e"></div> Cumulative Claims</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#ef4444"></div> Base Capacity (${s.periodCapacity})</div>
  `;
  if (hasSurge) {
    legendHTML += `<div class="legend-item"><div class="legend-swatch" style="background:#a855f7"></div> Effective Capacity (with surge)</div>`;
  }
  document.getElementById('forecastLegend').innerHTML = legendHTML;
}

function drawCapacityChart(periods, scenario) {
  const setup = setupCanvas('capacityChart', 250);
  if (!setup) return;
  const { canvas, ctx, W, H } = setup;

  ctx.clearRect(0, 0, W, H);

  const pad = { top: 20, right: 20, bottom: 40, left: 60 };
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;

  const s = scenario;
  const periodLabel = s.isLongTerm ? 'M' : 'W';

  // Sample if too many periods
  let displayPeriods = periods;
  if (periods.length > 24) {
    const step = Math.ceil(periods.length / 24);
    displayPeriods = periods.filter((_, i) => i % step === 0);
  }

  const barW = (chartW / displayPeriods.length) * 0.7;
  const gap = (chartW / displayPeriods.length) * 0.3;

  const maxUtil = Math.max(100, ...displayPeriods.map(w => w.utilisation)) * 1.15;

  // Grid
  ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
  [0, 25, 50, 75, 100].forEach(pct => {
    const y = pad.top + chartH - (pct / maxUtil) * chartH;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b'; ctx.font = '11px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText(pct + '%', pad.left - 8, y + 4);
  });

  // 100% line
  const y100 = pad.top + chartH - (100 / maxUtil) * chartH;
  ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
  ctx.beginPath(); ctx.moveTo(pad.left, y100); ctx.lineTo(pad.left + chartW, y100); ctx.stroke();
  ctx.setLineDash([]);

  // Bars
  displayPeriods.forEach((w, i) => {
    const x = pad.left + i * (chartW / displayPeriods.length) + gap / 2;
    const barH = (w.utilisation / maxUtil) * chartH;
    const y = pad.top + chartH - barH;

    let color;
    if (w.utilisation <= 70) color = getChartColor('green');
    else if (w.utilisation <= 100) color = getChartColor('yellow');
    else color = getChartColor('red');

    ctx.fillStyle = color;
    ctx.beginPath();
    const r = 3;
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + barW - r, y);
    ctx.quadraticCurveTo(x + barW, y, x + barW, y + r);
    ctx.lineTo(x + barW, pad.top + chartH);
    ctx.lineTo(x, pad.top + chartH);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.fill();

    // Label (only if not too many bars)
    if (displayPeriods.length <= 16) {
      ctx.fillStyle = '#e2e8f0'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText(Math.round(w.utilisation) + '%', x + barW / 2, y - 6);
    }

    // X label
    const periodNum = s.isLongTerm ? w.month : (w.week || w.period);
    ctx.fillStyle = '#64748b'; ctx.font = '11px sans-serif';
    ctx.fillText(periodLabel + periodNum, x + barW / 2, H - pad.bottom + 20);
  });

  document.getElementById('capacityLegend').innerHTML = `
    <div class="legend-item"><div class="legend-swatch" style="background:#22c55e"></div> Under 70%</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#eab308"></div> 70-100%</div>
    <div class="legend-item"><div class="legend-swatch" style="background:#ef4444"></div> Over Capacity</div>
  `;
}


// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 7: REPORT GENERATION
// PDF report creation (opens in new window for print)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
function generateReport() {
  if (!lastScenario) { showToast('Run a scenario first.', 'warning'); return; }
  const s = lastScenario;
  const incidentLabels = { fire: 'Fire', explosion: 'Explosion', chemical: 'Chemical (Toxic Release)', nuclear: 'Nuclear (Radiological)', fertiliser: 'Fertiliser (Ammonium Nitrate)' };
  const severityLabels = { minor: 'Minor', moderate: 'Moderate', major: 'Major', catastrophic: 'Catastrophic' };
  const claimTypeLabels = { both: 'All Claims (Injury + Property)', injury: 'Injury Claims Only', property: 'Property Claims Only' };
  const horizonNames = { short: 'Short Term', medium: 'Medium Term', long: 'Long Term' };
  const viewLabel = `${horizonNames[s.timeHorizon]} (0-${s.viewHorizonConfig.label})`;
  const fullLabel = s.fullHorizonConfig.label;

  const now = new Date();
  const dateStr = now.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
  const timeStr = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });

  const { displayPeriods, periodLabel, useMonthlyDisplay: rptUseMonthly } = getDisplayPeriods(s);
  const capacityLabel = 'claims/week';

  const surgeRows = (s.surgeEntries.length > 0)
    ? `<tr><td colspan="2" style="font-weight:700;padding-top:12px">Surge Resources Planned</td></tr>` +
      s.surgeEntries.map(e => `<tr><td>+${e.extraStaff} staff</td><td>From Week ${e.startWeek} onwards</td></tr>`).join('')
    : '';

  const hasClaimBreakdown = s.claimType === 'both';
  const periodRows = displayPeriods.map(w => {
    const statusClass = w.backlog === 0 ? '#22c55e' : (w.backlog < w.effectiveCapacity ? '#eab308' : '#ef4444');
    const statusText = w.backlog === 0 ? 'On Track' : (w.backlog < w.effectiveCapacity ? 'Building Backlog' : 'Critical Backlog');
    const periodNum = rptUseMonthly ? w.month : (w.week || w.period);
    let row = `<tr>
      <td>${periodLabel} ${periodNum}</td>`;
    if (hasClaimBreakdown) {
      row += `<td style="color:#d97706">${w.newInjury.toLocaleString()}</td>
              <td style="color:#7c3aed">${w.newProperty.toLocaleString()}</td>`;
    }
    row += `<td>${w.newClaims.toLocaleString()}</td>
      <td>${w.cumulative.toLocaleString()}</td>
      <td>${w.effectiveCapacity.toLocaleString()}${w.surgeStaff > 0 ? ' (+' + (w.effectiveCapacity - s.periodCapacity) + ')' : ''}</td>
      <td>${w.processed.toLocaleString()}</td>
      <td>${w.backlog.toLocaleString()}</td>
      <td style="color:${statusClass};font-weight:600">${statusText}</td>
    </tr>`;
    return row;
  }).join('');

  // Build recommendations
  const recs = buildRecommendations(s).map(r => {
    const level = r.level === 'critical' ? 'CRITICAL' : (r.level === 'warning' ? 'WARNING' : 'INFO');
    return { level, text: r.text };
  });

  const recsHtml = recs.map(r => {
    const color = r.level === 'CRITICAL' ? '#ef4444' : (r.level === 'WARNING' ? '#eab308' : '#3b82f6');
    return `<li style="padding:8px 12px;border-left:3px solid ${color};margin-bottom:6px;background:#f8fafc;border-radius:0 6px 6px 0">
      <strong style="color:${color}">[${r.level}]</strong> ${r.text}</li>`;
  }).join('');

  // Table headers
  let tableHeaders = `<th>${periodLabel}</th>`;
  if (hasClaimBreakdown) {
    tableHeaders += `<th>Injury</th><th>Property</th>`;
  }
  tableHeaders += `<th>New Claims</th><th>Cumulative</th><th>Capacity</th><th>Processed</th><th>Backlog</th><th>Status</th>`;

  // Claim breakdown metrics
  let claimBreakdownMetrics = '';
  if (hasClaimBreakdown) {
    claimBreakdownMetrics = `
  <div class="metric"><div class="metric-val" style="color:#d97706">${s.injuryClaims.toLocaleString()}</div><div class="metric-lbl">Injury Claims (${Math.round(s.splits.injury * 100)}%)</div></div>
  <div class="metric"><div class="metric-val" style="color:#7c3aed">${s.propertyClaims.toLocaleString()}</div><div class="metric-lbl">Property Claims (${Math.round(s.splits.property * 100)}%)</div></div>`;
  }

  const timeToClearLabel = s.weeksToClear === -1
    ? (fullLabel + '+')
    : (s.weeksToClear + ' weeks');
  const targetLabel = s.targetWeeks + ' Weeks';

  const html = `<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><title>Claims Resilience Report - ${sanitizeHTML(s.site.name)}</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1000px; margin: 0 auto; padding: 40px 20px; color: #1e293b; line-height: 1.6; }
  h1 { font-size: 24px; border-bottom: 2px solid #3b82f6; padding-bottom: 8px; }
  h2 { font-size: 18px; color: #3b82f6; margin-top: 32px; margin-bottom: 12px; }
  table { width: 100%; border-collapse: collapse; font-size: 12px; margin-bottom: 20px; }
  th, td { padding: 6px 8px; text-align: left; border-bottom: 1px solid #e2e8f0; }
  th { background: #f1f5f9; font-weight: 600; color: #64748b; text-transform: uppercase; font-size: 10px; }
  .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin: 20px 0; }
  .metric { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 14px; text-align: center; }
  .metric-val { font-size: 22px; font-weight: 800; }
  .metric-lbl { font-size: 10px; color: #64748b; text-transform: uppercase; }
  .green { color: #22c55e; } .red { color: #ef4444; } .blue { color: #3b82f6; } .yellow { color: #eab308; }
  ul { list-style: none; padding: 0; }
  .footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #e2e8f0; font-size: 11px; color: #94a3b8; }
  .pattern-note { background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px; padding: 12px; margin: 16px 0; font-size: 13px; }
  @media print { body { padding: 20px; } }
</style></head><body>
<h1>Claims Resilience Report</h1>
<p style="color:#64748b;margin-top:-4px">Generated: ${dateStr} at ${timeStr}</p>

<h2>Scenario Parameters</h2>
<table>
  <tr><td style="font-weight:600;width:200px">Site</td><td>${sanitizeHTML(s.site.name)} - ${sanitizeHTML(s.site.location)}</td></tr>
  <tr><td style="font-weight:600">Incident Type</td><td>${incidentLabels[s.incident]}</td></tr>
  <tr><td style="font-weight:600">Claim Type</td><td>${claimTypeLabels[s.claimType]}</td></tr>
  <tr><td style="font-weight:600">Severity</td><td>${severityLabels[s.severity]}</td></tr>
  <tr><td style="font-weight:600">Claims Spread View</td><td>${viewLabel}</td></tr>
  <tr><td style="font-weight:600">Full Lifecycle</td><td>${fullLabel} (severity-calibrated)</td></tr>
  <tr><td style="font-weight:600">Time Calibration</td><td style="font-size:11px;color:#64748b">${s.viewHorizonConfig.note}</td></tr>
  <tr><td style="font-weight:600">Affected Population</td><td>${(s.site.population + s.site.staffOnSite).toLocaleString()} (${s.site.population.toLocaleString()} local + ${s.site.staffOnSite.toLocaleString()} staff)</td></tr>
  <tr><td style="font-weight:600">Base Capacity</td><td>${s.periodCapacity} ${capacityLabel} (${config.organisation.staffCount} staff)</td></tr>
  <tr><td style="font-weight:600">Weighted Avg Days/Claim</td><td>${s.weightedDaysPerClaim.toFixed(1)} days</td></tr>
  <tr><td style="font-weight:600">Claim Complexity Mix</td><td>Auto: ${s.claimComplexity.autoProcessedPct}% | 2-day: ${s.claimComplexity.twoDayPct}% | ${s.claimComplexity.customDays}-day: ${s.claimComplexity.customDayPct}% | Standard (${s.claimComplexity.standardDays || 4}d): ${Math.max(0, 100 - s.claimComplexity.autoProcessedPct - s.claimComplexity.twoDayPct - s.claimComplexity.customDayPct)}%</td></tr>
  <tr><td style="font-weight:600">Target Processing Time</td><td>${targetLabel}</td></tr>
  ${surgeRows}
</table>

${(() => {
    const distTemplate = getClaimDistributionTemplate(s.incident);
    const reserveFactor = getReserveDevelopmentFactor(s.timeHorizon, s.incident);
    const categories = getApplicableClaimCategories(s.incident);
    const patternDesc = PATTERN_DESCRIPTIONS[s.incident];

    let researchSection = '';

    // Pattern note with bimodal insight
    if (s.incident === 'chemical' || s.incident === 'nuclear') {
      researchSection += `
<div class="pattern-note">
  <strong>Claim Pattern Note (Bimodal Distribution):</strong> ${s.incident === 'chemical' ?
    'Chemical (toxic release) incidents show bimodal distribution: 25% of claims in weeks 1-4 (acute poisoning, immediate property), then 45% emerge over years 2-40 (chronic illness, cancers, environmental). Based on Bhopal (1M+ claims over 40 years), Seveso (1976). Discovery rule applies: 3-year limitation from when claimant gains knowledge.' :
    'Nuclear incidents show distinct claim development: Only 5-10% in first 6 months (evacuation, acute), 20-30% at 6mo-3yrs (property, BI), 30-40% at 3-10yrs (health monitoring), 20-40% at 10-30yrs (latent cancers). UK Nuclear Installations Act 2022: 30-year personal injury limitation, environmental reinstatement now covered.'}
</div>`;
    }

    // Claim distribution template
    if (distTemplate) {
      researchSection += `
<h2>Claim Distribution Pattern (Research-Based)</h2>
<p style="font-size:13px;color:#64748b;margin-bottom:12px"><strong>${distTemplate.name}</strong> - Bimodal distribution based on historical incident data</p>
<table>
  <thead><tr><th>Period</th><th>% of Claims</th><th>Claim Types</th></tr></thead>
  <tbody>
    ${distTemplate.distribution.map(d => `<tr><td style="font-weight:600">${d.period}</td><td style="font-weight:700">${d.percent}%</td><td>${d.types}</td></tr>`).join('')}
  </tbody>
</table>`;
    }

    // Claim categories and timelines
    researchSection += `
<h2>Claim Categories &amp; Timelines</h2>
<table>
  <thead><tr><th>Category</th><th>Description</th><th>Logging</th><th>Settlement</th></tr></thead>
  <tbody>
    ${categories.map(cat => {
      const logUnit = cat.loggingTimeline.unit === 'yearsAfterDiagnosis' ? 'years (after diagnosis)' : cat.loggingTimeline.unit;
      const settleUnit = cat.settlementTimeline.unit === 'yearsAfterDiagnosis' ? 'years (after diagnosis)' : cat.settlementTimeline.unit;
      return `<tr><td style="font-weight:600">${cat.name}</td><td style="color:#64748b">${cat.description}</td><td>${cat.loggingTimeline.min}-${cat.loggingTimeline.max} ${logUnit}</td><td>${cat.settlementTimeline.min}-${cat.settlementTimeline.max} ${settleUnit}</td></tr>`;
    }).join('')}
  </tbody>
</table>`;

    // Reserve development factors
    if (reserveFactor && reserveFactor.min) {
      researchSection += `
<div style="background:#fef3c7;border:1px solid #fcd34d;border-radius:8px;padding:12px;margin:16px 0">
  <strong>Reserve Development Factor (${s.timeHorizon} term):</strong> ${reserveFactor.min}x - ${reserveFactor.max}x of initial estimates. <em>${reserveFactor.note}</em>
</div>`;
    }

    // UK Nuclear Legal Framework
    if (s.incident === 'nuclear') {
      const nuc = UK_LEGAL_FRAMEWORK.nuclearLimitations;
      researchSection += `
<h2>UK Nuclear Legal Framework</h2>
<p style="font-size:13px;font-weight:700;color:#ef4444">UK Nuclear Installations Act 1965 (as amended 2022)</p>
<table>
  <thead><tr><th>Parameter</th><th>Pre-2022</th><th>Post-2022 (Current)</th></tr></thead>
  <tbody>
    <tr><td>Operator Liability Cap</td><td>${nuc.pre2022.operatorLiabilityCap}</td><td style="font-weight:700">${nuc.post2022.operatorLiabilityCap}</td></tr>
    <tr><td>Personal Injury Limitation</td><td>${nuc.pre2022.personalInjury.years} years</td><td style="font-weight:700;color:#22c55e">${nuc.post2022.personalInjury.years} years (extended)</td></tr>
    <tr><td>Property Damage Limitation</td><td>${nuc.pre2022.propertyDamage.years} years</td><td>${nuc.post2022.propertyDamage.years} years</td></tr>
    <tr><td>Environmental Reinstatement</td><td style="color:#ef4444">Not covered</td><td style="font-weight:700;color:#22c55e">Now covered</td></tr>
  </tbody>
</table>
<p style="font-size:12px;color:#64748b;margin-top:8px"><strong>Discovery Rule:</strong> ${UK_LEGAL_FRAMEWORK.discoveryRule.description}</p>`;
    }

    // Historical reference
    if (patternDesc && patternDesc.historicalRef) {
      researchSection += `
<div style="background:#e0f2fe;border:1px solid #0284c7;border-radius:8px;padding:12px;margin:16px 0;font-size:12px">
  <strong style="color:#0369a1">Historical Reference:</strong> ${patternDesc.historicalRef}
</div>`;
    }

    return researchSection;
  })()}

<h2>Key Metrics</h2>
<div class="metrics">
  <div class="metric"><div class="metric-val blue">${s.totalClaims.toLocaleString()}</div><div class="metric-lbl">Total Estimated Claims</div></div>
  ${claimBreakdownMetrics}
  <div class="metric"><div class="metric-val yellow">${periodLabel} ${s.peakPeriod}</div><div class="metric-lbl">Peak ${periodLabel} (${s.peakClaims} claims)</div></div>
  <div class="metric"><div class="metric-val ${s.canMeetTarget ? 'green' : 'red'}">${s.canMeetTarget ? 'Yes' : 'No'}</div><div class="metric-lbl">Cleared Within ${targetLabel}?</div></div>
  <div class="metric"><div class="metric-val ${s.canMeetTarget ? 'green' : 'red'}">${timeToClearLabel}</div><div class="metric-lbl">Time to Clear</div></div>
  <div class="metric"><div class="metric-val ${s.additionalStaff === 0 ? 'green' : 'red'}">+${s.additionalStaff}</div><div class="metric-lbl">Additional Staff Required</div></div>
  <div class="metric"><div class="metric-val yellow">${s.maxBacklog.toLocaleString()}</div><div class="metric-lbl">Peak Backlog</div></div>
</div>

<h2>${periodLabel}ly Breakdown</h2>
<table>
  <thead><tr>${tableHeaders}</tr></thead>
  <tbody>${periodRows}</tbody>
</table>

<h2>Resource Requirements</h2>
<table>
  <tr><td style="font-weight:600">Current Staff</td><td>${config.organisation.staffCount}</td></tr>
  <tr><td style="font-weight:600">Staff Needed at Peak</td><td>${s.staffNeededAtPeak}</td></tr>
  <tr><td style="font-weight:600">Additional Staff Required</td><td style="color:${s.additionalStaff > 0 ? '#ef4444' : '#22c55e'};font-weight:700">${s.additionalStaff > 0 ? '+' + s.additionalStaff : 'None'}</td></tr>
  <tr><td style="font-weight:600">Claims/Staff/Week</td><td>${s.claimsPerStaffPerWeek.toFixed(1)}</td></tr>
  <tr><td style="font-weight:600">Capacity Coverage at Peak</td><td>${Math.round((s.periodCapacity / s.peakClaims) * 100)}%</td></tr>
</table>

<h2>Recommendations</h2>
<ul>${recsHtml}</ul>

<div class="footer">
  <p><strong>Claims Resilience Testing Tool</strong> — Report generated automatically for planning purposes.</p>
  <p style="margin-top:8px">Analysis based on historical incident patterns and research data including:</p>
  <ul style="margin-top:4px;padding-left:20px;font-size:10px">
    <li>BP Texas City (2005): 4,000 claims, $2.1B settlements</li>
    <li>Buncefield UK (2005): 2,700 claims, £300M-1B</li>
    <li>Bhopal (1984): 1M+ claims over 40 years, $470M settlement</li>
    <li>Fukushima (2011): 164,000 evacuees, $70B+ compensation</li>
    <li>Three Mile Island (1979): $82M documented, 14-year cleanup</li>
    <li>West, Texas (2013): $230M losses vs $1M coverage</li>
    <li>NFPA Fire Statistics, Allianz Global Claims Review</li>
    <li>UK Nuclear Installations Act 1965 (as amended 2022)</li>
  </ul>
  <p style="margin-top:8px;font-size:10px;color:#94a3b8">Key insight: Claim development follows bimodal distribution — immediate spike of property/acute injury, followed by long tail of latent illness claims (30+ years for chemical/nuclear).</p>
</div>
</body></html>`;

  // Open in a new window and trigger print (Save as PDF)
  const printWindow = window.open('', '_blank');
  if (!printWindow) { alert('Please allow pop-ups to generate the PDF report.'); return; }
  printWindow.document.write(html);
  printWindow.document.close();
  printWindow.onload = function() { printWindow.print(); };
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION MC: MONTE CARLO SIMULATION ENGINE
// Triangular distributions, Gaussian copula correlation,
// convergence checking, sensitivity analysis, historical validation
// Methodology: Gaussian copula Monte Carlo with triangular marginals
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ===== MC DEFAULT CONFIGURATION =====
const MC_DEFAULT_CONFIG = {
  iterations: 10000,
  convergenceTolerance: 0.02,
  convergenceCheckInterval: 500,
  batchSize: 500,
  paramDefs: [
    { key: 'claimRate',       label: 'Claim Rate',              minFactor: 0.4, maxFactor: 2.0, note: '% of affected population filing' },
    { key: 'incidentMult',    label: 'Incident Multiplier',     minFactor: 0.6, maxFactor: 1.8, note: 'Severity scaling factor' },
    { key: 'claimMultPP',     label: 'Claims Per Person',       minFactor: 0.7, maxFactor: 1.5, note: 'Multiple filings per individual' },
    { key: 'injuryRatio',     label: 'Injury/Property Split',   minFactor: 0.6, maxFactor: 1.4, note: 'Injury proportion vs property' },
    { key: 'peakWeekShift',   label: 'Peak Timing Shift',       minFactor: -2,  maxFactor: 2,   note: 'Weeks earlier/later than expected', isAbsolute: true },
    { key: 'tailWeight',      label: 'Tail Weight',             minFactor: 0.7, maxFactor: 1.4, note: 'Long-tail claim emergence' },
    { key: 'processingTime',  label: 'Processing Time',         minFactor: 0.7, maxFactor: 1.5, note: 'Days per claim variability' },
    { key: 'population',      label: 'Affected Population',     minFactor: 0.5, maxFactor: 2.0, note: 'Actual vs estimated exposure' },
    { key: 'claimValue',      label: 'Avg Claim Value',         minFactor: 0.4, maxFactor: 2.5, note: 'Per-claim financial amount' },
    { key: 'reserveDev',      label: 'Reserve Development',     minFactor: 0.8, maxFactor: 1.3, note: 'Ultimate claims multiplier' },
    { key: 'staffAvail',      label: 'Staff Availability',      minFactor: 0.6, maxFactor: 1.0, note: 'Attrition under stress' }
  ],
  // Correlation matrix (Gaussian copula) - order matches paramDefs
  correlationMatrix: [
  //  clmR  incM  clMP  injR  pkWk  tail  proc  popn  clVl  rsDv  stAv
    [ 1.00, 0.30, 0.20, 0.10, 0.05, 0.40,-0.10, 0.30, 0.50, 0.30,-0.10], // claimRate
    [ 0.30, 1.00, 0.25, 0.05, 0.10, 0.30, 0.15, 0.20, 0.40, 0.25,-0.05], // incidentMult
    [ 0.20, 0.25, 1.00, 0.10, 0.05, 0.20, 0.10, 0.15, 0.20, 0.15, 0.00], // claimMultPP
    [ 0.10, 0.05, 0.10, 1.00, 0.00, 0.10, 0.05, 0.00, 0.15, 0.05, 0.00], // injuryRatio
    [ 0.05, 0.10, 0.05, 0.00, 1.00, 0.15, 0.00, 0.00, 0.00, 0.10, 0.00], // peakWeekShift
    [ 0.40, 0.30, 0.20, 0.10, 0.15, 1.00, 0.10, 0.15, 0.30, 0.50,-0.05], // tailWeight
    [-0.10, 0.15, 0.10, 0.05, 0.00, 0.10, 1.00, 0.00, 0.10, 0.10,-0.30], // processingTime
    [ 0.30, 0.20, 0.15, 0.00, 0.00, 0.15, 0.00, 1.00, 0.20, 0.15, 0.00], // population
    [ 0.50, 0.40, 0.20, 0.15, 0.00, 0.30, 0.10, 0.20, 1.00, 0.35,-0.05], // claimValue
    [ 0.30, 0.25, 0.15, 0.05, 0.10, 0.50, 0.10, 0.15, 0.35, 1.00,-0.05], // reserveDev
    [-0.10,-0.05, 0.00, 0.00, 0.00,-0.05,-0.30, 0.00,-0.05,-0.05, 1.00]  // staffAvail
  ]
};

let mcConfig = JSON.parse(JSON.stringify(MC_DEFAULT_CONFIG));
try {
  const savedMC = loadWithIntegrity('claimsToolMCConfig');
  if (savedMC && savedMC.paramDefs) {
    // Validate correlation matrix matches paramDefs (Issue 10)
    if (savedMC.correlationMatrix && savedMC.paramDefs &&
        savedMC.correlationMatrix.length === savedMC.paramDefs.length) {
      mcConfig = savedMC;
    } else {
      console.warn('MC config correlation matrix size mismatch. Using defaults.');
      showToast('MC config had mismatched matrix size. Reset to defaults.', 'warning');
    }
  }
} catch(e) {
  console.warn('Failed to load MC config:', e);
}

function saveMCConfig() {
  saveWithIntegrity('claimsToolMCConfig', mcConfig);
}

let mcMode = 'simple';
let mcRunning = false;
let lastMCResults = null;

// ===== MATH UTILITIES =====

function normalCDF(x) {
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
  const sign = x < 0 ? -1 : 1;
  const ax = Math.abs(x) / Math.SQRT2;
  const t = 1.0 / (1.0 + p * ax);
  const y = 1.0 - (((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-ax*ax);
  return 0.5 * (1.0 + sign * y);
}

function boxMuller() {
  let u1; do { u1 = getMCRandom(); } while (u1 === 0);
  return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * getMCRandom());
}

function choleskyDecompose(A) {
  const n = A.length;
  const L = Array.from({length: n}, () => new Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j <= i; j++) {
      let sum = 0;
      for (let k = 0; k < j; k++) sum += L[i][k] * L[j][k];
      if (i === j) { const d = A[i][i] - sum; L[i][j] = d > 0 ? Math.sqrt(d) : 0; }
      else { L[i][j] = L[j][j] > 0 ? (A[i][j] - sum) / L[j][j] : 0; }
    }
  }
  return L;
}

function triangularQuantile(u, min, mode, max) {
  if (max <= min) return mode;
  const fc = (mode - min) / (max - min);
  if (u < fc) return min + Math.sqrt(u * (max - min) * (mode - min));
  return max - Math.sqrt((1 - u) * (max - min) * (max - mode));
}

function generateCorrelatedUniforms(choleskyL, n) {
  const z = new Array(n);
  for (let i = 0; i < n; i++) z[i] = boxMuller();
  const u = new Array(n);
  for (let i = 0; i < n; i++) {
    let sum = 0;
    for (let j = 0; j <= i; j++) sum += choleskyL[i][j] * z[j];
    u[i] = Math.max(0.001, Math.min(0.999, normalCDF(sum)));
  }
  return u;
}

// ===== PURE SCENARIO CALCULATOR (no DOM) =====
function calculateScenarioCore(params) {
  const {
    totalAffected, claimRate, incidentMult, claimMultPP,
    injuryRatio, propertyRatio, claimType,
    incident, severity,
    peakWeekShift, tailWeightFactor,
    processingTimeFactor, staffAvailFactor,
    basePeriodCapacity,
    useBlastConcentration, site,
    claimValuePerClaim, reserveDevMidpoint,
    surgeEntries, targetWeeks
  } = params;

  const baseTotalClaims = Math.round(totalAffected * claimRate * incidentMult * claimMultPP);
  let injuryClaims = 0, propertyClaims = 0, totalClaims = 0;
  if (claimType === 'both') {
    injuryClaims = Math.round(baseTotalClaims * injuryRatio);
    propertyClaims = Math.round(baseTotalClaims * propertyRatio);
    totalClaims = injuryClaims + propertyClaims;
  } else if (claimType === 'injury') {
    injuryClaims = baseTotalClaims; totalClaims = injuryClaims;
  } else {
    propertyClaims = baseTotalClaims; totalClaims = propertyClaims;
  }

  if (useBlastConcentration && totalClaims > 0) {
    const blastResult = applyBlastRadiusConcentration(totalClaims, site, true);
    if (blastResult.total > 0) {
      const adj = blastResult.total / totalClaims;
      totalClaims = blastResult.total;
      injuryClaims = Math.round(injuryClaims * adj);
      propertyClaims = Math.round(propertyClaims * adj);
    }
  }

  const fullWeeks = resolveHorizonConfig(incident, severity, 'long').weeks;
  const simWeeks = Math.min(fullWeeks, 520);

  const patterns = CLAIM_PATTERNS[incident] || CLAIM_PATTERNS.fire;
  const injP = (patterns.injury || {})[severity] || { peakWeek: 3, shape: 'spike', tailWeight: 0.15 };
  const propP = (patterns.property || {})[severity] || { peakWeek: 3, shape: 'spike', tailWeight: 0.15 };

  const injPeak = Math.max(1, Math.round((injP.peakWeek || 3) + peakWeekShift));
  const propPeak = Math.max(1, Math.round((propP.peakWeek || 3) + peakWeekShift));
  const injTail = Math.max(0.01, (injP.tailWeight || 0.15) * tailWeightFactor);
  const propTail = Math.max(0.01, (propP.tailWeight || 0.15) * tailWeightFactor);

  const injDist = injuryClaims > 0 ? generateShapedDistribution(simWeeks, injPeak, injP.shape, injTail) : [];
  const propDist = propertyClaims > 0 ? generateShapedDistribution(simWeeks, propPeak, propP.shape, propTail) : [];

  const injPerWeek = injDist.map(d => Math.round(injuryClaims * d));
  const propPerWeek = propDist.map(d => Math.round(propertyClaims * d));

  const effectiveBaseCapacity = Math.max(1, Math.round(basePeriodCapacity * staffAvailFactor * processingTimeFactor));
  const wdpc = getWeightedDaysPerClaim();
  const claimsPerStaff = wdpc > 0 ? config.organisation.workDaysPerWeek / wdpc : config.organisation.workDaysPerWeek;

  let cumulative = 0, backlog = 0, peakClaims = 0, peakWeek = 0, maxBacklog = 0, overCapacityWeeks = 0;
  let weeksToClear = -1;

  for (let i = 0; i < simWeeks; i++) {
    const weekNum = i + 1;
    let surgeStaff = 0;
    (surgeEntries || []).forEach(e => { if (weekNum >= e.startWeek) surgeStaff += e.extraStaff; });
    const surgeCapacity = Math.round(surgeStaff * claimsPerStaff * processingTimeFactor);
    const weeklyCapacity = effectiveBaseCapacity + surgeCapacity;

    const newClaims = (injPerWeek[i] || 0) + (propPerWeek[i] || 0);
    cumulative += newClaims;
    if (newClaims > peakClaims) { peakClaims = newClaims; peakWeek = weekNum; }

    const available = newClaims + backlog;
    const processed = Math.min(available, weeklyCapacity);
    backlog = available - processed;
    if (backlog > maxBacklog) maxBacklog = backlog;
    if (newClaims > weeklyCapacity) overCapacityWeeks++;

    if (weeksToClear === -1 && backlog === 0 && cumulative >= totalClaims * 0.95) {
      weeksToClear = weekNum;
    }
  }

  const staffNeededAtPeak = peakClaims > 0
    ? Math.ceil(peakClaims / Math.max(1, effectiveBaseCapacity / Math.max(1, Math.round(config.organisation.staffCount * staffAvailFactor))))
    : config.organisation.staffCount;
  const additionalStaff = Math.max(0, staffNeededAtPeak - Math.round(config.organisation.staffCount * staffAvailFactor));
  const canMeetTarget = weeksToClear !== -1 && weeksToClear <= targetWeeks;
  const ultimateClaims = Math.round(totalClaims * reserveDevMidpoint);
  const estimatedValue = ultimateClaims * claimValuePerClaim;

  return {
    totalClaims, injuryClaims, propertyClaims,
    peakClaims, peakWeek, weeksToClear,
    maxBacklog, overCapacityWeeks,
    additionalStaff, staffNeededAtPeak, canMeetTarget,
    ultimateClaims, estimatedValue
  };
}

// ===== MC PARAMETER SAMPLING =====
function sampleMCParameters(choleskyL) {
  const uniforms = generateCorrelatedUniforms(choleskyL, mcConfig.paramDefs.length);
  const sampled = {};
  mcConfig.paramDefs.forEach((pd, i) => {
    const u = uniforms[i];
    if (pd.isAbsolute) {
      sampled[pd.key] = triangularQuantile(u, pd.minFactor, 0, pd.maxFactor);
    } else {
      sampled[pd.key] = triangularQuantile(u, pd.minFactor, 1.0, pd.maxFactor);
    }
  });
  return { sampled, uniforms };
}

// ===== STATISTICS =====
function computePercentiles(arr, pcts) {
  const sorted = [...arr].sort((a, b) => a - b);
  const n = sorted.length;
  const result = {};
  pcts.forEach(p => {
    const idx = Math.min(n - 1, Math.max(0, Math.floor(p / 100 * n)));
    result['P' + p] = sorted[idx];
  });
  result.mean = arr.reduce((s, v) => s + v, 0) / n;
  result.std = Math.sqrt(arr.reduce((s, v) => s + (v - result.mean) ** 2, 0) / n);
  result.min = sorted[0]; result.max = sorted[n - 1];
  return result;
}

function buildHistogram(arr, numBins) {
  const sorted = [...arr].sort((a, b) => a - b);
  const min = sorted[0], max = sorted[sorted.length - 1];
  if (max === min) return { bins: [{ low: min, high: max, count: arr.length, pct: 100 }], min, max };
  const binWidth = (max - min) / numBins;
  const bins = [];
  for (let i = 0; i < numBins; i++) bins.push({ low: min + i * binWidth, high: min + (i + 1) * binWidth, count: 0, pct: 0 });
  arr.forEach(v => { let idx = Math.floor((v - min) / binWidth); if (idx >= numBins) idx = numBins - 1; bins[idx].count++; });
  bins.forEach(b => b.pct = (b.count / arr.length) * 100);
  return { bins, min, max };
}

function buildExceedanceCurve(arr) {
  const sorted = [...arr].sort((a, b) => a - b);
  const n = sorted.length, step = Math.max(1, Math.floor(n / 200));
  const points = [];
  for (let i = 0; i < n; i += step) points.push({ value: sorted[i], exceedance: 1 - (i / n) });
  points.push({ value: sorted[n - 1], exceedance: 1 / n });
  return points;
}

function spearmanCorrelation(x, y) {
  const n = x.length;
  function rankArray(arr) {
    const indexed = arr.map((v, i) => ({ v, i })).sort((a, b) => a.v - b.v);
    const ranks = new Array(n);
    indexed.forEach((item, rank) => { ranks[item.i] = rank + 1; });
    return ranks;
  }
  const rx = rankArray(x), ry = rankArray(y);
  let sumD2 = 0;
  for (let i = 0; i < n; i++) sumD2 += (rx[i] - ry[i]) ** 2;
  return 1 - (6 * sumD2) / (n * (n * n - 1));
}

// ===== HISTORICAL VALIDATION DATA =====
const HISTORICAL_VALIDATION = {
  explosion: {
    bpTexasCity: { name: 'BP Texas City (2005)', totalClaims: 4000, totalValue: 2100000000, severity: 'catastrophic', population: 80000 },
    buncefield: { name: 'Buncefield UK (2005)', totalClaims: 2700, totalValue: 700000000, severity: 'major', population: 60000 }
  },
  chemical: {
    bhopal: { name: 'Bhopal (1984)', totalClaims: 1029517, totalValue: 470000000, severity: 'catastrophic', population: 500000 }
  },
  nuclear: {
    fukushima: { name: 'Fukushima (2011)', totalClaims: 164000, totalValue: 70000000000, severity: 'catastrophic', population: 200000 },
    threeMileIsland: { name: 'Three Mile Island (1979)', totalClaims: 2000, totalValue: 82000000, severity: 'moderate', population: 50000 }
  },
  fertiliser: {
    westTexas: { name: 'West, Texas (2013)', totalClaims: 425, totalValue: 230000000, severity: 'catastrophic', population: 2800 }
  },
  fire: {
    genericMajor: { name: 'Typical Major Industrial Fire', totalClaims: 350, totalValue: 42000000, severity: 'major', population: 25000 }
  }
};

// ===== MAIN MC RUNNER =====
function runMonteCarlo() {
  if (mcRunning) return;
  if (!lastScenario) { showToast('Run a scenario first to establish baseline.', 'warning'); return; }

  // Validate correlation matrix (Issue 5, 10)
  const matrixValidation = validateCorrelationMatrix(mcConfig.correlationMatrix, mcConfig.paramDefs);
  if (!matrixValidation.valid) {
    showToast('Correlation matrix error: ' + matrixValidation.errors.join('; '), 'error');
    return;
  }

  mcRunning = true;
  const s = lastScenario;

  // Initialize seeded RNG if seed is set (Issue 5)
  const seedInput = document.getElementById('mcSeedInput');
  if (seedInput && seedInput.value.trim() !== '') {
    mcRandomSeed = parseInt(seedInput.value) || 42;
    seededRandom = mulberry32(mcRandomSeed);
  } else {
    mcRandomSeed = null;
    seededRandom = null;
  }

  document.getElementById('mcSidebarControls').style.display = '';
  document.getElementById('mcResultsArea').style.display = '';
  document.getElementById('mcProgressContainer').style.display = '';

  const iterations = mcMode === 'advanced'
    ? (parseInt(document.getElementById('mcIterations').value) || 10000)
    : mcConfig.iterations;
  const tolerance = mcMode === 'advanced'
    ? ((parseFloat(document.getElementById('mcTolerance').value) || 2) / 100)
    : mcConfig.convergenceTolerance;

  const choleskyL = choleskyDecompose(mcConfig.correlationMatrix);

  const site = s.site;
  const totalAffected = site.population + site.staffOnSite;
  const claimRate = config.severityRates[s.severity];
  const incidentMult = config.incidentMultipliers[s.incident] || 1.0;
  const claimMultPP = config.claimMultiplierPerPerson?.[s.incident] || DEFAULT_CONFIG.claimMultiplierPerPerson?.[s.incident] || 1.0;
  const splits = config.claimTypeSplits?.[s.incident] || DEFAULT_CONFIG.claimTypeSplits[s.incident];
  const blastModel = document.getElementById('blastRadiusSelect')?.value || 'uniform';
  const useBlast = (s.incident === 'explosion' || s.incident === 'fertiliser') && blastModel === 'concentrated';
  const reserveFactor = getReserveDevelopmentFactor(s.timeHorizon, s.incident);
  const avgClaimValue = getAverageClaimValue(s.incident, s.severity);
  const baseWeeklyCapacity = getWeeklyCapacity();

  const results = {
    totalClaims: [], injuryClaims: [], propertyClaims: [],
    peakClaims: [], peakWeek: [], weeksToClear: [],
    maxBacklog: [], overCapacityWeeks: [],
    additionalStaff: [], staffNeededAtPeak: [],
    ultimateClaims: [], estimatedValue: [],
    canMeetTarget: []
  };
  const inputSamples = {};
  mcConfig.paramDefs.forEach(pd => { inputSamples[pd.key] = []; });

  let completed = 0, converged = false, prevMedian = null, prevP10 = null, prevP90 = null;
  let consecutiveStableChecks = 0;
  const MIN_ITERS_BEFORE_CONVERGENCE = Math.max(2000, Math.floor(iterations * 0.2));
  const REQUIRED_STABLE_CHECKS = 3;

  function processBatch() {
    const batchEnd = Math.min(completed + mcConfig.batchSize, iterations);
    for (let i = completed; i < batchEnd; i++) {
      const { sampled } = sampleMCParameters(choleskyL);

      const mcInjuryRatio = Math.max(0.05, Math.min(0.95, splits.injury * sampled.injuryRatio));

      mcConfig.paramDefs.forEach(pd => { inputSamples[pd.key].push(sampled[pd.key]); });

      const result = calculateScenarioCore({
        totalAffected: Math.round(totalAffected * sampled.population),
        claimRate: claimRate * sampled.claimRate,
        incidentMult: incidentMult * sampled.incidentMult,
        claimMultPP: claimMultPP * sampled.claimMultPP,
        injuryRatio: mcInjuryRatio,
        propertyRatio: 1 - mcInjuryRatio,
        claimType: s.claimType,
        incident: s.incident,
        severity: s.severity,
        peakWeekShift: sampled.peakWeekShift,
        tailWeightFactor: sampled.tailWeight,
        processingTimeFactor: 1 / sampled.processingTime,
        staffAvailFactor: sampled.staffAvail,
        basePeriodCapacity: baseWeeklyCapacity,
        useBlastConcentration: useBlast,
        site,
        claimValuePerClaim: avgClaimValue * sampled.claimValue,
        reserveDevMidpoint: reserveFactor.midpoint * sampled.reserveDev,
        surgeEntries: s.surgeEntries || surgeEntries,
        targetWeeks: s.targetWeeks
      });

      for (const key in results) {
        if (result[key] !== undefined) results[key].push(result[key]);
      }
    }
    completed = batchEnd;

    const pct = Math.round((completed / iterations) * 100);
    const bar = document.getElementById('mcProgressBar');
    bar.style.width = pct + '%';
    bar.textContent = pct + '% (' + completed.toLocaleString() + '/' + iterations.toLocaleString() + ')';

    // Convergence check: only after minimum iterations, requires multiple consecutive stable checks,
    // and checks P10/P50/P90 stability (not just median)
    if (completed % mcConfig.convergenceCheckInterval === 0 && completed >= MIN_ITERS_BEFORE_CONVERGENCE) {
      const sorted = [...results.totalClaims].sort((a, b) => a - b);
      const n = sorted.length;
      const currentMedian = sorted[Math.floor(n * 0.5)];
      const currentP10 = sorted[Math.floor(n * 0.1)];
      const currentP90 = sorted[Math.floor(n * 0.9)];

      if (prevMedian !== null && prevP10 !== null && prevP90 !== null) {
        const medianChange = Math.abs(currentMedian - prevMedian) / Math.max(1, prevMedian);
        const p10Change = Math.abs(currentP10 - prevP10) / Math.max(1, prevP10);
        const p90Change = Math.abs(currentP90 - prevP90) / Math.max(1, prevP90);
        const allStable = medianChange < tolerance && p10Change < tolerance && p90Change < tolerance;

        if (allStable) {
          consecutiveStableChecks++;
          if (consecutiveStableChecks >= REQUIRED_STABLE_CHECKS) {
            converged = true;
            document.getElementById('mcConvergenceStatus').innerHTML =
              '<span class="dot converged"></span> Converged at ' + completed.toLocaleString() + ' iterations (P10/P50/P90 stable within ' + (tolerance * 100).toFixed(1) + '% for ' + REQUIRED_STABLE_CHECKS + ' consecutive checks)';
          }
        } else {
          consecutiveStableChecks = 0;
        }
      }
      prevMedian = currentMedian;
      prevP10 = currentP10;
      prevP90 = currentP90;
    }

    if (completed < iterations && !converged) {
      setTimeout(processBatch, 0);
    } else {
      if (!converged) {
        document.getElementById('mcConvergenceStatus').innerHTML =
          '<span class="dot converged"></span> Completed ' + completed.toLocaleString() + ' iterations';
      }
      document.getElementById('mcProgressBar').style.width = '100%';
      document.getElementById('mcProgressBar').textContent = '100% Complete';

      lastMCResults = { iterations: completed, converged, results, inputSamples, baseScenario: s, stats: {}, sensitivity: {} };

      const pctiles = [5, 10, 25, 50, 75, 90, 95, 99];
      for (const key in results) {
        if (key === 'canMeetTarget') {
          lastMCResults.stats[key] = { probabilityYes: results[key].filter(v => v).length / completed };
        } else {
          lastMCResults.stats[key] = computePercentiles(results[key], pctiles);
        }
      }

      const outputKeys = ['totalClaims', 'estimatedValue', 'weeksToClear', 'additionalStaff'];
      outputKeys.forEach(outKey => {
        lastMCResults.sensitivity[outKey] = [];
        mcConfig.paramDefs.forEach(pd => {
          if (inputSamples[pd.key] && results[outKey]) {
            const corr = spearmanCorrelation(inputSamples[pd.key], results[outKey]);
            lastMCResults.sensitivity[outKey].push({ param: pd.label, correlation: corr, key: pd.key });
          }
        });
        lastMCResults.sensitivity[outKey].sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
      });

      displayMCResults(lastMCResults);
      mcRunning = false;
      showToast('Monte Carlo simulation complete (' + completed.toLocaleString() + ' iterations' + (converged ? ', converged' : '') + ')', 'success');
      setTimeout(() => { document.getElementById('mcProgressContainer').style.display = 'none'; }, 1500);
    }
  }
  processBatch();
}

// ===== MC RESULTS DISPLAY =====
function displayMCResults(mc) {
  const s = mc.baseScenario, st = mc.stats;

  document.getElementById('mcMethodNote').innerHTML =
    '<strong>Methodology:</strong> Gaussian copula Monte Carlo simulation with triangular marginal distributions. ' +
    mc.iterations.toLocaleString() + ' iterations' + (mc.converged ? ' (converged)' : '') +
    '. Inter-parameter correlations modelled via Cholesky-decomposed correlation matrix. ' +
    'All ' + mcConfig.paramDefs.length + ' stochastic parameters varied simultaneously.' +
    '<br><strong>Parameters varied:</strong> ' + mcConfig.paramDefs.map(p => p.label).join(', ');

  const grid = document.getElementById('mcMetricsGrid');
  const metrics = [
    { label: 'Total Claims', det: s.totalClaims, stats: st.totalClaims, fmt: v => Math.round(v).toLocaleString() },
    { label: 'Injury Claims', det: s.injuryClaims, stats: st.injuryClaims, fmt: v => Math.round(v).toLocaleString() },
    { label: 'Property Claims', det: s.propertyClaims, stats: st.propertyClaims, fmt: v => Math.round(v).toLocaleString() },
    { label: 'Peak Weekly Claims', det: s.peakClaims, stats: st.peakClaims, fmt: v => Math.round(v).toLocaleString() },
    { label: 'Time to Clear (wks)', det: s.weeksToClear, stats: st.weeksToClear, fmt: v => v === -1 ? 'N/A' : Math.round(v).toLocaleString() },
    { label: 'Max Backlog', det: s.maxBacklog, stats: st.maxBacklog, fmt: v => Math.round(v).toLocaleString() },
    { label: 'Addl Staff Needed', det: s.additionalStaff, stats: st.additionalStaff, fmt: v => '+' + Math.round(v).toLocaleString() },
    { label: 'Ultimate Claims', det: s.ultimateClaimsMid || s.ultimateClaims || 0, stats: st.ultimateClaims, fmt: v => Math.round(v).toLocaleString() },
    { label: 'Estimated Value', det: s.estimatedTotalValue || 0, stats: st.estimatedValue, fmt: v => '\u00A3' + (v / 1e6).toFixed(1) + 'M' },
    { label: 'Can Meet Target', det: s.canMeetTarget, stats: st.canMeetTarget, isBool: true }
  ];

  grid.innerHTML = metrics.map(m => {
    if (m.isBool) {
      const prob = (m.stats.probabilityYes * 100).toFixed(1);
      const color = m.stats.probabilityYes > 0.7 ? '#22c55e' : m.stats.probabilityYes > 0.3 ? '#eab308' : '#ef4444';
      return '<div class="mc-metric-card">' +
        '<div class="det-value" style="color:' + (m.det ? '#22c55e' : '#ef4444') + '">' + (m.det ? 'Yes' : 'No') + ' <span style="font-size:11px;color:#64748b">(det.)</span></div>' +
        '<div class="mc-range" style="color:' + color + '">' + prob + '% probability</div>' +
        '<div class="metric-label">' + m.label + '</div></div>';
    }
    const detVal = m.det !== null ? m.fmt(m.det) : 'N/A';
    return '<div class="mc-metric-card">' +
      '<div class="det-value">' + detVal + ' <span style="font-size:11px;color:#64748b">(deterministic)</span></div>' +
      '<div class="mc-range">P10: ' + m.fmt(m.stats.P10) + ' \u2014 P50: ' + m.fmt(m.stats.P50) + ' \u2014 P90: ' + m.fmt(m.stats.P90) + '</div>' +
      '<div class="mc-ci">95% CI: ' + m.fmt(m.stats.P5) + ' \u2013 ' + m.fmt(m.stats.P95) + ' | Mean: ' + m.fmt(m.stats.mean) + '</div>' +
      '<div class="metric-label">' + m.label + '</div></div>';
  }).join('');

  drawMCHistogram('mcClaimsHistogram', mc.results.totalClaims, 'Total Claims', s.totalClaims, 'mcClaimsHistLegend');
  drawMCHistogram('mcValueHistogram', mc.results.estimatedValue, 'Estimated Value', null, 'mcValueHistLegend', v => '\u00A3' + (v / 1e6).toFixed(1) + 'M');
  drawMCHistogram('mcClearTimeHistogram', mc.results.weeksToClear.filter(v => v > 0), 'Weeks to Clear', s.weeksToClear > 0 ? s.weeksToClear : null, 'mcClearTimeLegend');

  drawExceedanceChart('mcClaimsExceedance', mc.results.totalClaims, 'Claims');
  drawExceedanceChart('mcValueExceedance', mc.results.estimatedValue, 'Value', v => '\u00A3' + (v / 1e6).toFixed(0) + 'M');

  drawTornadoChart('mcTornadoChart', mc.sensitivity.totalClaims, 'Total Claims');

  displayComparison(mc);
  displayHistoricalValidation(mc);
}

// ===== MC CHART: HISTOGRAM =====
function drawMCHistogram(canvasId, data, title, deterministicValue, legendId, formatter) {
  const canvas = document.getElementById(canvasId);
  if (!canvas || !data || data.length === 0) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr; canvas.height = 280 * dpr; canvas.style.height = '280px';
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 280;
  ctx.clearRect(0, 0, W, H);

  const fmt = formatter || (v => Math.round(v).toLocaleString());
  const hist = buildHistogram(data, 40);
  const pad = { top: 20, right: 20, bottom: 50, left: 70 };
  const chartW = W - pad.left - pad.right, chartH = H - pad.top - pad.bottom;
  const maxPct = Math.max(...hist.bins.map(b => b.pct));
  const barW = chartW / hist.bins.length;

  const sorted = [...data].sort((a, b) => a - b);
  const p5 = sorted[Math.floor(sorted.length * 0.05)];
  const p25 = sorted[Math.floor(sorted.length * 0.25)];
  const p50 = sorted[Math.floor(sorted.length * 0.50)];
  const p75 = sorted[Math.floor(sorted.length * 0.75)];
  const p95 = sorted[Math.floor(sorted.length * 0.95)];

  // Grid
  ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (chartH / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b'; ctx.font = '10px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText((maxPct - (maxPct / 4) * i).toFixed(1) + '%', pad.left - 6, y + 4);
  }

  // Bars
  hist.bins.forEach((bin, i) => {
    const x = pad.left + i * barW;
    const barH = maxPct > 0 ? (bin.pct / maxPct) * chartH : 0;
    const y = pad.top + chartH - barH;
    const midVal = (bin.low + bin.high) / 2;
    if (midVal < p5 || midVal > p95) ctx.fillStyle = colorBlindMode ? 'rgba(213,94,0,0.6)' : 'rgba(239,68,68,0.6)';
    else if (midVal < p25 || midVal > p75) ctx.fillStyle = colorBlindMode ? 'rgba(230,159,0,0.6)' : 'rgba(234,179,8,0.6)';
    else ctx.fillStyle = colorBlindMode ? 'rgba(86,180,233,0.6)' : 'rgba(59,130,246,0.6)';
    ctx.fillRect(x + 1, y, Math.max(1, barW - 2), barH);
  });

  // Deterministic line
  if (deterministicValue !== null && deterministicValue > 0 && hist.max > hist.min) {
    const detX = pad.left + ((deterministicValue - hist.min) / (hist.max - hist.min)) * chartW;
    if (detX >= pad.left && detX <= pad.left + chartW) {
      ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 2; ctx.setLineDash([6, 3]);
      ctx.beginPath(); ctx.moveTo(detX, pad.top); ctx.lineTo(detX, pad.top + chartH); ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle = '#22c55e'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('Det: ' + fmt(deterministicValue), detX, pad.top - 4);
    }
  }

  // P50 line
  if (hist.max > hist.min) {
    const p50X = pad.left + ((p50 - hist.min) / (hist.max - hist.min)) * chartW;
    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2; ctx.setLineDash([4, 3]);
    ctx.beginPath(); ctx.moveTo(p50X, pad.top); ctx.lineTo(p50X, pad.top + chartH); ctx.stroke(); ctx.setLineDash([]);
    ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('P50: ' + fmt(p50), p50X, pad.top + chartH + 14);
  }

  // X labels
  ctx.fillStyle = '#64748b'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  for (let i = 0; i <= 6; i++) {
    const val = hist.min + (hist.max - hist.min) * (i / 6);
    ctx.fillText(fmt(val), pad.left + (i / 6) * chartW, pad.top + chartH + 30);
  }

  ctx.save(); ctx.translate(14, pad.top + chartH / 2); ctx.rotate(-Math.PI / 2);
  ctx.fillStyle = '#64748b'; ctx.font = '11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Frequency (%)', 0, 0); ctx.restore();

  if (legendId) {
    document.getElementById(legendId).innerHTML =
      '<div class="legend-item"><div class="legend-swatch" style="background:#3b82f6"></div> P25-P75 (IQR)</div>' +
      '<div class="legend-item"><div class="legend-swatch" style="background:#eab308"></div> P5-P25 / P75-P95</div>' +
      '<div class="legend-item"><div class="legend-swatch" style="background:#ef4444"></div> Tail (&lt; P5 / &gt; P95)</div>' +
      (deterministicValue !== null ? '<div class="legend-item"><div class="legend-swatch" style="background:#22c55e"></div> Deterministic</div>' : '') +
      '<div class="legend-item"><div class="legend-swatch" style="background:#f59e0b"></div> Median (P50)</div>';
  }
}

// ===== MC CHART: EXCEEDANCE CURVE =====
function drawExceedanceChart(canvasId, data, label, formatter) {
  const canvas = document.getElementById(canvasId);
  if (!canvas || !data || data.length === 0) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr; canvas.height = 220 * dpr; canvas.style.height = '220px';
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 220;
  ctx.clearRect(0, 0, W, H);

  const curve = buildExceedanceCurve(data);
  const fmt = formatter || (v => Math.round(v).toLocaleString());
  const pad = { top: 16, right: 16, bottom: 40, left: 56 };
  const chartW = W - pad.left - pad.right, chartH = H - pad.top - pad.bottom;
  const minVal = curve[0].value, maxVal = curve[curve.length - 1].value;
  const valRange = maxVal - minVal || 1;

  ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
  [0, 0.2, 0.4, 0.6, 0.8, 1.0].forEach(p => {
    const y = pad.top + chartH * (1 - p);
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + chartW, y); ctx.stroke();
    ctx.fillStyle = '#64748b'; ctx.font = '10px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText((p * 100).toFixed(0) + '%', pad.left - 4, y + 4);
  });

  // Curve + fill
  ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
  ctx.beginPath();
  curve.forEach((pt, i) => {
    const x = pad.left + ((pt.value - minVal) / valRange) * chartW;
    const y = pad.top + chartH * (1 - pt.exceedance);
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();
  ctx.lineTo(pad.left + chartW, pad.top + chartH);
  ctx.lineTo(pad.left, pad.top + chartH);
  ctx.closePath();
  const grad = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
  grad.addColorStop(0, 'rgba(245,158,11,0.2)'); grad.addColorStop(1, 'rgba(245,158,11,0.02)');
  ctx.fillStyle = grad; ctx.fill();

  ctx.fillStyle = '#64748b'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const val = minVal + valRange * (i / 5);
    ctx.fillText(fmt(val), pad.left + (i / 5) * chartW, H - pad.bottom + 16);
  }

  ctx.save(); ctx.translate(12, pad.top + chartH / 2); ctx.rotate(-Math.PI / 2);
  ctx.fillText('P(X > x)', 0, 0); ctx.restore();
  ctx.fillText(label, pad.left + chartW / 2, H - 4);
}

// ===== MC CHART: TORNADO =====
function drawTornadoChart(canvasId, sensData, outputLabel) {
  const canvas = document.getElementById(canvasId);
  if (!canvas || !sensData || sensData.length === 0) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr; canvas.height = 320 * dpr; canvas.style.height = '320px';
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 320;
  ctx.clearRect(0, 0, W, H);

  const top = sensData.slice(0, Math.min(10, sensData.length));
  const pad = { top: 30, right: 30, bottom: 30, left: 160 };
  const chartW = W - pad.left - pad.right, chartH = H - pad.top - pad.bottom;
  const barH = Math.min(24, chartH / top.length - 4);
  const maxCorr = Math.max(0.1, Math.max(...top.map(d => Math.abs(d.correlation))));

  ctx.fillStyle = '#e2e8f0'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Sensitivity to ' + outputLabel, W / 2, 16);

  const centerX = pad.left + chartW / 2;
  ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(centerX, pad.top); ctx.lineTo(centerX, pad.top + chartH); ctx.stroke();

  ctx.fillStyle = '#64748b'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  [-1, -0.5, 0, 0.5, 1].forEach(v => {
    const x = centerX + (v / maxCorr) * (chartW / 2);
    if (x >= pad.left && x <= pad.left + chartW) ctx.fillText(v.toFixed(1), x, pad.top + chartH + 16);
  });

  top.forEach((d, i) => {
    const y = pad.top + i * (chartH / top.length) + (chartH / top.length - barH) / 2;
    const w = (d.correlation / maxCorr) * (chartW / 2);
    ctx.fillStyle = d.correlation > 0 ? 'rgba(59,130,246,0.7)' : 'rgba(239,68,68,0.7)';
    if (w > 0) ctx.fillRect(centerX, y, w, barH);
    else ctx.fillRect(centerX + w, y, -w, barH);

    ctx.fillStyle = '#e2e8f0'; ctx.font = '11px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText(d.param, pad.left - 8, y + barH / 2 + 4);
    ctx.fillStyle = '#94a3b8'; ctx.font = '10px sans-serif';
    ctx.textAlign = d.correlation > 0 ? 'left' : 'right';
    ctx.fillText(d.correlation.toFixed(3), centerX + w + (d.correlation > 0 ? 4 : -4), y + barH / 2 + 4);
  });

  ctx.fillStyle = '#64748b'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Spearman Rank Correlation', W / 2, H - 6);
}

// ===== COMPARISON TABLE =====
function displayComparison(mc) {
  const s = mc.baseScenario, st = mc.stats;
  const fmt = v => Math.round(v).toLocaleString();
  const fmtMoney = v => '\u00A3' + (v / 1e6).toFixed(1) + 'M';

  const rows = [
    { label: 'Total Claims', det: s.totalClaims, mc: st.totalClaims, fmt },
    { label: 'Injury Claims', det: s.injuryClaims, mc: st.injuryClaims, fmt },
    { label: 'Property Claims', det: s.propertyClaims, mc: st.propertyClaims, fmt },
    { label: 'Peak Weekly Claims', det: s.peakClaims, mc: st.peakClaims, fmt },
    { label: 'Weeks to Clear', det: s.weeksToClear, mc: st.weeksToClear, fmt },
    { label: 'Max Backlog', det: s.maxBacklog, mc: st.maxBacklog, fmt },
    { label: 'Additional Staff', det: s.additionalStaff, mc: st.additionalStaff, fmt },
    { label: 'Ultimate Claims', det: s.ultimateClaimsMid || s.ultimateClaims || 0, mc: st.ultimateClaims, fmt },
    { label: 'Estimated Value', det: s.estimatedTotalValue || 0, mc: st.estimatedValue, fmt: fmtMoney }
  ];

  document.getElementById('mcComparisonContent').innerHTML =
    '<table class="capacity-table" style="font-size:12px"><thead><tr>' +
    '<th>Metric</th><th>Deterministic</th><th>MC P10</th><th>MC P50 (Median)</th><th>MC P90</th><th>MC Mean</th><th>Difference (P50 vs Det)</th>' +
    '</tr></thead><tbody>' +
    rows.map(r => {
      const diff = r.mc.P50 - r.det;
      const diffPct = r.det !== 0 ? ((diff / r.det) * 100).toFixed(1) : 'N/A';
      const diffColor = Math.abs(diff) / Math.max(1, Math.abs(r.det)) > 0.1 ? '#eab308' : '#22c55e';
      return '<tr><td style="font-weight:600">' + r.label + '</td>' +
        '<td>' + r.fmt(r.det) + '</td>' +
        '<td style="color:#3b82f6">' + r.fmt(r.mc.P10) + '</td>' +
        '<td style="color:#f59e0b;font-weight:700">' + r.fmt(r.mc.P50) + '</td>' +
        '<td style="color:#ef4444">' + r.fmt(r.mc.P90) + '</td>' +
        '<td>' + r.fmt(r.mc.mean) + '</td>' +
        '<td style="color:' + diffColor + '">' + (diff >= 0 ? '+' : '') + r.fmt(diff) + ' (' + diffPct + '%)</td></tr>';
    }).join('') +
    '<tr><td style="font-weight:600">Can Meet Target</td>' +
    '<td style="color:' + (s.canMeetTarget ? '#22c55e' : '#ef4444') + '">' + (s.canMeetTarget ? 'Yes' : 'No') + '</td>' +
    '<td colspan="5" style="color:#f59e0b;font-weight:700">' + (st.canMeetTarget.probabilityYes * 100).toFixed(1) + '% probability of meeting target</td></tr>' +
    '</tbody></table>';
}

// ===== HISTORICAL VALIDATION =====
function displayHistoricalValidation(mc) {
  const incident = mc.baseScenario.incident;
  const validationData = HISTORICAL_VALIDATION[incident];
  if (!validationData) {
    document.getElementById('mcValidationContent').innerHTML =
      '<p style="color:#94a3b8;font-size:13px">No historical validation data available for this incident type.</p>';
    return;
  }

  const claimsSorted = [...mc.results.totalClaims].sort((a, b) => a - b);
  const valueSorted = [...mc.results.estimatedValue].sort((a, b) => a - b);

  function getPercentile(sorted, value) {
    let idx = sorted.findIndex(v => v >= value);
    if (idx === -1) idx = sorted.length;
    return (idx / sorted.length * 100).toFixed(1);
  }

  let html = '<table class="capacity-table" style="font-size:12px">' +
    '<thead><tr><th>Historical Incident</th><th>Actual Claims</th><th>MC Percentile</th><th>Actual Value</th><th>MC Percentile</th><th>Assessment</th></tr></thead><tbody>';

  for (const key in validationData) {
    const hist = validationData[key];
    const currentPop = mc.baseScenario.site.population + mc.baseScenario.site.staffOnSite;
    const scaleFactor = currentPop / (hist.population || currentPop);
    const scaledClaims = Math.round(hist.totalClaims * scaleFactor);
    const scaledClaimPct = getPercentile(claimsSorted, scaledClaims);
    const valuePct = getPercentile(valueSorted, hist.totalValue);
    const pctNum = parseFloat(scaledClaimPct);
    let assessment, assessClass;
    if (pctNum >= 2 && pctNum <= 98) { assessment = 'Within range'; assessClass = 'validation-pass'; }
    else if (pctNum >= 0.5 && pctNum <= 99.5) { assessment = 'Edge of range'; assessClass = 'validation-warn'; }
    else { assessment = 'Outside range'; assessClass = 'validation-fail'; }

    html += '<tr><td style="font-weight:600">' + hist.name + '<br><span style="font-size:10px;color:#64748b">Pop: ' + hist.population.toLocaleString() + ' (scale: ' + scaleFactor.toFixed(2) + 'x)</span></td>' +
      '<td>' + hist.totalClaims.toLocaleString() + '<br><span style="font-size:10px;color:#64748b">Scaled: ' + scaledClaims.toLocaleString() + '</span></td>' +
      '<td>P' + scaledClaimPct + '</td>' +
      '<td>\u00A3' + (hist.totalValue / 1e6).toFixed(0) + 'M</td>' +
      '<td>P' + valuePct + '</td>' +
      '<td class="' + assessClass + '">' + assessment + '</td></tr>';
  }

  html += '</tbody></table>' +
    '<div style="margin-top:12px;font-size:11px;color:#94a3b8">' +
    '<strong>Interpretation:</strong> Historical outcomes falling between P2-P98 indicate the model produces realistic uncertainty ranges. ' +
    'Claims are population-scaled to enable comparison. Financial values are nominal (not inflation-adjusted).</div>';

  document.getElementById('mcValidationContent').innerHTML = html;
}

// ===== MC UI CONTROLS =====
function setMCMode(mode) {
  mcMode = mode;
  document.getElementById('mcSimpleBtn').classList.toggle('active', mode === 'simple');
  document.getElementById('mcAdvancedBtn').classList.toggle('active', mode === 'advanced');
  document.getElementById('mcAdvancedControls').style.display = mode === 'advanced' ? '' : 'none';
}

function loadMCAdmin() {
  const body = document.getElementById('mcParamBody');
  if (!body) return;
  body.innerHTML = mcConfig.paramDefs.map((pd, i) =>
    '<tr><td style="font-weight:600">' + pd.label + '</td>' +
    '<td><input type="number" value="' + pd.minFactor + '" step="0.1" onchange="updateMCParam(' + i + ',\'minFactor\',parseFloat(this.value))"></td>' +
    '<td><input type="number" value="' + pd.maxFactor + '" step="0.1" onchange="updateMCParam(' + i + ',\'maxFactor\',parseFloat(this.value))"></td>' +
    '<td style="font-size:10px;color:#64748b">' + pd.note + (pd.isAbsolute ? ' (absolute)' : ' (factor)') + '</td></tr>'
  ).join('');
  document.getElementById('adminMCIterations').value = mcConfig.iterations;
  document.getElementById('adminMCTolerance').value = (mcConfig.convergenceTolerance * 100);
}

function updateMCParam(idx, field, value) {
  mcConfig.paramDefs[idx][field] = value;
  saveMCConfig();
}

function saveMCAdmin() {
  mcConfig.iterations = parseInt(document.getElementById('adminMCIterations').value) || 10000;
  mcConfig.convergenceTolerance = (parseFloat(document.getElementById('adminMCTolerance').value) || 2) / 100;
  saveMCConfig();
}

function resetMCDefaults() {
  mcConfig = JSON.parse(JSON.stringify(MC_DEFAULT_CONFIG));
  saveMCConfig();
  loadMCAdmin();
  showToast('Monte Carlo parameters reset to defaults', 'info');
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// SECTION 8: INITIALIZATION
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Restore color blind mode preference
try {
  const cbPref = safeStorageGet('claimsToolColorBlind');
  if (cbPref === '1') {
    colorBlindMode = true;
    document.body.classList.add('color-blind');
    const cbToggle = document.getElementById('colorBlindToggle');
    if (cbToggle) cbToggle.checked = true;
  }
} catch(e) {}

populateSites();
updateTimeHorizonLabels();
runScenario();

// Setup chart tooltips (Issue 6)
setupChartTooltip('forecastChart', 'forecastTooltip', function(x, y, w, h) {
  if (!_forecastDisplayPeriods || !_forecastDisplayPeriods.length) return null;
  const pad = { left: 60, right: 20, top: 20, bottom: 40 };
  const chartW = w - pad.left - pad.right;
  const idx = Math.round((x - pad.left) / chartW * (_forecastDisplayPeriods.length - 1));
  if (idx < 0 || idx >= _forecastDisplayPeriods.length) return null;
  const p = _forecastDisplayPeriods[idx];
  const label = _forecastScenario && _forecastScenario.isLongTerm ? 'Month ' + p.month : 'Week ' + (p.week || p.period);
  let html = '<strong>' + label + '</strong><br>';
  html += 'New claims: ' + p.newClaims.toLocaleString() + '<br>';
  if (p.newInjury !== undefined && p.newProperty !== undefined && p.newInjury > 0) {
    html += 'Injury: ' + p.newInjury.toLocaleString() + ' / Property: ' + p.newProperty.toLocaleString() + '<br>';
  }
  html += 'Cumulative: ' + p.cumulative.toLocaleString() + '<br>';
  html += 'Backlog: ' + p.backlog.toLocaleString();
  return html;
});

// Keyboard navigation (Issue 2)
document.addEventListener('keydown', function(e) {
  // Escape closes dialogs
  if (e.key === 'Escape') {
    const confirm = document.getElementById('confirmDialog');
    if (confirm && confirm.classList.contains('active')) {
      closeConfirmDialog(false);
      return;
    }
  }
  // Ctrl+Enter runs scenario
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    e.preventDefault();
    runScenario();
  }
  // Ctrl+Shift+M runs Monte Carlo
  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'M') {
    e.preventDefault();
    runMonteCarlo();
  }
});

// Debounced resize handler (Issue 7: performance)
let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    if (document.getElementById('resultsArea').style.display !== 'none') {
      runScenario();
    }
  }, RESIZE_DEBOUNCE);
});

// ===== INLINE DOCUMENTATION TOOLTIPS (Issue 9) =====
const STAT_TERMS = {
  'P10': 'The 10th percentile — 10% of simulated outcomes fall below this value. Represents a favourable/optimistic scenario.',
  'P50': 'The 50th percentile (median) — the middle value where half of outcomes are above and half below. More robust than the mean for skewed distributions.',
  'P90': 'The 90th percentile — 90% of simulated outcomes fall below this value. Represents a conservative/adverse scenario commonly used for reserving.',
  'P95': 'The 95th percentile — only 5% of outcomes exceed this. Often used as a regulatory confidence level.',
  'Spearman correlation': 'Spearman rank correlation measures how strongly two variables move together, accounting for non-linear relationships. Values range from -1 (perfect inverse) to +1 (perfect positive). Used here to identify which input parameters most influence outputs.',
  'Gaussian copula': 'A statistical method for modelling dependencies between multiple random variables. Allows parameters to be correlated (e.g., higher claim rates tend to coincide with higher claim values) while each parameter maintains its own distribution shape.',
  'Cholesky decomposition': 'A matrix factorisation used to generate correlated random samples from a correlation matrix. Ensures the mathematical validity of the correlation structure.',
  'Triangular distribution': 'A probability distribution defined by three points: minimum, most likely (mode), and maximum. Used when limited data is available but expert judgement can estimate reasonable bounds.',
  'Convergence': 'Monte Carlo results stabilise (converge) when adding more iterations no longer significantly changes the output statistics. Early convergence saves computation time.',
  'Reserve development': 'Insurance reserves typically increase over time as more claims emerge and existing claims develop. The development factor (e.g., 1.5x) estimates the ratio of ultimate claims to initial estimates.',
  'IBNR': 'Incurred But Not Reported — claims that have occurred but not yet been filed. Common in long-tail lines like chemical exposure or nuclear incidents.'
};

// Validate correlation matrix on init
try {
  const initValidation = validateCorrelationMatrix(mcConfig.correlationMatrix, mcConfig.paramDefs);
  if (!initValidation.valid) {
    console.warn('MC correlation matrix validation warnings:', initValidation.errors);
  }
} catch(e) {}

// Log browser compatibility info
if (!supportsCanvas) { console.warn('Canvas API not supported. Charts will not render.'); }
if (!supportsLocalStorage) { console.warn('localStorage not available. Using in-memory storage.'); }
</script>
</body>
</html>
